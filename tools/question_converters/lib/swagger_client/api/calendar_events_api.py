# coding: utf-8

"""

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class CalendarEventsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_calendar_event(self, calendar_event_context_code, **kwargs):  # noqa: E501
        """Create a calendar event  # noqa: E501

        Create and return a new calendar event  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_calendar_event(calendar_event_context_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str calendar_event_context_code: Context code of the course, group, user, or account whose calendar this event should be added to. (required)
        :param str calendar_event_title: Short title for the calendar event.
        :param str calendar_event_description: Longer HTML description of the event.
        :param Object calendar_event_start_at: Start date/time of the event.
        :param Object calendar_event_end_at: End date/time of the event.
        :param str calendar_event_location_name: Location name of the event.
        :param str calendar_event_location_address: Location address
        :param str calendar_event_time_zone_edited: Time zone of the user editing the event. Allowed time zones are {http://www.iana.org/time-zones IANA time zones} or friendlier {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
        :param bool calendar_event_all_day: When true event is considered to span the whole day and times are ignored.
        :param Object calendar_event_child_event_data_x_start_at: Section-level start time(s) if this is a course event. X can be any identifier, provided that it is consistent across the start_at, end_at and context_code
        :param Object calendar_event_child_event_data_x_end_at: Section-level end time(s) if this is a course event.
        :param str calendar_event_child_event_data_x_context_code: Context code(s) corresponding to the section-level start and end time(s).
        :param float calendar_event_duplicate_count: Number of times to copy/duplicate the event.  Count cannot exceed 200.
        :param float calendar_event_duplicate_interval: Defaults to 1 if duplicate `count` is set.  The interval between the duplicated events.
        :param str calendar_event_duplicate_frequency: Defaults to \"weekly\".  The frequency at which to duplicate the event
        :param bool calendar_event_duplicate_append_iterator: Defaults to false.  If set to `true`, an increasing counter number will be appended to the event title when the event is duplicated.  (e.g. Event 1, Event 2, Event 3, etc)
        :param str calendar_event_rrule: The recurrence rule to create a series of recurring events. Its value is the {https://icalendar.org/iCalendar-RFC-5545/3-8-5-3-recurrence-rule.html iCalendar RRULE} defining how the event repeats. Unending series not supported.
        :param bool calendar_event_blackout_date: If the blackout_date is true, this event represents a holiday or some other special day that does not count in course pacing.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_calendar_event_with_http_info(calendar_event_context_code, **kwargs)  # noqa: E501
        else:
            (data) = self.create_calendar_event_with_http_info(calendar_event_context_code, **kwargs)  # noqa: E501
            return data

    def create_calendar_event_with_http_info(self, calendar_event_context_code, **kwargs):  # noqa: E501
        """Create a calendar event  # noqa: E501

        Create and return a new calendar event  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_calendar_event_with_http_info(calendar_event_context_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str calendar_event_context_code: Context code of the course, group, user, or account whose calendar this event should be added to. (required)
        :param str calendar_event_title: Short title for the calendar event.
        :param str calendar_event_description: Longer HTML description of the event.
        :param Object calendar_event_start_at: Start date/time of the event.
        :param Object calendar_event_end_at: End date/time of the event.
        :param str calendar_event_location_name: Location name of the event.
        :param str calendar_event_location_address: Location address
        :param str calendar_event_time_zone_edited: Time zone of the user editing the event. Allowed time zones are {http://www.iana.org/time-zones IANA time zones} or friendlier {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
        :param bool calendar_event_all_day: When true event is considered to span the whole day and times are ignored.
        :param Object calendar_event_child_event_data_x_start_at: Section-level start time(s) if this is a course event. X can be any identifier, provided that it is consistent across the start_at, end_at and context_code
        :param Object calendar_event_child_event_data_x_end_at: Section-level end time(s) if this is a course event.
        :param str calendar_event_child_event_data_x_context_code: Context code(s) corresponding to the section-level start and end time(s).
        :param float calendar_event_duplicate_count: Number of times to copy/duplicate the event.  Count cannot exceed 200.
        :param float calendar_event_duplicate_interval: Defaults to 1 if duplicate `count` is set.  The interval between the duplicated events.
        :param str calendar_event_duplicate_frequency: Defaults to \"weekly\".  The frequency at which to duplicate the event
        :param bool calendar_event_duplicate_append_iterator: Defaults to false.  If set to `true`, an increasing counter number will be appended to the event title when the event is duplicated.  (e.g. Event 1, Event 2, Event 3, etc)
        :param str calendar_event_rrule: The recurrence rule to create a series of recurring events. Its value is the {https://icalendar.org/iCalendar-RFC-5545/3-8-5-3-recurrence-rule.html iCalendar RRULE} defining how the event repeats. Unending series not supported.
        :param bool calendar_event_blackout_date: If the blackout_date is true, this event represents a holiday or some other special day that does not count in course pacing.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['calendar_event_context_code', 'calendar_event_title', 'calendar_event_description', 'calendar_event_start_at', 'calendar_event_end_at', 'calendar_event_location_name', 'calendar_event_location_address', 'calendar_event_time_zone_edited', 'calendar_event_all_day', 'calendar_event_child_event_data_x_start_at', 'calendar_event_child_event_data_x_end_at', 'calendar_event_child_event_data_x_context_code', 'calendar_event_duplicate_count', 'calendar_event_duplicate_interval', 'calendar_event_duplicate_frequency', 'calendar_event_duplicate_append_iterator', 'calendar_event_rrule', 'calendar_event_blackout_date']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_calendar_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'calendar_event_context_code' is set
        if self.api_client.client_side_validation and ('calendar_event_context_code' not in params or
                                                       params['calendar_event_context_code'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `calendar_event_context_code` when calling `create_calendar_event`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'calendar_event_context_code' in params:
            form_params.append(('calendar_event[context_code]', params['calendar_event_context_code']))  # noqa: E501
        if 'calendar_event_title' in params:
            form_params.append(('calendar_event[title]', params['calendar_event_title']))  # noqa: E501
        if 'calendar_event_description' in params:
            form_params.append(('calendar_event[description]', params['calendar_event_description']))  # noqa: E501
        if 'calendar_event_start_at' in params:
            form_params.append(('calendar_event[start_at]', params['calendar_event_start_at']))  # noqa: E501
        if 'calendar_event_end_at' in params:
            form_params.append(('calendar_event[end_at]', params['calendar_event_end_at']))  # noqa: E501
        if 'calendar_event_location_name' in params:
            form_params.append(('calendar_event[location_name]', params['calendar_event_location_name']))  # noqa: E501
        if 'calendar_event_location_address' in params:
            form_params.append(('calendar_event[location_address]', params['calendar_event_location_address']))  # noqa: E501
        if 'calendar_event_time_zone_edited' in params:
            form_params.append(('calendar_event[time_zone_edited]', params['calendar_event_time_zone_edited']))  # noqa: E501
        if 'calendar_event_all_day' in params:
            form_params.append(('calendar_event[all_day]', params['calendar_event_all_day']))  # noqa: E501
        if 'calendar_event_child_event_data_x_start_at' in params:
            form_params.append(('calendar_event[child_event_data][X][start_at]', params['calendar_event_child_event_data_x_start_at']))  # noqa: E501
        if 'calendar_event_child_event_data_x_end_at' in params:
            form_params.append(('calendar_event[child_event_data][X][end_at]', params['calendar_event_child_event_data_x_end_at']))  # noqa: E501
        if 'calendar_event_child_event_data_x_context_code' in params:
            form_params.append(('calendar_event[child_event_data][X][context_code]', params['calendar_event_child_event_data_x_context_code']))  # noqa: E501
        if 'calendar_event_duplicate_count' in params:
            form_params.append(('calendar_event[duplicate][count]', params['calendar_event_duplicate_count']))  # noqa: E501
        if 'calendar_event_duplicate_interval' in params:
            form_params.append(('calendar_event[duplicate][interval]', params['calendar_event_duplicate_interval']))  # noqa: E501
        if 'calendar_event_duplicate_frequency' in params:
            form_params.append(('calendar_event[duplicate][frequency]', params['calendar_event_duplicate_frequency']))  # noqa: E501
        if 'calendar_event_duplicate_append_iterator' in params:
            form_params.append(('calendar_event[duplicate][append_iterator]', params['calendar_event_duplicate_append_iterator']))  # noqa: E501
        if 'calendar_event_rrule' in params:
            form_params.append(('calendar_event[rrule]', params['calendar_event_rrule']))  # noqa: E501
        if 'calendar_event_blackout_date' in params:
            form_params.append(('calendar_event[blackout_date]', params['calendar_event_blackout_date']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/calendar_events', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_or_update_events_directly_for_course_timetable(self, course_id, **kwargs):  # noqa: E501
        """Create or update events directly for a course timetable  # noqa: E501

        Creates and updates \"timetable\" events for a course or course section. Similar to {api:CalendarEventsApiController#set_course_timetable setting a course timetable}, but instead of generating a list of events based on a timetable schedule, this endpoint expects a complete list of events.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_or_update_events_directly_for_course_timetable(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str course_section_id: Events will be created for the course section specified by course_section_id. If not present, events will be created for the entire course.
        :param list[Array] events: An array of event objects to use.
        :param list[datetime] events_start_at: Start time for the event
        :param list[datetime] events_end_at: End time for the event
        :param list[str] events_location_name: Location name for the event
        :param list[str] events_code: A unique identifier that can be used to update the event at a later time If one is not specified, an identifier will be generated based on the start and end times
        :param list[str] events_title: Title for the meeting. If not present, will default to the associated course's name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_or_update_events_directly_for_course_timetable_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_or_update_events_directly_for_course_timetable_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def create_or_update_events_directly_for_course_timetable_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Create or update events directly for a course timetable  # noqa: E501

        Creates and updates \"timetable\" events for a course or course section. Similar to {api:CalendarEventsApiController#set_course_timetable setting a course timetable}, but instead of generating a list of events based on a timetable schedule, this endpoint expects a complete list of events.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_or_update_events_directly_for_course_timetable_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str course_section_id: Events will be created for the course section specified by course_section_id. If not present, events will be created for the entire course.
        :param list[Array] events: An array of event objects to use.
        :param list[datetime] events_start_at: Start time for the event
        :param list[datetime] events_end_at: End time for the event
        :param list[str] events_location_name: Location name for the event
        :param list[str] events_code: A unique identifier that can be used to update the event at a later time If one is not specified, an identifier will be generated based on the start and end times
        :param list[str] events_title: Title for the meeting. If not present, will default to the associated course's name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'course_section_id', 'events', 'events_start_at', 'events_end_at', 'events_location_name', 'events_code', 'events_title']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_or_update_events_directly_for_course_timetable" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `create_or_update_events_directly_for_course_timetable`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'course_section_id' in params:
            form_params.append(('course_section_id', params['course_section_id']))  # noqa: E501
        if 'events' in params:
            form_params.append(('events', params['events']))  # noqa: E501
            collection_formats['events'] = 'csv'  # noqa: E501
        if 'events_start_at' in params:
            form_params.append(('events[start_at]', params['events_start_at']))  # noqa: E501
            collection_formats['events[start_at]'] = 'csv'  # noqa: E501
        if 'events_end_at' in params:
            form_params.append(('events[end_at]', params['events_end_at']))  # noqa: E501
            collection_formats['events[end_at]'] = 'csv'  # noqa: E501
        if 'events_location_name' in params:
            form_params.append(('events[location_name]', params['events_location_name']))  # noqa: E501
            collection_formats['events[location_name]'] = 'csv'  # noqa: E501
        if 'events_code' in params:
            form_params.append(('events[code]', params['events_code']))  # noqa: E501
            collection_formats['events[code]'] = 'csv'  # noqa: E501
        if 'events_title' in params:
            form_params.append(('events[title]', params['events_title']))  # noqa: E501
            collection_formats['events[title]'] = 'csv'  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/calendar_events/timetable_events', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_calendar_event(self, id, **kwargs):  # noqa: E501
        """Delete a calendar event  # noqa: E501

        Delete an event from the calendar and return the deleted event  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_calendar_event(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str cancel_reason: Reason for deleting/canceling the event.
        :param str which: Valid if the event whose ID is in the URL is part of a series. Delete just the event whose ID is in in the URL, all events in the series, or the given event and all those following.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_calendar_event_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_calendar_event_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_calendar_event_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a calendar event  # noqa: E501

        Delete an event from the calendar and return the deleted event  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_calendar_event_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str cancel_reason: Reason for deleting/canceling the event.
        :param str which: Valid if the event whose ID is in the URL is part of a series. Delete just the event whose ID is in in the URL, all events in the series, or the given event and all those following.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'cancel_reason', 'which']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_calendar_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_calendar_event`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'cancel_reason' in params:
            query_params.append(('cancel_reason', params['cancel_reason']))  # noqa: E501
        if 'which' in params:
            query_params.append(('which', params['which']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/calendar_events/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_timetable(self, course_id, **kwargs):  # noqa: E501
        """Get course timetable  # noqa: E501

        Returns the last timetable set by the {api:CalendarEventsApiController#set_course_timetable Set a course timetable} endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_timetable(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_timetable_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_timetable_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def get_course_timetable_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Get course timetable  # noqa: E501

        Returns the last timetable set by the {api:CalendarEventsApiController#set_course_timetable Set a course timetable} endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_timetable_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_timetable" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_timetable`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/calendar_events/timetable', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_single_calendar_event_or_assignment(self, id, **kwargs):  # noqa: E501
        """Get a single calendar event or assignment  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_single_calendar_event_or_assignment(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: CalendarEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_single_calendar_event_or_assignment_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_single_calendar_event_or_assignment_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_single_calendar_event_or_assignment_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a single calendar event or assignment  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_single_calendar_event_or_assignment_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: CalendarEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_single_calendar_event_or_assignment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_single_calendar_event_or_assignment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/calendar_events/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CalendarEvent',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_calendar_events(self, **kwargs):  # noqa: E501
        """List calendar events  # noqa: E501

        Retrieve the paginated list of calendar events or assignments for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_calendar_events(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type: Defaults to \"event\"
        :param Object start_date: Only return events since the start_date (inclusive). Defaults to today. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
        :param Object end_date: Only return events before the end_date (inclusive). Defaults to start_date. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ. If end_date is the same as start_date, then only events on that day are returned.
        :param bool undated: Defaults to false (dated events only). If true, only return undated events and ignore start_date and end_date.
        :param bool all_events: Defaults to false (uses start_date, end_date, and undated criteria). If true, all events are returned, ignoring start_date, end_date, and undated criteria.
        :param list[str] context_codes: List of context codes of courses, groups, users, or accounts whose events you want to see. If not specified, defaults to the current user (i.e personal calendar, no course/group events). Limited to 10 context codes, additional ones are ignored. The format of this field is the context type, followed by an underscore, followed by the context id. For example: course_42
        :param list[Array] excludes: Array of attributes to exclude. Possible values are \"description\", \"child_events\" and \"assignment\"
        :param list[Array] includes: Array of optional attributes to include. Possible values are \"web_conference\" and \"series_natural_language\"
        :param bool important_dates: Defaults to false. If true, only events with important dates set to true will be returned.
        :param bool blackout_date: Defaults to false. If true, only events with blackout date set to true will be returned.
        :return: list[CalendarEvent]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_calendar_events_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_calendar_events_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_calendar_events_with_http_info(self, **kwargs):  # noqa: E501
        """List calendar events  # noqa: E501

        Retrieve the paginated list of calendar events or assignments for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_calendar_events_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type: Defaults to \"event\"
        :param Object start_date: Only return events since the start_date (inclusive). Defaults to today. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
        :param Object end_date: Only return events before the end_date (inclusive). Defaults to start_date. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ. If end_date is the same as start_date, then only events on that day are returned.
        :param bool undated: Defaults to false (dated events only). If true, only return undated events and ignore start_date and end_date.
        :param bool all_events: Defaults to false (uses start_date, end_date, and undated criteria). If true, all events are returned, ignoring start_date, end_date, and undated criteria.
        :param list[str] context_codes: List of context codes of courses, groups, users, or accounts whose events you want to see. If not specified, defaults to the current user (i.e personal calendar, no course/group events). Limited to 10 context codes, additional ones are ignored. The format of this field is the context type, followed by an underscore, followed by the context id. For example: course_42
        :param list[Array] excludes: Array of attributes to exclude. Possible values are \"description\", \"child_events\" and \"assignment\"
        :param list[Array] includes: Array of optional attributes to include. Possible values are \"web_conference\" and \"series_natural_language\"
        :param bool important_dates: Defaults to false. If true, only events with important dates set to true will be returned.
        :param bool blackout_date: Defaults to false. If true, only events with blackout date set to true will be returned.
        :return: list[CalendarEvent]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type', 'start_date', 'end_date', 'undated', 'all_events', 'context_codes', 'excludes', 'includes', 'important_dates', 'blackout_date']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_calendar_events" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'undated' in params:
            query_params.append(('undated', params['undated']))  # noqa: E501
        if 'all_events' in params:
            query_params.append(('all_events', params['all_events']))  # noqa: E501
        if 'context_codes' in params:
            query_params.append(('context_codes', params['context_codes']))  # noqa: E501
            collection_formats['context_codes'] = 'csv'  # noqa: E501
        if 'excludes' in params:
            query_params.append(('excludes', params['excludes']))  # noqa: E501
            collection_formats['excludes'] = 'csv'  # noqa: E501
        if 'includes' in params:
            query_params.append(('includes', params['includes']))  # noqa: E501
            collection_formats['includes'] = 'csv'  # noqa: E501
        if 'important_dates' in params:
            query_params.append(('important_dates', params['important_dates']))  # noqa: E501
        if 'blackout_date' in params:
            query_params.append(('blackout_date', params['blackout_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/calendar_events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CalendarEvent]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_calendar_events_for_user(self, user_id, **kwargs):  # noqa: E501
        """List calendar events for a user  # noqa: E501

        Retrieve the paginated list of calendar events or assignments for the specified user. To view calendar events for a user other than yourself, you must either be an observer of that user or an administrator.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_calendar_events_for_user(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str type: Defaults to \"event\"
        :param Object start_date: Only return events since the start_date (inclusive). Defaults to today. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
        :param Object end_date: Only return events before the end_date (inclusive). Defaults to start_date. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ. If end_date is the same as start_date, then only events on that day are returned.
        :param bool undated: Defaults to false (dated events only). If true, only return undated events and ignore start_date and end_date.
        :param bool all_events: Defaults to false (uses start_date, end_date, and undated criteria). If true, all events are returned, ignoring start_date, end_date, and undated criteria.
        :param list[str] context_codes: List of context codes of courses, groups, users, or accounts whose events you want to see. If not specified, defaults to the current user (i.e personal calendar, no course/group events). Limited to 10 context codes, additional ones are ignored. The format of this field is the context type, followed by an underscore, followed by the context id. For example: course_42
        :param list[Array] excludes: Array of attributes to exclude. Possible values are \"description\", \"child_events\" and \"assignment\"
        :param list[Array] submission_types: When type is \"assignment\", specifies the allowable submission types for returned assignments. Ignored if type is not \"assignment\" or if exclude_submission_types is provided.
        :param list[Array] exclude_submission_types: When type is \"assignment\", specifies the submission types to be excluded from the returned assignments. Ignored if type is not \"assignment\".
        :param list[Array] includes: Array of optional attributes to include. Possible values are \"web_conference\" and \"series_natural_language\"
        :param bool important_dates: Defaults to false If true, only events with important dates set to true will be returned.
        :param bool blackout_date: Defaults to false If true, only events with blackout date set to true will be returned.
        :return: list[CalendarEvent]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_calendar_events_for_user_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_calendar_events_for_user_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def list_calendar_events_for_user_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List calendar events for a user  # noqa: E501

        Retrieve the paginated list of calendar events or assignments for the specified user. To view calendar events for a user other than yourself, you must either be an observer of that user or an administrator.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_calendar_events_for_user_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str type: Defaults to \"event\"
        :param Object start_date: Only return events since the start_date (inclusive). Defaults to today. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
        :param Object end_date: Only return events before the end_date (inclusive). Defaults to start_date. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ. If end_date is the same as start_date, then only events on that day are returned.
        :param bool undated: Defaults to false (dated events only). If true, only return undated events and ignore start_date and end_date.
        :param bool all_events: Defaults to false (uses start_date, end_date, and undated criteria). If true, all events are returned, ignoring start_date, end_date, and undated criteria.
        :param list[str] context_codes: List of context codes of courses, groups, users, or accounts whose events you want to see. If not specified, defaults to the current user (i.e personal calendar, no course/group events). Limited to 10 context codes, additional ones are ignored. The format of this field is the context type, followed by an underscore, followed by the context id. For example: course_42
        :param list[Array] excludes: Array of attributes to exclude. Possible values are \"description\", \"child_events\" and \"assignment\"
        :param list[Array] submission_types: When type is \"assignment\", specifies the allowable submission types for returned assignments. Ignored if type is not \"assignment\" or if exclude_submission_types is provided.
        :param list[Array] exclude_submission_types: When type is \"assignment\", specifies the submission types to be excluded from the returned assignments. Ignored if type is not \"assignment\".
        :param list[Array] includes: Array of optional attributes to include. Possible values are \"web_conference\" and \"series_natural_language\"
        :param bool important_dates: Defaults to false If true, only events with important dates set to true will be returned.
        :param bool blackout_date: Defaults to false If true, only events with blackout date set to true will be returned.
        :return: list[CalendarEvent]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'type', 'start_date', 'end_date', 'undated', 'all_events', 'context_codes', 'excludes', 'submission_types', 'exclude_submission_types', 'includes', 'important_dates', 'blackout_date']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_calendar_events_for_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `list_calendar_events_for_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'undated' in params:
            query_params.append(('undated', params['undated']))  # noqa: E501
        if 'all_events' in params:
            query_params.append(('all_events', params['all_events']))  # noqa: E501
        if 'context_codes' in params:
            query_params.append(('context_codes', params['context_codes']))  # noqa: E501
            collection_formats['context_codes'] = 'csv'  # noqa: E501
        if 'excludes' in params:
            query_params.append(('excludes', params['excludes']))  # noqa: E501
            collection_formats['excludes'] = 'csv'  # noqa: E501
        if 'submission_types' in params:
            query_params.append(('submission_types', params['submission_types']))  # noqa: E501
            collection_formats['submission_types'] = 'csv'  # noqa: E501
        if 'exclude_submission_types' in params:
            query_params.append(('exclude_submission_types', params['exclude_submission_types']))  # noqa: E501
            collection_formats['exclude_submission_types'] = 'csv'  # noqa: E501
        if 'includes' in params:
            query_params.append(('includes', params['includes']))  # noqa: E501
            collection_formats['includes'] = 'csv'  # noqa: E501
        if 'important_dates' in params:
            query_params.append(('important_dates', params['important_dates']))  # noqa: E501
        if 'blackout_date' in params:
            query_params.append(('blackout_date', params['blackout_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/calendar_events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CalendarEvent]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reserve_time_slot(self, id, **kwargs):  # noqa: E501
        """Reserve a time slot  # noqa: E501

        Reserves a particular time slot and return the new reservation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reserve_time_slot(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str participant_id: User or group id for whom you are making the reservation (depends on the participant type). Defaults to the current user (or user's candidate group).
        :param str comments: Comments to associate with this reservation
        :param bool cancel_existing: Defaults to false. If true, cancel any previous reservation(s) for this participant and appointment group.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reserve_time_slot_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.reserve_time_slot_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def reserve_time_slot_with_http_info(self, id, **kwargs):  # noqa: E501
        """Reserve a time slot  # noqa: E501

        Reserves a particular time slot and return the new reservation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reserve_time_slot_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str participant_id: User or group id for whom you are making the reservation (depends on the participant type). Defaults to the current user (or user's candidate group).
        :param str comments: Comments to associate with this reservation
        :param bool cancel_existing: Defaults to false. If true, cancel any previous reservation(s) for this participant and appointment group.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'participant_id', 'comments', 'cancel_existing']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reserve_time_slot" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `reserve_time_slot`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'participant_id' in params:
            form_params.append(('participant_id', params['participant_id']))  # noqa: E501
        if 'comments' in params:
            form_params.append(('comments', params['comments']))  # noqa: E501
        if 'cancel_existing' in params:
            form_params.append(('cancel_existing', params['cancel_existing']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/calendar_events/{id}/reservations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reserve_time_slot_participant_id(self, id, participant_id, **kwargs):  # noqa: E501
        """Reserve a time slot  # noqa: E501

        Reserves a particular time slot and return the new reservation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reserve_time_slot_participant_id(id, participant_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str participant_id: User or group id for whom you are making the reservation (depends on the participant type). Defaults to the current user (or user's candidate group). (required)
        :param str comments: Comments to associate with this reservation
        :param bool cancel_existing: Defaults to false. If true, cancel any previous reservation(s) for this participant and appointment group.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reserve_time_slot_participant_id_with_http_info(id, participant_id, **kwargs)  # noqa: E501
        else:
            (data) = self.reserve_time_slot_participant_id_with_http_info(id, participant_id, **kwargs)  # noqa: E501
            return data

    def reserve_time_slot_participant_id_with_http_info(self, id, participant_id, **kwargs):  # noqa: E501
        """Reserve a time slot  # noqa: E501

        Reserves a particular time slot and return the new reservation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reserve_time_slot_participant_id_with_http_info(id, participant_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str participant_id: User or group id for whom you are making the reservation (depends on the participant type). Defaults to the current user (or user's candidate group). (required)
        :param str comments: Comments to associate with this reservation
        :param bool cancel_existing: Defaults to false. If true, cancel any previous reservation(s) for this participant and appointment group.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'participant_id', 'comments', 'cancel_existing']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reserve_time_slot_participant_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `reserve_time_slot_participant_id`")  # noqa: E501
        # verify the required parameter 'participant_id' is set
        if self.api_client.client_side_validation and ('participant_id' not in params or
                                                       params['participant_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `participant_id` when calling `reserve_time_slot_participant_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'participant_id' in params:
            path_params['participant_id'] = params['participant_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'comments' in params:
            form_params.append(('comments', params['comments']))  # noqa: E501
        if 'cancel_existing' in params:
            form_params.append(('cancel_existing', params['cancel_existing']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/calendar_events/{id}/reservations/{participant_id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def save_enabled_account_calendars(self, **kwargs):  # noqa: E501
        """Save enabled account calendars  # noqa: E501

        Creates and updates the enabled_account_calendars and mark_feature_as_seen user preferences  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_enabled_account_calendars(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool mark_feature_as_seen: Flag to mark account calendars feature as seen
        :param list[Array] enabled_account_calendars: An array of account Ids to remember in the calendars list of the user
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.save_enabled_account_calendars_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.save_enabled_account_calendars_with_http_info(**kwargs)  # noqa: E501
            return data

    def save_enabled_account_calendars_with_http_info(self, **kwargs):  # noqa: E501
        """Save enabled account calendars  # noqa: E501

        Creates and updates the enabled_account_calendars and mark_feature_as_seen user preferences  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_enabled_account_calendars_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool mark_feature_as_seen: Flag to mark account calendars feature as seen
        :param list[Array] enabled_account_calendars: An array of account Ids to remember in the calendars list of the user
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mark_feature_as_seen', 'enabled_account_calendars']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method save_enabled_account_calendars" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'mark_feature_as_seen' in params:
            form_params.append(('mark_feature_as_seen', params['mark_feature_as_seen']))  # noqa: E501
        if 'enabled_account_calendars' in params:
            form_params.append(('enabled_account_calendars', params['enabled_account_calendars']))  # noqa: E501
            collection_formats['enabled_account_calendars'] = 'csv'  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/calendar_events/save_enabled_account_calendars', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_course_timetable(self, course_id, **kwargs):  # noqa: E501
        """Set a course timetable  # noqa: E501

        Creates and updates \"timetable\" events for a course. Can automaticaly generate a series of calendar events based on simple schedules (e.g. \"Monday and Wednesday at 2:00pm\" )  Existing timetable events for the course and course sections will be updated if they still are part of the timetable. Otherwise, they will be deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_timetable(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param list[Array] timetables_course_section_id: An array of timetable objects for the course section specified by course_section_id. If course_section_id is set to \"all\", events will be created for the entire course.
        :param list[str] timetables_course_section_id_weekdays: A comma-separated list of abbreviated weekdays (Mon-Monday, Tue-Tuesday, Wed-Wednesday, Thu-Thursday, Fri-Friday, Sat-Saturday, Sun-Sunday)
        :param list[str] timetables_course_section_id_start_time: Time to start each event at (e.g. \"9:00 am\")
        :param list[str] timetables_course_section_id_end_time: Time to end each event at (e.g. \"9:00 am\")
        :param list[str] timetables_course_section_id_location_name: A location name to set for each event
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_course_timetable_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.set_course_timetable_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def set_course_timetable_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Set a course timetable  # noqa: E501

        Creates and updates \"timetable\" events for a course. Can automaticaly generate a series of calendar events based on simple schedules (e.g. \"Monday and Wednesday at 2:00pm\" )  Existing timetable events for the course and course sections will be updated if they still are part of the timetable. Otherwise, they will be deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_timetable_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param list[Array] timetables_course_section_id: An array of timetable objects for the course section specified by course_section_id. If course_section_id is set to \"all\", events will be created for the entire course.
        :param list[str] timetables_course_section_id_weekdays: A comma-separated list of abbreviated weekdays (Mon-Monday, Tue-Tuesday, Wed-Wednesday, Thu-Thursday, Fri-Friday, Sat-Saturday, Sun-Sunday)
        :param list[str] timetables_course_section_id_start_time: Time to start each event at (e.g. \"9:00 am\")
        :param list[str] timetables_course_section_id_end_time: Time to end each event at (e.g. \"9:00 am\")
        :param list[str] timetables_course_section_id_location_name: A location name to set for each event
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'timetables_course_section_id', 'timetables_course_section_id_weekdays', 'timetables_course_section_id_start_time', 'timetables_course_section_id_end_time', 'timetables_course_section_id_location_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_course_timetable" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `set_course_timetable`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'timetables_course_section_id' in params:
            form_params.append(('timetables[course_section_id]', params['timetables_course_section_id']))  # noqa: E501
            collection_formats['timetables[course_section_id]'] = 'csv'  # noqa: E501
        if 'timetables_course_section_id_weekdays' in params:
            form_params.append(('timetables[course_section_id][weekdays]', params['timetables_course_section_id_weekdays']))  # noqa: E501
            collection_formats['timetables[course_section_id][weekdays]'] = 'csv'  # noqa: E501
        if 'timetables_course_section_id_start_time' in params:
            form_params.append(('timetables[course_section_id][start_time]', params['timetables_course_section_id_start_time']))  # noqa: E501
            collection_formats['timetables[course_section_id][start_time]'] = 'csv'  # noqa: E501
        if 'timetables_course_section_id_end_time' in params:
            form_params.append(('timetables[course_section_id][end_time]', params['timetables_course_section_id_end_time']))  # noqa: E501
            collection_formats['timetables[course_section_id][end_time]'] = 'csv'  # noqa: E501
        if 'timetables_course_section_id_location_name' in params:
            form_params.append(('timetables[course_section_id][location_name]', params['timetables_course_section_id_location_name']))  # noqa: E501
            collection_formats['timetables[course_section_id][location_name]'] = 'csv'  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/calendar_events/timetable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_calendar_event(self, id, **kwargs):  # noqa: E501
        """Update a calendar event  # noqa: E501

        Update and return a calendar event  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_calendar_event(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str calendar_event_context_code: Context code of the course, group, user, or account to move this event to. Scheduler appointments and events with section-specific times cannot be moved between calendars.
        :param str calendar_event_title: Short title for the calendar event.
        :param str calendar_event_description: Longer HTML description of the event.
        :param Object calendar_event_start_at: Start date/time of the event.
        :param Object calendar_event_end_at: End date/time of the event.
        :param str calendar_event_location_name: Location name of the event.
        :param str calendar_event_location_address: Location address
        :param str calendar_event_time_zone_edited: Time zone of the user editing the event. Allowed time zones are {http://www.iana.org/time-zones IANA time zones} or friendlier {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
        :param bool calendar_event_all_day: When true event is considered to span the whole day and times are ignored.
        :param Object calendar_event_child_event_data_x_start_at: Section-level start time(s) if this is a course event. X can be any identifier, provided that it is consistent across the start_at, end_at and context_code
        :param Object calendar_event_child_event_data_x_end_at: Section-level end time(s) if this is a course event.
        :param str calendar_event_child_event_data_x_context_code: Context code(s) corresponding to the section-level start and end time(s).
        :param str calendar_event_rrule: Valid if the event whose ID is in the URL is part of a series. This defines the shape of the recurring event series after it's updated. Its value is the iCalendar RRULE. Unending series are not supported.
        :param str which: Valid if the event whose ID is in the URL is part of a series. Update just the event whose ID is in in the URL, all events in the series, or the given event and all those following. Some updates may create a new series. For example, changing the start time of this and all following events from the middle of a series.
        :param bool calendar_event_blackout_date: If the blackout_date is true, this event represents a holiday or some other special day that does not count in course pacing.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_calendar_event_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_calendar_event_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_calendar_event_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update a calendar event  # noqa: E501

        Update and return a calendar event  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_calendar_event_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str calendar_event_context_code: Context code of the course, group, user, or account to move this event to. Scheduler appointments and events with section-specific times cannot be moved between calendars.
        :param str calendar_event_title: Short title for the calendar event.
        :param str calendar_event_description: Longer HTML description of the event.
        :param Object calendar_event_start_at: Start date/time of the event.
        :param Object calendar_event_end_at: End date/time of the event.
        :param str calendar_event_location_name: Location name of the event.
        :param str calendar_event_location_address: Location address
        :param str calendar_event_time_zone_edited: Time zone of the user editing the event. Allowed time zones are {http://www.iana.org/time-zones IANA time zones} or friendlier {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
        :param bool calendar_event_all_day: When true event is considered to span the whole day and times are ignored.
        :param Object calendar_event_child_event_data_x_start_at: Section-level start time(s) if this is a course event. X can be any identifier, provided that it is consistent across the start_at, end_at and context_code
        :param Object calendar_event_child_event_data_x_end_at: Section-level end time(s) if this is a course event.
        :param str calendar_event_child_event_data_x_context_code: Context code(s) corresponding to the section-level start and end time(s).
        :param str calendar_event_rrule: Valid if the event whose ID is in the URL is part of a series. This defines the shape of the recurring event series after it's updated. Its value is the iCalendar RRULE. Unending series are not supported.
        :param str which: Valid if the event whose ID is in the URL is part of a series. Update just the event whose ID is in in the URL, all events in the series, or the given event and all those following. Some updates may create a new series. For example, changing the start time of this and all following events from the middle of a series.
        :param bool calendar_event_blackout_date: If the blackout_date is true, this event represents a holiday or some other special day that does not count in course pacing.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'calendar_event_context_code', 'calendar_event_title', 'calendar_event_description', 'calendar_event_start_at', 'calendar_event_end_at', 'calendar_event_location_name', 'calendar_event_location_address', 'calendar_event_time_zone_edited', 'calendar_event_all_day', 'calendar_event_child_event_data_x_start_at', 'calendar_event_child_event_data_x_end_at', 'calendar_event_child_event_data_x_context_code', 'calendar_event_rrule', 'which', 'calendar_event_blackout_date']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_calendar_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_calendar_event`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'calendar_event_context_code' in params:
            form_params.append(('calendar_event[context_code]', params['calendar_event_context_code']))  # noqa: E501
        if 'calendar_event_title' in params:
            form_params.append(('calendar_event[title]', params['calendar_event_title']))  # noqa: E501
        if 'calendar_event_description' in params:
            form_params.append(('calendar_event[description]', params['calendar_event_description']))  # noqa: E501
        if 'calendar_event_start_at' in params:
            form_params.append(('calendar_event[start_at]', params['calendar_event_start_at']))  # noqa: E501
        if 'calendar_event_end_at' in params:
            form_params.append(('calendar_event[end_at]', params['calendar_event_end_at']))  # noqa: E501
        if 'calendar_event_location_name' in params:
            form_params.append(('calendar_event[location_name]', params['calendar_event_location_name']))  # noqa: E501
        if 'calendar_event_location_address' in params:
            form_params.append(('calendar_event[location_address]', params['calendar_event_location_address']))  # noqa: E501
        if 'calendar_event_time_zone_edited' in params:
            form_params.append(('calendar_event[time_zone_edited]', params['calendar_event_time_zone_edited']))  # noqa: E501
        if 'calendar_event_all_day' in params:
            form_params.append(('calendar_event[all_day]', params['calendar_event_all_day']))  # noqa: E501
        if 'calendar_event_child_event_data_x_start_at' in params:
            form_params.append(('calendar_event[child_event_data][X][start_at]', params['calendar_event_child_event_data_x_start_at']))  # noqa: E501
        if 'calendar_event_child_event_data_x_end_at' in params:
            form_params.append(('calendar_event[child_event_data][X][end_at]', params['calendar_event_child_event_data_x_end_at']))  # noqa: E501
        if 'calendar_event_child_event_data_x_context_code' in params:
            form_params.append(('calendar_event[child_event_data][X][context_code]', params['calendar_event_child_event_data_x_context_code']))  # noqa: E501
        if 'calendar_event_rrule' in params:
            form_params.append(('calendar_event[rrule]', params['calendar_event_rrule']))  # noqa: E501
        if 'which' in params:
            form_params.append(('which', params['which']))  # noqa: E501
        if 'calendar_event_blackout_date' in params:
            form_params.append(('calendar_event[blackout_date]', params['calendar_event_blackout_date']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/calendar_events/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
