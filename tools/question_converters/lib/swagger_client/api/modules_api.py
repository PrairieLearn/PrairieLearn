# coding: utf-8

"""

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ModulesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_module(self, course_id, module_name, **kwargs):  # noqa: E501
        """Create a module  # noqa: E501

        Create and return a new module  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_module(course_id, module_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str module_name: The name of the module (required)
        :param Object module_unlock_at: The date the module will unlock
        :param int module_position: The position of this module in the course (1-based)
        :param bool module_require_sequential_progress: Whether module items must be unlocked in order
        :param list[str] module_prerequisite_module_ids: IDs of Modules that must be completed before this one is unlocked. Prerequisite modules must precede this module (i.e. have a lower position value), otherwise they will be ignored
        :param bool module_publish_final_grade: Whether to publish the student's final grade for the course upon completion of this module.
        :return: Module
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_module_with_http_info(course_id, module_name, **kwargs)  # noqa: E501
        else:
            (data) = self.create_module_with_http_info(course_id, module_name, **kwargs)  # noqa: E501
            return data

    def create_module_with_http_info(self, course_id, module_name, **kwargs):  # noqa: E501
        """Create a module  # noqa: E501

        Create and return a new module  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_module_with_http_info(course_id, module_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str module_name: The name of the module (required)
        :param Object module_unlock_at: The date the module will unlock
        :param int module_position: The position of this module in the course (1-based)
        :param bool module_require_sequential_progress: Whether module items must be unlocked in order
        :param list[str] module_prerequisite_module_ids: IDs of Modules that must be completed before this one is unlocked. Prerequisite modules must precede this module (i.e. have a lower position value), otherwise they will be ignored
        :param bool module_publish_final_grade: Whether to publish the student's final grade for the course upon completion of this module.
        :return: Module
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'module_name', 'module_unlock_at', 'module_position', 'module_require_sequential_progress', 'module_prerequisite_module_ids', 'module_publish_final_grade']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_module" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `create_module`")  # noqa: E501
        # verify the required parameter 'module_name' is set
        if self.api_client.client_side_validation and ('module_name' not in params or
                                                       params['module_name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `module_name` when calling `create_module`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'module_name' in params:
            form_params.append(('module[name]', params['module_name']))  # noqa: E501
        if 'module_unlock_at' in params:
            form_params.append(('module[unlock_at]', params['module_unlock_at']))  # noqa: E501
        if 'module_position' in params:
            form_params.append(('module[position]', params['module_position']))  # noqa: E501
        if 'module_require_sequential_progress' in params:
            form_params.append(('module[require_sequential_progress]', params['module_require_sequential_progress']))  # noqa: E501
        if 'module_prerequisite_module_ids' in params:
            form_params.append(('module[prerequisite_module_ids]', params['module_prerequisite_module_ids']))  # noqa: E501
            collection_formats['module[prerequisite_module_ids]'] = 'csv'  # noqa: E501
        if 'module_publish_final_grade' in params:
            form_params.append(('module[publish_final_grade]', params['module_publish_final_grade']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/modules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Module',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_module_item(self, course_id, module_id, module_item_type, module_item_content_id, **kwargs):  # noqa: E501
        """Create a module item  # noqa: E501

        Create and return a new module item  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_module_item(course_id, module_id, module_item_type, module_item_content_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str module_id: ID (required)
        :param str module_item_type: The type of content linked to the item (required)
        :param str module_item_content_id: The id of the content to link to the module item. Required, except for 'ExternalUrl', 'Page', and 'SubHeader' types. (required)
        :param str module_item_title: The name of the module item and associated content
        :param int module_item_position: The position of this item in the module (1-based).
        :param int module_item_indent: 0-based indent level; module items may be indented to show a hierarchy
        :param str module_item_page_url: Suffix for the linked wiki page (e.g. 'front-page'). Required for 'Page' type.
        :param str module_item_external_url: External url that the item points to. [Required for 'ExternalUrl' and 'ExternalTool' types.
        :param bool module_item_new_tab: Whether the external tool opens in a new tab. Only applies to 'ExternalTool' type.
        :param str module_item_completion_requirement_type: Completion requirement for this module item. \"must_view\": Applies to all item types \"must_contribute\": Only applies to \"Assignment\", \"Discussion\", and \"Page\" types \"must_submit\", \"min_score\": Only apply to \"Assignment\" and \"Quiz\" types \"must_mark_done\": Only applies to \"Assignment\" and \"Page\" types Inapplicable types will be ignored
        :param int module_item_completion_requirement_min_score: Minimum score required to complete. Required for completion_requirement type 'min_score'.
        :param int module_item_iframe_width: Width of the ExternalTool on launch
        :param int module_item_iframe_height: Height of the ExternalTool on launch
        :return: ModuleItem
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_module_item_with_http_info(course_id, module_id, module_item_type, module_item_content_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_module_item_with_http_info(course_id, module_id, module_item_type, module_item_content_id, **kwargs)  # noqa: E501
            return data

    def create_module_item_with_http_info(self, course_id, module_id, module_item_type, module_item_content_id, **kwargs):  # noqa: E501
        """Create a module item  # noqa: E501

        Create and return a new module item  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_module_item_with_http_info(course_id, module_id, module_item_type, module_item_content_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str module_id: ID (required)
        :param str module_item_type: The type of content linked to the item (required)
        :param str module_item_content_id: The id of the content to link to the module item. Required, except for 'ExternalUrl', 'Page', and 'SubHeader' types. (required)
        :param str module_item_title: The name of the module item and associated content
        :param int module_item_position: The position of this item in the module (1-based).
        :param int module_item_indent: 0-based indent level; module items may be indented to show a hierarchy
        :param str module_item_page_url: Suffix for the linked wiki page (e.g. 'front-page'). Required for 'Page' type.
        :param str module_item_external_url: External url that the item points to. [Required for 'ExternalUrl' and 'ExternalTool' types.
        :param bool module_item_new_tab: Whether the external tool opens in a new tab. Only applies to 'ExternalTool' type.
        :param str module_item_completion_requirement_type: Completion requirement for this module item. \"must_view\": Applies to all item types \"must_contribute\": Only applies to \"Assignment\", \"Discussion\", and \"Page\" types \"must_submit\", \"min_score\": Only apply to \"Assignment\" and \"Quiz\" types \"must_mark_done\": Only applies to \"Assignment\" and \"Page\" types Inapplicable types will be ignored
        :param int module_item_completion_requirement_min_score: Minimum score required to complete. Required for completion_requirement type 'min_score'.
        :param int module_item_iframe_width: Width of the ExternalTool on launch
        :param int module_item_iframe_height: Height of the ExternalTool on launch
        :return: ModuleItem
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'module_id', 'module_item_type', 'module_item_content_id', 'module_item_title', 'module_item_position', 'module_item_indent', 'module_item_page_url', 'module_item_external_url', 'module_item_new_tab', 'module_item_completion_requirement_type', 'module_item_completion_requirement_min_score', 'module_item_iframe_width', 'module_item_iframe_height']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_module_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `create_module_item`")  # noqa: E501
        # verify the required parameter 'module_id' is set
        if self.api_client.client_side_validation and ('module_id' not in params or
                                                       params['module_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `module_id` when calling `create_module_item`")  # noqa: E501
        # verify the required parameter 'module_item_type' is set
        if self.api_client.client_side_validation and ('module_item_type' not in params or
                                                       params['module_item_type'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `module_item_type` when calling `create_module_item`")  # noqa: E501
        # verify the required parameter 'module_item_content_id' is set
        if self.api_client.client_side_validation and ('module_item_content_id' not in params or
                                                       params['module_item_content_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `module_item_content_id` when calling `create_module_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'module_id' in params:
            path_params['module_id'] = params['module_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'module_item_title' in params:
            form_params.append(('module_item[title]', params['module_item_title']))  # noqa: E501
        if 'module_item_type' in params:
            form_params.append(('module_item[type]', params['module_item_type']))  # noqa: E501
        if 'module_item_content_id' in params:
            form_params.append(('module_item[content_id]', params['module_item_content_id']))  # noqa: E501
        if 'module_item_position' in params:
            form_params.append(('module_item[position]', params['module_item_position']))  # noqa: E501
        if 'module_item_indent' in params:
            form_params.append(('module_item[indent]', params['module_item_indent']))  # noqa: E501
        if 'module_item_page_url' in params:
            form_params.append(('module_item[page_url]', params['module_item_page_url']))  # noqa: E501
        if 'module_item_external_url' in params:
            form_params.append(('module_item[external_url]', params['module_item_external_url']))  # noqa: E501
        if 'module_item_new_tab' in params:
            form_params.append(('module_item[new_tab]', params['module_item_new_tab']))  # noqa: E501
        if 'module_item_completion_requirement_type' in params:
            form_params.append(('module_item[completion_requirement][type]', params['module_item_completion_requirement_type']))  # noqa: E501
        if 'module_item_completion_requirement_min_score' in params:
            form_params.append(('module_item[completion_requirement][min_score]', params['module_item_completion_requirement_min_score']))  # noqa: E501
        if 'module_item_iframe_width' in params:
            form_params.append(('module_item[iframe][width]', params['module_item_iframe_width']))  # noqa: E501
        if 'module_item_iframe_height' in params:
            form_params.append(('module_item[iframe][height]', params['module_item_iframe_height']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/modules/{module_id}/items', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModuleItem',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_module(self, course_id, id, **kwargs):  # noqa: E501
        """Delete module  # noqa: E501

        Delete a module  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_module(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :return: Module
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_module_with_http_info(course_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_module_with_http_info(course_id, id, **kwargs)  # noqa: E501
            return data

    def delete_module_with_http_info(self, course_id, id, **kwargs):  # noqa: E501
        """Delete module  # noqa: E501

        Delete a module  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_module_with_http_info(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :return: Module
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_module" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `delete_module`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_module`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/modules/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Module',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_module_item(self, course_id, module_id, id, **kwargs):  # noqa: E501
        """Delete module item  # noqa: E501

        Delete a module item  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_module_item(course_id, module_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str module_id: ID (required)
        :param str id: ID (required)
        :return: ModuleItem
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_module_item_with_http_info(course_id, module_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_module_item_with_http_info(course_id, module_id, id, **kwargs)  # noqa: E501
            return data

    def delete_module_item_with_http_info(self, course_id, module_id, id, **kwargs):  # noqa: E501
        """Delete module item  # noqa: E501

        Delete a module item  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_module_item_with_http_info(course_id, module_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str module_id: ID (required)
        :param str id: ID (required)
        :return: ModuleItem
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'module_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_module_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `delete_module_item`")  # noqa: E501
        # verify the required parameter 'module_id' is set
        if self.api_client.client_side_validation and ('module_id' not in params or
                                                       params['module_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `module_id` when calling `delete_module_item`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_module_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'module_id' in params:
            path_params['module_id'] = params['module_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/modules/{module_id}/items/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModuleItem',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_module_item_sequence(self, course_id, **kwargs):  # noqa: E501
        """Get module item sequence  # noqa: E501

        Given an asset in a course, find the ModuleItem it belongs to, the previous and next Module Items in the course sequence, and also any applicable mastery path rules  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_module_item_sequence(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str asset_type: The type of asset to find module sequence information for. Use the ModuleItem if it is known (e.g., the user navigated from a module item), since this will avoid ambiguity if the asset appears more than once in the module sequence.
        :param int asset_id: The id of the asset (or the url in the case of a Page)
        :return: ModuleItemSequence
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_module_item_sequence_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_module_item_sequence_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def get_module_item_sequence_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Get module item sequence  # noqa: E501

        Given an asset in a course, find the ModuleItem it belongs to, the previous and next Module Items in the course sequence, and also any applicable mastery path rules  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_module_item_sequence_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str asset_type: The type of asset to find module sequence information for. Use the ModuleItem if it is known (e.g., the user navigated from a module item), since this will avoid ambiguity if the asset appears more than once in the module sequence.
        :param int asset_id: The id of the asset (or the url in the case of a Page)
        :return: ModuleItemSequence
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'asset_type', 'asset_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_module_item_sequence" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `get_module_item_sequence`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []
        if 'asset_type' in params:
            query_params.append(('asset_type', params['asset_type']))  # noqa: E501
        if 'asset_id' in params:
            query_params.append(('asset_id', params['asset_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/module_item_sequence', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModuleItemSequence',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_module_items(self, course_id, module_id, **kwargs):  # noqa: E501
        """List module items  # noqa: E501

        A paginated list of the items in a module  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_module_items(course_id, module_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str module_id: ID (required)
        :param list[str] include: If included, will return additional details specific to the content associated with each item. Refer to the {api:Modules:Module%20Item Module Item specification} for more details. Includes standard lock information for each item.
        :param str search_term: The partial title of the items to match and return.
        :param str student_id: Returns module completion information for the student with this id.
        :return: list[ModuleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_module_items_with_http_info(course_id, module_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_module_items_with_http_info(course_id, module_id, **kwargs)  # noqa: E501
            return data

    def list_module_items_with_http_info(self, course_id, module_id, **kwargs):  # noqa: E501
        """List module items  # noqa: E501

        A paginated list of the items in a module  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_module_items_with_http_info(course_id, module_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str module_id: ID (required)
        :param list[str] include: If included, will return additional details specific to the content associated with each item. Refer to the {api:Modules:Module%20Item Module Item specification} for more details. Includes standard lock information for each item.
        :param str search_term: The partial title of the items to match and return.
        :param str student_id: Returns module completion information for the student with this id.
        :return: list[ModuleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'module_id', 'include', 'search_term', 'student_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_module_items" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `list_module_items`")  # noqa: E501
        # verify the required parameter 'module_id' is set
        if self.api_client.client_side_validation and ('module_id' not in params or
                                                       params['module_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `module_id` when calling `list_module_items`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'module_id' in params:
            path_params['module_id'] = params['module_id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'search_term' in params:
            query_params.append(('search_term', params['search_term']))  # noqa: E501
        if 'student_id' in params:
            query_params.append(('student_id', params['student_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/modules/{module_id}/items', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ModuleItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_module_s_overrides(self, course_id, context_module_id, **kwargs):  # noqa: E501
        """List a module's overrides  # noqa: E501

        Returns a paginated list of AssignmentOverrides that apply to the ContextModule.  Note: this API is still under development and will not function until the feature is enabled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_module_s_overrides(course_id, context_module_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str context_module_id: ID (required)
        :return: list[ModuleAssignmentOverride]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_module_s_overrides_with_http_info(course_id, context_module_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_module_s_overrides_with_http_info(course_id, context_module_id, **kwargs)  # noqa: E501
            return data

    def list_module_s_overrides_with_http_info(self, course_id, context_module_id, **kwargs):  # noqa: E501
        """List a module's overrides  # noqa: E501

        Returns a paginated list of AssignmentOverrides that apply to the ContextModule.  Note: this API is still under development and will not function until the feature is enabled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_module_s_overrides_with_http_info(course_id, context_module_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str context_module_id: ID (required)
        :return: list[ModuleAssignmentOverride]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'context_module_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_module_s_overrides" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `list_module_s_overrides`")  # noqa: E501
        # verify the required parameter 'context_module_id' is set
        if self.api_client.client_side_validation and ('context_module_id' not in params or
                                                       params['context_module_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `context_module_id` when calling `list_module_s_overrides`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'context_module_id' in params:
            path_params['context_module_id'] = params['context_module_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/modules/{context_module_id}/assignment_overrides', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ModuleAssignmentOverride]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_modules(self, course_id, **kwargs):  # noqa: E501
        """List modules  # noqa: E501

        A paginated list of the modules in a course  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_modules(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param list[str] include: - \"items\": Return module items inline if possible.   This parameter suggests that Canvas return module items directly   in the Module object JSON, to avoid having to make separate API   requests for each module when enumerating modules and items. Canvas   is free to omit 'items' for any particular module if it deems them   too numerous to return inline. Callers must be prepared to use the   {api:ContextModuleItemsApiController#index List Module Items API}   if items are not returned. - \"content_details\": Requires 'items'. Returns additional   details with module items specific to their associated content items.   Includes standard lock information for each item.
        :param str search_term: The partial name of the modules (and module items, if 'items' is specified with include[]) to match and return.
        :param str student_id: Returns module completion information for the student with this id.
        :return: list[Module]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_modules_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_modules_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def list_modules_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """List modules  # noqa: E501

        A paginated list of the modules in a course  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_modules_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param list[str] include: - \"items\": Return module items inline if possible.   This parameter suggests that Canvas return module items directly   in the Module object JSON, to avoid having to make separate API   requests for each module when enumerating modules and items. Canvas   is free to omit 'items' for any particular module if it deems them   too numerous to return inline. Callers must be prepared to use the   {api:ContextModuleItemsApiController#index List Module Items API}   if items are not returned. - \"content_details\": Requires 'items'. Returns additional   details with module items specific to their associated content items.   Includes standard lock information for each item.
        :param str search_term: The partial name of the modules (and module items, if 'items' is specified with include[]) to match and return.
        :param str student_id: Returns module completion information for the student with this id.
        :return: list[Module]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'include', 'search_term', 'student_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_modules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `list_modules`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'search_term' in params:
            query_params.append(('search_term', params['search_term']))  # noqa: E501
        if 'student_id' in params:
            query_params.append(('student_id', params['student_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/modules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Module]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mark_module_item_as_done_not_done(self, course_id, module_id, id, **kwargs):  # noqa: E501
        """Mark module item as done/not done  # noqa: E501

        Mark a module item as done/not done. Use HTTP method PUT to mark as done, and DELETE to mark as not done.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_module_item_as_done_not_done(course_id, module_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str module_id: ID (required)
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mark_module_item_as_done_not_done_with_http_info(course_id, module_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.mark_module_item_as_done_not_done_with_http_info(course_id, module_id, id, **kwargs)  # noqa: E501
            return data

    def mark_module_item_as_done_not_done_with_http_info(self, course_id, module_id, id, **kwargs):  # noqa: E501
        """Mark module item as done/not done  # noqa: E501

        Mark a module item as done/not done. Use HTTP method PUT to mark as done, and DELETE to mark as not done.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_module_item_as_done_not_done_with_http_info(course_id, module_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str module_id: ID (required)
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'module_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_module_item_as_done_not_done" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `mark_module_item_as_done_not_done`")  # noqa: E501
        # verify the required parameter 'module_id' is set
        if self.api_client.client_side_validation and ('module_id' not in params or
                                                       params['module_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `module_id` when calling `mark_module_item_as_done_not_done`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `mark_module_item_as_done_not_done`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'module_id' in params:
            path_params['module_id'] = params['module_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/modules/{module_id}/items/{id}/done', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mark_module_item_read(self, course_id, module_id, id, **kwargs):  # noqa: E501
        """Mark module item read  # noqa: E501

        Fulfills \"must view\" requirement for a module item. It is generally not necessary to do this explicitly, but it is provided for applications that need to access external content directly (bypassing the html_url redirect that normally allows Canvas to fulfill \"must view\" requirements).  This endpoint cannot be used to complete requirements on locked or unpublished module items.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_module_item_read(course_id, module_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str module_id: ID (required)
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mark_module_item_read_with_http_info(course_id, module_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.mark_module_item_read_with_http_info(course_id, module_id, id, **kwargs)  # noqa: E501
            return data

    def mark_module_item_read_with_http_info(self, course_id, module_id, id, **kwargs):  # noqa: E501
        """Mark module item read  # noqa: E501

        Fulfills \"must view\" requirement for a module item. It is generally not necessary to do this explicitly, but it is provided for applications that need to access external content directly (bypassing the html_url redirect that normally allows Canvas to fulfill \"must view\" requirements).  This endpoint cannot be used to complete requirements on locked or unpublished module items.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_module_item_read_with_http_info(course_id, module_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str module_id: ID (required)
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'module_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_module_item_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `mark_module_item_read`")  # noqa: E501
        # verify the required parameter 'module_id' is set
        if self.api_client.client_side_validation and ('module_id' not in params or
                                                       params['module_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `module_id` when calling `mark_module_item_read`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `mark_module_item_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'module_id' in params:
            path_params['module_id'] = params['module_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/modules/{module_id}/items/{id}/mark_read', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def re_lock_module_progressions(self, course_id, id, **kwargs):  # noqa: E501
        """Re-lock module progressions  # noqa: E501

        Resets module progressions to their default locked state and recalculates them based on the current requirements.  Adding progression requirements to an active course will not lock students out of modules they have already unlocked unless this action is called.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.re_lock_module_progressions(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :return: Module
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.re_lock_module_progressions_with_http_info(course_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.re_lock_module_progressions_with_http_info(course_id, id, **kwargs)  # noqa: E501
            return data

    def re_lock_module_progressions_with_http_info(self, course_id, id, **kwargs):  # noqa: E501
        """Re-lock module progressions  # noqa: E501

        Resets module progressions to their default locked state and recalculates them based on the current requirements.  Adding progression requirements to an active course will not lock students out of modules they have already unlocked unless this action is called.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.re_lock_module_progressions_with_http_info(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :return: Module
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method re_lock_module_progressions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `re_lock_module_progressions`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `re_lock_module_progressions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/modules/{id}/relock', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Module',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def select_mastery_path(self, course_id, module_id, id, **kwargs):  # noqa: E501
        """Select a mastery path  # noqa: E501

        Select a mastery path when module item includes several possible paths. Requires Mastery Paths feature to be enabled.  Returns a compound document with the assignments included in the given path and any module items related to those assignments  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.select_mastery_path(course_id, module_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str module_id: ID (required)
        :param str id: ID (required)
        :param str assignment_set_id: Assignment set chosen, as specified in the mastery_paths portion of the context module item response
        :param str student_id: Which student the selection applies to.  If not specified, current user is implied.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.select_mastery_path_with_http_info(course_id, module_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.select_mastery_path_with_http_info(course_id, module_id, id, **kwargs)  # noqa: E501
            return data

    def select_mastery_path_with_http_info(self, course_id, module_id, id, **kwargs):  # noqa: E501
        """Select a mastery path  # noqa: E501

        Select a mastery path when module item includes several possible paths. Requires Mastery Paths feature to be enabled.  Returns a compound document with the assignments included in the given path and any module items related to those assignments  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.select_mastery_path_with_http_info(course_id, module_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str module_id: ID (required)
        :param str id: ID (required)
        :param str assignment_set_id: Assignment set chosen, as specified in the mastery_paths portion of the context module item response
        :param str student_id: Which student the selection applies to.  If not specified, current user is implied.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'module_id', 'id', 'assignment_set_id', 'student_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method select_mastery_path" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `select_mastery_path`")  # noqa: E501
        # verify the required parameter 'module_id' is set
        if self.api_client.client_side_validation and ('module_id' not in params or
                                                       params['module_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `module_id` when calling `select_mastery_path`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `select_mastery_path`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'module_id' in params:
            path_params['module_id'] = params['module_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'assignment_set_id' in params:
            form_params.append(('assignment_set_id', params['assignment_set_id']))  # noqa: E501
        if 'student_id' in params:
            form_params.append(('student_id', params['student_id']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/modules/{module_id}/items/{id}/select_mastery_path', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_module(self, course_id, id, **kwargs):  # noqa: E501
        """Show module  # noqa: E501

        Get information about a single module  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_module(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :param list[str] include: - \"items\": Return module items inline if possible.   This parameter suggests that Canvas return module items directly   in the Module object JSON, to avoid having to make separate API   requests for each module when enumerating modules and items. Canvas   is free to omit 'items' for any particular module if it deems them   too numerous to return inline. Callers must be prepared to use the   {api:ContextModuleItemsApiController#index List Module Items API}   if items are not returned. - \"content_details\": Requires 'items'. Returns additional   details with module items specific to their associated content items.   Includes standard lock information for each item.
        :param str student_id: Returns module completion information for the student with this id.
        :return: Module
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_module_with_http_info(course_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.show_module_with_http_info(course_id, id, **kwargs)  # noqa: E501
            return data

    def show_module_with_http_info(self, course_id, id, **kwargs):  # noqa: E501
        """Show module  # noqa: E501

        Get information about a single module  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_module_with_http_info(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :param list[str] include: - \"items\": Return module items inline if possible.   This parameter suggests that Canvas return module items directly   in the Module object JSON, to avoid having to make separate API   requests for each module when enumerating modules and items. Canvas   is free to omit 'items' for any particular module if it deems them   too numerous to return inline. Callers must be prepared to use the   {api:ContextModuleItemsApiController#index List Module Items API}   if items are not returned. - \"content_details\": Requires 'items'. Returns additional   details with module items specific to their associated content items.   Includes standard lock information for each item.
        :param str student_id: Returns module completion information for the student with this id.
        :return: Module
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'id', 'include', 'student_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_module" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `show_module`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `show_module`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'student_id' in params:
            query_params.append(('student_id', params['student_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/modules/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Module',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_module_item(self, course_id, module_id, id, **kwargs):  # noqa: E501
        """Show module item  # noqa: E501

        Get information about a single module item  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_module_item(course_id, module_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str module_id: ID (required)
        :param str id: ID (required)
        :param list[str] include: If included, will return additional details specific to the content associated with this item. Refer to the {api:Modules:Module%20Item Module Item specification} for more details. Includes standard lock information for each item.
        :param str student_id: Returns module completion information for the student with this id.
        :return: ModuleItem
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_module_item_with_http_info(course_id, module_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.show_module_item_with_http_info(course_id, module_id, id, **kwargs)  # noqa: E501
            return data

    def show_module_item_with_http_info(self, course_id, module_id, id, **kwargs):  # noqa: E501
        """Show module item  # noqa: E501

        Get information about a single module item  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_module_item_with_http_info(course_id, module_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str module_id: ID (required)
        :param str id: ID (required)
        :param list[str] include: If included, will return additional details specific to the content associated with this item. Refer to the {api:Modules:Module%20Item Module Item specification} for more details. Includes standard lock information for each item.
        :param str student_id: Returns module completion information for the student with this id.
        :return: ModuleItem
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'module_id', 'id', 'include', 'student_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_module_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `show_module_item`")  # noqa: E501
        # verify the required parameter 'module_id' is set
        if self.api_client.client_side_validation and ('module_id' not in params or
                                                       params['module_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `module_id` when calling `show_module_item`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `show_module_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'module_id' in params:
            path_params['module_id'] = params['module_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'student_id' in params:
            query_params.append(('student_id', params['student_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/modules/{module_id}/items/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModuleItem',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_module(self, course_id, id, **kwargs):  # noqa: E501
        """Update a module  # noqa: E501

        Update and return an existing module  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_module(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :param str module_name: The name of the module
        :param Object module_unlock_at: The date the module will unlock
        :param int module_position: The position of the module in the course (1-based)
        :param bool module_require_sequential_progress: Whether module items must be unlocked in order
        :param list[str] module_prerequisite_module_ids: IDs of Modules that must be completed before this one is unlocked Prerequisite modules must precede this module (i.e. have a lower position value), otherwise they will be ignored
        :param bool module_publish_final_grade: Whether to publish the student's final grade for the course upon completion of this module.
        :param bool module_published: Whether the module is published and visible to students
        :return: Module
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_module_with_http_info(course_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_module_with_http_info(course_id, id, **kwargs)  # noqa: E501
            return data

    def update_module_with_http_info(self, course_id, id, **kwargs):  # noqa: E501
        """Update a module  # noqa: E501

        Update and return an existing module  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_module_with_http_info(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :param str module_name: The name of the module
        :param Object module_unlock_at: The date the module will unlock
        :param int module_position: The position of the module in the course (1-based)
        :param bool module_require_sequential_progress: Whether module items must be unlocked in order
        :param list[str] module_prerequisite_module_ids: IDs of Modules that must be completed before this one is unlocked Prerequisite modules must precede this module (i.e. have a lower position value), otherwise they will be ignored
        :param bool module_publish_final_grade: Whether to publish the student's final grade for the course upon completion of this module.
        :param bool module_published: Whether the module is published and visible to students
        :return: Module
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'id', 'module_name', 'module_unlock_at', 'module_position', 'module_require_sequential_progress', 'module_prerequisite_module_ids', 'module_publish_final_grade', 'module_published']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_module" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `update_module`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_module`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'module_name' in params:
            form_params.append(('module[name]', params['module_name']))  # noqa: E501
        if 'module_unlock_at' in params:
            form_params.append(('module[unlock_at]', params['module_unlock_at']))  # noqa: E501
        if 'module_position' in params:
            form_params.append(('module[position]', params['module_position']))  # noqa: E501
        if 'module_require_sequential_progress' in params:
            form_params.append(('module[require_sequential_progress]', params['module_require_sequential_progress']))  # noqa: E501
        if 'module_prerequisite_module_ids' in params:
            form_params.append(('module[prerequisite_module_ids]', params['module_prerequisite_module_ids']))  # noqa: E501
            collection_formats['module[prerequisite_module_ids]'] = 'csv'  # noqa: E501
        if 'module_publish_final_grade' in params:
            form_params.append(('module[publish_final_grade]', params['module_publish_final_grade']))  # noqa: E501
        if 'module_published' in params:
            form_params.append(('module[published]', params['module_published']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/modules/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Module',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_module_item(self, course_id, module_id, id, **kwargs):  # noqa: E501
        """Update a module item  # noqa: E501

        Update and return an existing module item  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_module_item(course_id, module_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str module_id: ID (required)
        :param str id: ID (required)
        :param str module_item_title: The name of the module item
        :param int module_item_position: The position of this item in the module (1-based)
        :param int module_item_indent: 0-based indent level; module items may be indented to show a hierarchy
        :param str module_item_external_url: External url that the item points to. Only applies to 'ExternalUrl' type.
        :param bool module_item_new_tab: Whether the external tool opens in a new tab. Only applies to 'ExternalTool' type.
        :param str module_item_completion_requirement_type: Completion requirement for this module item. \"must_view\": Applies to all item types \"must_contribute\": Only applies to \"Assignment\", \"Discussion\", and \"Page\" types \"must_submit\", \"min_score\": Only apply to \"Assignment\" and \"Quiz\" types \"must_mark_done\": Only applies to \"Assignment\" and \"Page\" types Inapplicable types will be ignored
        :param int module_item_completion_requirement_min_score: Minimum score required to complete, Required for completion_requirement type 'min_score'.
        :param bool module_item_published: Whether the module item is published and visible to students.
        :param str module_item_module_id: Move this item to another module by specifying the target module id here. The target module must be in the same course.
        :return: ModuleItem
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_module_item_with_http_info(course_id, module_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_module_item_with_http_info(course_id, module_id, id, **kwargs)  # noqa: E501
            return data

    def update_module_item_with_http_info(self, course_id, module_id, id, **kwargs):  # noqa: E501
        """Update a module item  # noqa: E501

        Update and return an existing module item  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_module_item_with_http_info(course_id, module_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str module_id: ID (required)
        :param str id: ID (required)
        :param str module_item_title: The name of the module item
        :param int module_item_position: The position of this item in the module (1-based)
        :param int module_item_indent: 0-based indent level; module items may be indented to show a hierarchy
        :param str module_item_external_url: External url that the item points to. Only applies to 'ExternalUrl' type.
        :param bool module_item_new_tab: Whether the external tool opens in a new tab. Only applies to 'ExternalTool' type.
        :param str module_item_completion_requirement_type: Completion requirement for this module item. \"must_view\": Applies to all item types \"must_contribute\": Only applies to \"Assignment\", \"Discussion\", and \"Page\" types \"must_submit\", \"min_score\": Only apply to \"Assignment\" and \"Quiz\" types \"must_mark_done\": Only applies to \"Assignment\" and \"Page\" types Inapplicable types will be ignored
        :param int module_item_completion_requirement_min_score: Minimum score required to complete, Required for completion_requirement type 'min_score'.
        :param bool module_item_published: Whether the module item is published and visible to students.
        :param str module_item_module_id: Move this item to another module by specifying the target module id here. The target module must be in the same course.
        :return: ModuleItem
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'module_id', 'id', 'module_item_title', 'module_item_position', 'module_item_indent', 'module_item_external_url', 'module_item_new_tab', 'module_item_completion_requirement_type', 'module_item_completion_requirement_min_score', 'module_item_published', 'module_item_module_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_module_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `update_module_item`")  # noqa: E501
        # verify the required parameter 'module_id' is set
        if self.api_client.client_side_validation and ('module_id' not in params or
                                                       params['module_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `module_id` when calling `update_module_item`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_module_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'module_id' in params:
            path_params['module_id'] = params['module_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'module_item_title' in params:
            form_params.append(('module_item[title]', params['module_item_title']))  # noqa: E501
        if 'module_item_position' in params:
            form_params.append(('module_item[position]', params['module_item_position']))  # noqa: E501
        if 'module_item_indent' in params:
            form_params.append(('module_item[indent]', params['module_item_indent']))  # noqa: E501
        if 'module_item_external_url' in params:
            form_params.append(('module_item[external_url]', params['module_item_external_url']))  # noqa: E501
        if 'module_item_new_tab' in params:
            form_params.append(('module_item[new_tab]', params['module_item_new_tab']))  # noqa: E501
        if 'module_item_completion_requirement_type' in params:
            form_params.append(('module_item[completion_requirement][type]', params['module_item_completion_requirement_type']))  # noqa: E501
        if 'module_item_completion_requirement_min_score' in params:
            form_params.append(('module_item[completion_requirement][min_score]', params['module_item_completion_requirement_min_score']))  # noqa: E501
        if 'module_item_published' in params:
            form_params.append(('module_item[published]', params['module_item_published']))  # noqa: E501
        if 'module_item_module_id' in params:
            form_params.append(('module_item[module_id]', params['module_item_module_id']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/modules/{module_id}/items/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModuleItem',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_module_s_overrides(self, course_id, context_module_id, overrides, **kwargs):  # noqa: E501
        """Update a module's overrides  # noqa: E501

        Accepts a list of overrides and applies them to the ContextModule. Returns 204 No Content response code if successful.  Note: this API is still under development and will not function until the feature is enabled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_module_s_overrides(course_id, context_module_id, overrides, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str context_module_id: ID (required)
        :param list[Array] overrides: List of overrides to apply to the module. Overrides that already exist should include an ID and will be updated if needed. New overrides will be created for overrides in the list without an ID. Overrides not included in the list will be deleted. Providing an empty list will delete all of the module's overrides. Keys for each override object can include: 'id', 'title', 'student_ids', and 'course_section_id'. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_module_s_overrides_with_http_info(course_id, context_module_id, overrides, **kwargs)  # noqa: E501
        else:
            (data) = self.update_module_s_overrides_with_http_info(course_id, context_module_id, overrides, **kwargs)  # noqa: E501
            return data

    def update_module_s_overrides_with_http_info(self, course_id, context_module_id, overrides, **kwargs):  # noqa: E501
        """Update a module's overrides  # noqa: E501

        Accepts a list of overrides and applies them to the ContextModule. Returns 204 No Content response code if successful.  Note: this API is still under development and will not function until the feature is enabled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_module_s_overrides_with_http_info(course_id, context_module_id, overrides, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str context_module_id: ID (required)
        :param list[Array] overrides: List of overrides to apply to the module. Overrides that already exist should include an ID and will be updated if needed. New overrides will be created for overrides in the list without an ID. Overrides not included in the list will be deleted. Providing an empty list will delete all of the module's overrides. Keys for each override object can include: 'id', 'title', 'student_ids', and 'course_section_id'. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'context_module_id', 'overrides']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_module_s_overrides" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `update_module_s_overrides`")  # noqa: E501
        # verify the required parameter 'context_module_id' is set
        if self.api_client.client_side_validation and ('context_module_id' not in params or
                                                       params['context_module_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `context_module_id` when calling `update_module_s_overrides`")  # noqa: E501
        # verify the required parameter 'overrides' is set
        if self.api_client.client_side_validation and ('overrides' not in params or
                                                       params['overrides'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `overrides` when calling `update_module_s_overrides`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'context_module_id' in params:
            path_params['context_module_id'] = params['context_module_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'overrides' in params:
            form_params.append(('overrides', params['overrides']))  # noqa: E501
            collection_formats['overrides'] = 'csv'  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/modules/{context_module_id}/assignment_overrides', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
