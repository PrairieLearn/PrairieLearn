# coding: utf-8

"""

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class AppointmentGroupsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_appointment_group(self, appointment_group_context_codes, appointment_group_title, **kwargs):  # noqa: E501
        """Create an appointment group  # noqa: E501

        Create and return a new appointment group. If new_appointments are specified, the response will return a new_appointments array (same format as appointments array, see \"List appointment groups\" action)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_appointment_group(appointment_group_context_codes, appointment_group_title, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] appointment_group_context_codes: Array of context codes (courses, e.g. course_1) this group should be linked to (1 or more). Users in the course(s) with appropriate permissions will be able to sign up for this appointment group. (required)
        :param str appointment_group_title: Short title for the appointment group. (required)
        :param list[str] appointment_group_sub_context_codes: Array of sub context codes (course sections or a single group category) this group should be linked to. Used to limit the appointment group to particular sections. If a group category is specified, students will sign up in groups and the participant_type will be \"Group\" instead of \"User\".
        :param str appointment_group_description: Longer text description of the appointment group.
        :param str appointment_group_location_name: Location name of the appointment group.
        :param str appointment_group_location_address: Location address.
        :param bool appointment_group_publish: Indicates whether this appointment group should be published (i.e. made available for signup). Once published, an appointment group cannot be unpublished. Defaults to false.
        :param int appointment_group_participants_per_appointment: Maximum number of participants that may register for each time slot. Defaults to null (no limit).
        :param int appointment_group_min_appointments_per_participant: Minimum number of time slots a user must register for. If not set, users do not need to sign up for any time slots.
        :param int appointment_group_max_appointments_per_participant: Maximum number of time slots a user may register for.
        :param list[str] appointment_group_new_appointments_x: Nested array of start time/end time pairs indicating time slots for this appointment group. Refer to the example request.
        :param str appointment_group_participant_visibility: \"private\":: participants cannot see who has signed up for a particular             time slot \"protected\":: participants can see who has signed up.  Defaults to               \"private\".
        :param bool appointment_group_allow_observer_signup: Whether observer users can sign-up for an appointment. Defaults to false.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_appointment_group_with_http_info(appointment_group_context_codes, appointment_group_title, **kwargs)  # noqa: E501
        else:
            (data) = self.create_appointment_group_with_http_info(appointment_group_context_codes, appointment_group_title, **kwargs)  # noqa: E501
            return data

    def create_appointment_group_with_http_info(self, appointment_group_context_codes, appointment_group_title, **kwargs):  # noqa: E501
        """Create an appointment group  # noqa: E501

        Create and return a new appointment group. If new_appointments are specified, the response will return a new_appointments array (same format as appointments array, see \"List appointment groups\" action)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_appointment_group_with_http_info(appointment_group_context_codes, appointment_group_title, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] appointment_group_context_codes: Array of context codes (courses, e.g. course_1) this group should be linked to (1 or more). Users in the course(s) with appropriate permissions will be able to sign up for this appointment group. (required)
        :param str appointment_group_title: Short title for the appointment group. (required)
        :param list[str] appointment_group_sub_context_codes: Array of sub context codes (course sections or a single group category) this group should be linked to. Used to limit the appointment group to particular sections. If a group category is specified, students will sign up in groups and the participant_type will be \"Group\" instead of \"User\".
        :param str appointment_group_description: Longer text description of the appointment group.
        :param str appointment_group_location_name: Location name of the appointment group.
        :param str appointment_group_location_address: Location address.
        :param bool appointment_group_publish: Indicates whether this appointment group should be published (i.e. made available for signup). Once published, an appointment group cannot be unpublished. Defaults to false.
        :param int appointment_group_participants_per_appointment: Maximum number of participants that may register for each time slot. Defaults to null (no limit).
        :param int appointment_group_min_appointments_per_participant: Minimum number of time slots a user must register for. If not set, users do not need to sign up for any time slots.
        :param int appointment_group_max_appointments_per_participant: Maximum number of time slots a user may register for.
        :param list[str] appointment_group_new_appointments_x: Nested array of start time/end time pairs indicating time slots for this appointment group. Refer to the example request.
        :param str appointment_group_participant_visibility: \"private\":: participants cannot see who has signed up for a particular             time slot \"protected\":: participants can see who has signed up.  Defaults to               \"private\".
        :param bool appointment_group_allow_observer_signup: Whether observer users can sign-up for an appointment. Defaults to false.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['appointment_group_context_codes', 'appointment_group_title', 'appointment_group_sub_context_codes', 'appointment_group_description', 'appointment_group_location_name', 'appointment_group_location_address', 'appointment_group_publish', 'appointment_group_participants_per_appointment', 'appointment_group_min_appointments_per_participant', 'appointment_group_max_appointments_per_participant', 'appointment_group_new_appointments_x', 'appointment_group_participant_visibility', 'appointment_group_allow_observer_signup']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_appointment_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'appointment_group_context_codes' is set
        if self.api_client.client_side_validation and ('appointment_group_context_codes' not in params or
                                                       params['appointment_group_context_codes'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `appointment_group_context_codes` when calling `create_appointment_group`")  # noqa: E501
        # verify the required parameter 'appointment_group_title' is set
        if self.api_client.client_side_validation and ('appointment_group_title' not in params or
                                                       params['appointment_group_title'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `appointment_group_title` when calling `create_appointment_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'appointment_group_context_codes' in params:
            form_params.append(('appointment_group[context_codes]', params['appointment_group_context_codes']))  # noqa: E501
            collection_formats['appointment_group[context_codes]'] = 'csv'  # noqa: E501
        if 'appointment_group_sub_context_codes' in params:
            form_params.append(('appointment_group[sub_context_codes]', params['appointment_group_sub_context_codes']))  # noqa: E501
            collection_formats['appointment_group[sub_context_codes]'] = 'csv'  # noqa: E501
        if 'appointment_group_title' in params:
            form_params.append(('appointment_group[title]', params['appointment_group_title']))  # noqa: E501
        if 'appointment_group_description' in params:
            form_params.append(('appointment_group[description]', params['appointment_group_description']))  # noqa: E501
        if 'appointment_group_location_name' in params:
            form_params.append(('appointment_group[location_name]', params['appointment_group_location_name']))  # noqa: E501
        if 'appointment_group_location_address' in params:
            form_params.append(('appointment_group[location_address]', params['appointment_group_location_address']))  # noqa: E501
        if 'appointment_group_publish' in params:
            form_params.append(('appointment_group[publish]', params['appointment_group_publish']))  # noqa: E501
        if 'appointment_group_participants_per_appointment' in params:
            form_params.append(('appointment_group[participants_per_appointment]', params['appointment_group_participants_per_appointment']))  # noqa: E501
        if 'appointment_group_min_appointments_per_participant' in params:
            form_params.append(('appointment_group[min_appointments_per_participant]', params['appointment_group_min_appointments_per_participant']))  # noqa: E501
        if 'appointment_group_max_appointments_per_participant' in params:
            form_params.append(('appointment_group[max_appointments_per_participant]', params['appointment_group_max_appointments_per_participant']))  # noqa: E501
        if 'appointment_group_new_appointments_x' in params:
            form_params.append(('appointment_group[new_appointments][X]', params['appointment_group_new_appointments_x']))  # noqa: E501
            collection_formats['appointment_group[new_appointments][X]'] = 'csv'  # noqa: E501
        if 'appointment_group_participant_visibility' in params:
            form_params.append(('appointment_group[participant_visibility]', params['appointment_group_participant_visibility']))  # noqa: E501
        if 'appointment_group_allow_observer_signup' in params:
            form_params.append(('appointment_group[allow_observer_signup]', params['appointment_group_allow_observer_signup']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/appointment_groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_appointment_group(self, id, **kwargs):  # noqa: E501
        """Delete an appointment group  # noqa: E501

        Delete an appointment group (and associated time slots and reservations) and return the deleted group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_appointment_group(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str cancel_reason: Reason for deleting/canceling the appointment group.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_appointment_group_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_appointment_group_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_appointment_group_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete an appointment group  # noqa: E501

        Delete an appointment group (and associated time slots and reservations) and return the deleted group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_appointment_group_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str cancel_reason: Reason for deleting/canceling the appointment group.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'cancel_reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_appointment_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_appointment_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'cancel_reason' in params:
            query_params.append(('cancel_reason', params['cancel_reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/appointment_groups/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_next_appointment(self, **kwargs):  # noqa: E501
        """Get next appointment  # noqa: E501

        Return the next appointment available to sign up for. The appointment is returned in a one-element array. If no future appointments are available, an empty array is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_next_appointment(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] appointment_group_ids: List of ids of appointment groups to search.
        :return: list[CalendarEvent]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_next_appointment_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_next_appointment_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_next_appointment_with_http_info(self, **kwargs):  # noqa: E501
        """Get next appointment  # noqa: E501

        Return the next appointment available to sign up for. The appointment is returned in a one-element array. If no future appointments are available, an empty array is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_next_appointment_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] appointment_group_ids: List of ids of appointment groups to search.
        :return: list[CalendarEvent]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['appointment_group_ids']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_next_appointment" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'appointment_group_ids' in params:
            query_params.append(('appointment_group_ids', params['appointment_group_ids']))  # noqa: E501
            collection_formats['appointment_group_ids'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/appointment_groups/next_appointment', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CalendarEvent]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_single_appointment_group(self, id, **kwargs):  # noqa: E501
        """Get a single appointment group  # noqa: E501

        Returns information for a single appointment group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_single_appointment_group(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param list[str] include: Array of additional information to include. See include[] argument of \"List appointment groups\" action.  \"child_events\":: reservations of time slots time slots \"appointments\":: will always be returned \"all_context_codes\":: all context codes associated with this appointment group
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_single_appointment_group_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_single_appointment_group_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_single_appointment_group_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a single appointment group  # noqa: E501

        Returns information for a single appointment group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_single_appointment_group_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param list[str] include: Array of additional information to include. See include[] argument of \"List appointment groups\" action.  \"child_events\":: reservations of time slots time slots \"appointments\":: will always be returned \"all_context_codes\":: all context codes associated with this appointment group
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_single_appointment_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_single_appointment_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/appointment_groups/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_appointment_groups(self, **kwargs):  # noqa: E501
        """List appointment groups  # noqa: E501

        Retrieve the paginated list of appointment groups that can be reserved or managed by the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_appointment_groups(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str scope: Defaults to \"reservable\"
        :param list[str] context_codes: Array of context codes used to limit returned results.
        :param bool include_past_appointments: Defaults to false. If true, includes past appointment groups
        :param list[str] include: Array of additional information to include.  \"appointments\":: calendar event time slots for this appointment group \"child_events\":: reservations of those time slots \"participant_count\":: number of reservations \"reserved_times\":: the event id, start time and end time of reservations                    the current user has made) \"all_context_codes\":: all context codes associated with this appointment group
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_appointment_groups_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_appointment_groups_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_appointment_groups_with_http_info(self, **kwargs):  # noqa: E501
        """List appointment groups  # noqa: E501

        Retrieve the paginated list of appointment groups that can be reserved or managed by the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_appointment_groups_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str scope: Defaults to \"reservable\"
        :param list[str] context_codes: Array of context codes used to limit returned results.
        :param bool include_past_appointments: Defaults to false. If true, includes past appointment groups
        :param list[str] include: Array of additional information to include.  \"appointments\":: calendar event time slots for this appointment group \"child_events\":: reservations of those time slots \"participant_count\":: number of reservations \"reserved_times\":: the event id, start time and end time of reservations                    the current user has made) \"all_context_codes\":: all context codes associated with this appointment group
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['scope', 'context_codes', 'include_past_appointments', 'include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_appointment_groups" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'scope' in params:
            query_params.append(('scope', params['scope']))  # noqa: E501
        if 'context_codes' in params:
            query_params.append(('context_codes', params['context_codes']))  # noqa: E501
            collection_formats['context_codes'] = 'csv'  # noqa: E501
        if 'include_past_appointments' in params:
            query_params.append(('include_past_appointments', params['include_past_appointments']))  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/appointment_groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_student_group_participants(self, id, **kwargs):  # noqa: E501
        """List student group participants  # noqa: E501

        A paginated list of student groups that are (or may be) participating in this appointment group. Refer to the Groups API for the response fields. Returns no results for appointment groups with the \"User\" participant_type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_student_group_participants(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str registration_status: Limits results to the a given participation status, defaults to \"all\"
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_student_group_participants_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_student_group_participants_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def list_student_group_participants_with_http_info(self, id, **kwargs):  # noqa: E501
        """List student group participants  # noqa: E501

        A paginated list of student groups that are (or may be) participating in this appointment group. Refer to the Groups API for the response fields. Returns no results for appointment groups with the \"User\" participant_type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_student_group_participants_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str registration_status: Limits results to the a given participation status, defaults to \"all\"
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'registration_status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_student_group_participants" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `list_student_group_participants`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'registration_status' in params:
            query_params.append(('registration_status', params['registration_status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/appointment_groups/{id}/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_user_participants(self, id, **kwargs):  # noqa: E501
        """List user participants  # noqa: E501

        A paginated list of users that are (or may be) participating in this appointment group.  Refer to the Users API for the response fields. Returns no results for appointment groups with the \"Group\" participant_type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_user_participants(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str registration_status: Limits results to the a given participation status, defaults to \"all\"
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_user_participants_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_user_participants_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def list_user_participants_with_http_info(self, id, **kwargs):  # noqa: E501
        """List user participants  # noqa: E501

        A paginated list of users that are (or may be) participating in this appointment group.  Refer to the Users API for the response fields. Returns no results for appointment groups with the \"Group\" participant_type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_user_participants_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str registration_status: Limits results to the a given participation status, defaults to \"all\"
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'registration_status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_user_participants" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `list_user_participants`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'registration_status' in params:
            query_params.append(('registration_status', params['registration_status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/appointment_groups/{id}/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_appointment_group(self, id, appointment_group_context_codes, **kwargs):  # noqa: E501
        """Update an appointment group  # noqa: E501

        Update and return an appointment group. If new_appointments are specified, the response will return a new_appointments array (same format as appointments array, see \"List appointment groups\" action).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_appointment_group(id, appointment_group_context_codes, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param list[str] appointment_group_context_codes: Array of context codes (courses, e.g. course_1) this group should be linked to (1 or more). Users in the course(s) with appropriate permissions will be able to sign up for this appointment group. (required)
        :param list[str] appointment_group_sub_context_codes: Array of sub context codes (course sections or a single group category) this group should be linked to. Used to limit the appointment group to particular sections. If a group category is specified, students will sign up in groups and the participant_type will be \"Group\" instead of \"User\".
        :param str appointment_group_title: Short title for the appointment group.
        :param str appointment_group_description: Longer text description of the appointment group.
        :param str appointment_group_location_name: Location name of the appointment group.
        :param str appointment_group_location_address: Location address.
        :param bool appointment_group_publish: Indicates whether this appointment group should be published (i.e. made available for signup). Once published, an appointment group cannot be unpublished. Defaults to false.
        :param int appointment_group_participants_per_appointment: Maximum number of participants that may register for each time slot. Defaults to null (no limit).
        :param int appointment_group_min_appointments_per_participant: Minimum number of time slots a user must register for. If not set, users do not need to sign up for any time slots.
        :param int appointment_group_max_appointments_per_participant: Maximum number of time slots a user may register for.
        :param list[str] appointment_group_new_appointments_x: Nested array of start time/end time pairs indicating time slots for this appointment group. Refer to the example request.
        :param str appointment_group_participant_visibility: \"private\":: participants cannot see who has signed up for a particular             time slot \"protected\":: participants can see who has signed up. Defaults to \"private\".
        :param bool appointment_group_allow_observer_signup: Whether observer users can sign-up for an appointment.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_appointment_group_with_http_info(id, appointment_group_context_codes, **kwargs)  # noqa: E501
        else:
            (data) = self.update_appointment_group_with_http_info(id, appointment_group_context_codes, **kwargs)  # noqa: E501
            return data

    def update_appointment_group_with_http_info(self, id, appointment_group_context_codes, **kwargs):  # noqa: E501
        """Update an appointment group  # noqa: E501

        Update and return an appointment group. If new_appointments are specified, the response will return a new_appointments array (same format as appointments array, see \"List appointment groups\" action).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_appointment_group_with_http_info(id, appointment_group_context_codes, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param list[str] appointment_group_context_codes: Array of context codes (courses, e.g. course_1) this group should be linked to (1 or more). Users in the course(s) with appropriate permissions will be able to sign up for this appointment group. (required)
        :param list[str] appointment_group_sub_context_codes: Array of sub context codes (course sections or a single group category) this group should be linked to. Used to limit the appointment group to particular sections. If a group category is specified, students will sign up in groups and the participant_type will be \"Group\" instead of \"User\".
        :param str appointment_group_title: Short title for the appointment group.
        :param str appointment_group_description: Longer text description of the appointment group.
        :param str appointment_group_location_name: Location name of the appointment group.
        :param str appointment_group_location_address: Location address.
        :param bool appointment_group_publish: Indicates whether this appointment group should be published (i.e. made available for signup). Once published, an appointment group cannot be unpublished. Defaults to false.
        :param int appointment_group_participants_per_appointment: Maximum number of participants that may register for each time slot. Defaults to null (no limit).
        :param int appointment_group_min_appointments_per_participant: Minimum number of time slots a user must register for. If not set, users do not need to sign up for any time slots.
        :param int appointment_group_max_appointments_per_participant: Maximum number of time slots a user may register for.
        :param list[str] appointment_group_new_appointments_x: Nested array of start time/end time pairs indicating time slots for this appointment group. Refer to the example request.
        :param str appointment_group_participant_visibility: \"private\":: participants cannot see who has signed up for a particular             time slot \"protected\":: participants can see who has signed up. Defaults to \"private\".
        :param bool appointment_group_allow_observer_signup: Whether observer users can sign-up for an appointment.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'appointment_group_context_codes', 'appointment_group_sub_context_codes', 'appointment_group_title', 'appointment_group_description', 'appointment_group_location_name', 'appointment_group_location_address', 'appointment_group_publish', 'appointment_group_participants_per_appointment', 'appointment_group_min_appointments_per_participant', 'appointment_group_max_appointments_per_participant', 'appointment_group_new_appointments_x', 'appointment_group_participant_visibility', 'appointment_group_allow_observer_signup']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_appointment_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_appointment_group`")  # noqa: E501
        # verify the required parameter 'appointment_group_context_codes' is set
        if self.api_client.client_side_validation and ('appointment_group_context_codes' not in params or
                                                       params['appointment_group_context_codes'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `appointment_group_context_codes` when calling `update_appointment_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'appointment_group_context_codes' in params:
            form_params.append(('appointment_group[context_codes]', params['appointment_group_context_codes']))  # noqa: E501
            collection_formats['appointment_group[context_codes]'] = 'csv'  # noqa: E501
        if 'appointment_group_sub_context_codes' in params:
            form_params.append(('appointment_group[sub_context_codes]', params['appointment_group_sub_context_codes']))  # noqa: E501
            collection_formats['appointment_group[sub_context_codes]'] = 'csv'  # noqa: E501
        if 'appointment_group_title' in params:
            form_params.append(('appointment_group[title]', params['appointment_group_title']))  # noqa: E501
        if 'appointment_group_description' in params:
            form_params.append(('appointment_group[description]', params['appointment_group_description']))  # noqa: E501
        if 'appointment_group_location_name' in params:
            form_params.append(('appointment_group[location_name]', params['appointment_group_location_name']))  # noqa: E501
        if 'appointment_group_location_address' in params:
            form_params.append(('appointment_group[location_address]', params['appointment_group_location_address']))  # noqa: E501
        if 'appointment_group_publish' in params:
            form_params.append(('appointment_group[publish]', params['appointment_group_publish']))  # noqa: E501
        if 'appointment_group_participants_per_appointment' in params:
            form_params.append(('appointment_group[participants_per_appointment]', params['appointment_group_participants_per_appointment']))  # noqa: E501
        if 'appointment_group_min_appointments_per_participant' in params:
            form_params.append(('appointment_group[min_appointments_per_participant]', params['appointment_group_min_appointments_per_participant']))  # noqa: E501
        if 'appointment_group_max_appointments_per_participant' in params:
            form_params.append(('appointment_group[max_appointments_per_participant]', params['appointment_group_max_appointments_per_participant']))  # noqa: E501
        if 'appointment_group_new_appointments_x' in params:
            form_params.append(('appointment_group[new_appointments][X]', params['appointment_group_new_appointments_x']))  # noqa: E501
            collection_formats['appointment_group[new_appointments][X]'] = 'csv'  # noqa: E501
        if 'appointment_group_participant_visibility' in params:
            form_params.append(('appointment_group[participant_visibility]', params['appointment_group_participant_visibility']))  # noqa: E501
        if 'appointment_group_allow_observer_signup' in params:
            form_params.append(('appointment_group[allow_observer_signup]', params['appointment_group_allow_observer_signup']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/appointment_groups/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
