# coding: utf-8

"""

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ConversationsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_message(self, id, body, **kwargs):  # noqa: E501
        """Add a message  # noqa: E501

        Add a message to an existing conversation. Response is similar to the GET/show action, except that only includes the latest message (i.e. what we just sent)  An array of user ids. Defaults to all of the current conversation recipients. To explicitly send a message to no other recipients, this array should consist of the logged-in user id.  An array of message ids from this conversation to send to recipients of the new message. Recipients who already had a copy of included messages will not be affected.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_message(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str body: The message to be sent. (required)
        :param list[str] attachment_ids: An array of attachments ids. These must be files that have been previously uploaded to the sender's \"conversation attachments\" folder.
        :param str media_comment_id: Media comment id of an audio of video file to be associated with this message.
        :param str media_comment_type: Type of the associated media file.
        :param list[str] recipients: no description
        :param list[str] included_messages: no description
        :param bool user_note: Will add a faculty journal entry for each recipient as long as the user making the api call has permission, the recipient is a student and faculty journals are enabled in the account.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_message_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_message_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def add_message_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Add a message  # noqa: E501

        Add a message to an existing conversation. Response is similar to the GET/show action, except that only includes the latest message (i.e. what we just sent)  An array of user ids. Defaults to all of the current conversation recipients. To explicitly send a message to no other recipients, this array should consist of the logged-in user id.  An array of message ids from this conversation to send to recipients of the new message. Recipients who already had a copy of included messages will not be affected.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_message_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str body: The message to be sent. (required)
        :param list[str] attachment_ids: An array of attachments ids. These must be files that have been previously uploaded to the sender's \"conversation attachments\" folder.
        :param str media_comment_id: Media comment id of an audio of video file to be associated with this message.
        :param str media_comment_type: Type of the associated media file.
        :param list[str] recipients: no description
        :param list[str] included_messages: no description
        :param bool user_note: Will add a faculty journal entry for each recipient as long as the user making the api call has permission, the recipient is a student and faculty journals are enabled in the account.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'attachment_ids', 'media_comment_id', 'media_comment_type', 'recipients', 'included_messages', 'user_note']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_message" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `add_message`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `add_message`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'body' in params:
            form_params.append(('body', params['body']))  # noqa: E501
        if 'attachment_ids' in params:
            form_params.append(('attachment_ids', params['attachment_ids']))  # noqa: E501
            collection_formats['attachment_ids'] = 'csv'  # noqa: E501
        if 'media_comment_id' in params:
            form_params.append(('media_comment_id', params['media_comment_id']))  # noqa: E501
        if 'media_comment_type' in params:
            form_params.append(('media_comment_type', params['media_comment_type']))  # noqa: E501
        if 'recipients' in params:
            form_params.append(('recipients', params['recipients']))  # noqa: E501
            collection_formats['recipients'] = 'csv'  # noqa: E501
        if 'included_messages' in params:
            form_params.append(('included_messages', params['included_messages']))  # noqa: E501
            collection_formats['included_messages'] = 'csv'  # noqa: E501
        if 'user_note' in params:
            form_params.append(('user_note', params['user_note']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/conversations/{id}/add_message', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_recipients(self, id, recipients, **kwargs):  # noqa: E501
        """Add recipients  # noqa: E501

        Add recipients to an existing group conversation. Response is similar to the GET/show action, except that only includes the latest message (e.g. \"joe was added to the conversation by bob\")  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_recipients(id, recipients, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param list[str] recipients: An array of recipient ids. These may be user ids or course/group ids prefixed with \"course_\" or \"group_\" respectively, e.g. recipients[]=1&recipients[]=2&recipients[]=course_3 (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_recipients_with_http_info(id, recipients, **kwargs)  # noqa: E501
        else:
            (data) = self.add_recipients_with_http_info(id, recipients, **kwargs)  # noqa: E501
            return data

    def add_recipients_with_http_info(self, id, recipients, **kwargs):  # noqa: E501
        """Add recipients  # noqa: E501

        Add recipients to an existing group conversation. Response is similar to the GET/show action, except that only includes the latest message (e.g. \"joe was added to the conversation by bob\")  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_recipients_with_http_info(id, recipients, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param list[str] recipients: An array of recipient ids. These may be user ids or course/group ids prefixed with \"course_\" or \"group_\" respectively, e.g. recipients[]=1&recipients[]=2&recipients[]=course_3 (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'recipients']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_recipients" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `add_recipients`")  # noqa: E501
        # verify the required parameter 'recipients' is set
        if self.api_client.client_side_validation and ('recipients' not in params or
                                                       params['recipients'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `recipients` when calling `add_recipients`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'recipients' in params:
            form_params.append(('recipients', params['recipients']))  # noqa: E501
            collection_formats['recipients'] = 'csv'  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/conversations/{id}/add_recipients', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def batch_update_conversations(self, conversation_ids, event, **kwargs):  # noqa: E501
        """Batch update conversations  # noqa: E501

        Perform a change on a set of conversations. Operates asynchronously; use the {api:ProgressController#show progress endpoint} to query the status of an operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.batch_update_conversations(conversation_ids, event, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] conversation_ids: List of conversations to update. Limited to 500 conversations. (required)
        :param str event: The action to take on each conversation. (required)
        :return: Progress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.batch_update_conversations_with_http_info(conversation_ids, event, **kwargs)  # noqa: E501
        else:
            (data) = self.batch_update_conversations_with_http_info(conversation_ids, event, **kwargs)  # noqa: E501
            return data

    def batch_update_conversations_with_http_info(self, conversation_ids, event, **kwargs):  # noqa: E501
        """Batch update conversations  # noqa: E501

        Perform a change on a set of conversations. Operates asynchronously; use the {api:ProgressController#show progress endpoint} to query the status of an operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.batch_update_conversations_with_http_info(conversation_ids, event, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] conversation_ids: List of conversations to update. Limited to 500 conversations. (required)
        :param str event: The action to take on each conversation. (required)
        :return: Progress
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['conversation_ids', 'event']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batch_update_conversations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'conversation_ids' is set
        if self.api_client.client_side_validation and ('conversation_ids' not in params or
                                                       params['conversation_ids'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `conversation_ids` when calling `batch_update_conversations`")  # noqa: E501
        # verify the required parameter 'event' is set
        if self.api_client.client_side_validation and ('event' not in params or
                                                       params['event'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `event` when calling `batch_update_conversations`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'conversation_ids' in params:
            form_params.append(('conversation_ids', params['conversation_ids']))  # noqa: E501
            collection_formats['conversation_ids'] = 'csv'  # noqa: E501
        if 'event' in params:
            form_params.append(('event', params['event']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/conversations', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Progress',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_conversation(self, recipients, body, **kwargs):  # noqa: E501
        """Create a conversation  # noqa: E501

        Create a new conversation with one or more recipients. If there is already an existing private conversation with the given recipients, it will be reused.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_conversation(recipients, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] recipients: An array of recipient ids. These may be user ids or course/group ids prefixed with \"course_\" or \"group_\" respectively, e.g. recipients[]=1&recipients[]=2&recipients[]=course_3. If the course/group has over 100 enrollments, 'bulk_message' and 'group_conversation' must be set to true. (required)
        :param str body: The message to be sent (required)
        :param str subject: The subject of the conversation. This is ignored when reusing a conversation. Maximum length is 255 characters.
        :param bool force_new: Forces a new message to be created, even if there is an existing private conversation.
        :param bool group_conversation: Defaults to false.  When false, individual private conversations will be created with each recipient. If true, this will be a group conversation (i.e. all recipients may see all messages and replies). Must be set true if the number of recipients is over the set maximum (default is 100).
        :param list[str] attachment_ids: An array of attachments ids. These must be files that have been previously uploaded to the sender's \"conversation attachments\" folder.
        :param str media_comment_id: Media comment id of an audio or video file to be associated with this message.
        :param str media_comment_type: Type of the associated media file
        :param bool user_note: Will add a faculty journal entry for each recipient as long as the user making the api call has permission, the recipient is a student and faculty journals are enabled in the account.
        :param str mode: Determines whether the messages will be created/sent synchronously or asynchronously. Defaults to sync, and this option is ignored if this is a group conversation or there is just one recipient (i.e. it must be a bulk private message). When sent async, the response will be an empty array (batch status can be queried via the {api:ConversationsController#batches batches API})
        :param str scope: Used when generating \"visible\" in the API response. See the explanation under the {api:ConversationsController#index index API action}
        :param list[str] filter: Used when generating \"visible\" in the API response. See the explanation under the {api:ConversationsController#index index API action}
        :param str filter_mode: Used when generating \"visible\" in the API response. See the explanation under the {api:ConversationsController#index index API action}
        :param str context_code: The course or group that is the context for this conversation. Same format as courses or groups in the recipients argument.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_conversation_with_http_info(recipients, body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_conversation_with_http_info(recipients, body, **kwargs)  # noqa: E501
            return data

    def create_conversation_with_http_info(self, recipients, body, **kwargs):  # noqa: E501
        """Create a conversation  # noqa: E501

        Create a new conversation with one or more recipients. If there is already an existing private conversation with the given recipients, it will be reused.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_conversation_with_http_info(recipients, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] recipients: An array of recipient ids. These may be user ids or course/group ids prefixed with \"course_\" or \"group_\" respectively, e.g. recipients[]=1&recipients[]=2&recipients[]=course_3. If the course/group has over 100 enrollments, 'bulk_message' and 'group_conversation' must be set to true. (required)
        :param str body: The message to be sent (required)
        :param str subject: The subject of the conversation. This is ignored when reusing a conversation. Maximum length is 255 characters.
        :param bool force_new: Forces a new message to be created, even if there is an existing private conversation.
        :param bool group_conversation: Defaults to false.  When false, individual private conversations will be created with each recipient. If true, this will be a group conversation (i.e. all recipients may see all messages and replies). Must be set true if the number of recipients is over the set maximum (default is 100).
        :param list[str] attachment_ids: An array of attachments ids. These must be files that have been previously uploaded to the sender's \"conversation attachments\" folder.
        :param str media_comment_id: Media comment id of an audio or video file to be associated with this message.
        :param str media_comment_type: Type of the associated media file
        :param bool user_note: Will add a faculty journal entry for each recipient as long as the user making the api call has permission, the recipient is a student and faculty journals are enabled in the account.
        :param str mode: Determines whether the messages will be created/sent synchronously or asynchronously. Defaults to sync, and this option is ignored if this is a group conversation or there is just one recipient (i.e. it must be a bulk private message). When sent async, the response will be an empty array (batch status can be queried via the {api:ConversationsController#batches batches API})
        :param str scope: Used when generating \"visible\" in the API response. See the explanation under the {api:ConversationsController#index index API action}
        :param list[str] filter: Used when generating \"visible\" in the API response. See the explanation under the {api:ConversationsController#index index API action}
        :param str filter_mode: Used when generating \"visible\" in the API response. See the explanation under the {api:ConversationsController#index index API action}
        :param str context_code: The course or group that is the context for this conversation. Same format as courses or groups in the recipients argument.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['recipients', 'body', 'subject', 'force_new', 'group_conversation', 'attachment_ids', 'media_comment_id', 'media_comment_type', 'user_note', 'mode', 'scope', 'filter', 'filter_mode', 'context_code']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_conversation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'recipients' is set
        if self.api_client.client_side_validation and ('recipients' not in params or
                                                       params['recipients'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `recipients` when calling `create_conversation`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `create_conversation`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'recipients' in params:
            form_params.append(('recipients', params['recipients']))  # noqa: E501
            collection_formats['recipients'] = 'csv'  # noqa: E501
        if 'subject' in params:
            form_params.append(('subject', params['subject']))  # noqa: E501
        if 'body' in params:
            form_params.append(('body', params['body']))  # noqa: E501
        if 'force_new' in params:
            form_params.append(('force_new', params['force_new']))  # noqa: E501
        if 'group_conversation' in params:
            form_params.append(('group_conversation', params['group_conversation']))  # noqa: E501
        if 'attachment_ids' in params:
            form_params.append(('attachment_ids', params['attachment_ids']))  # noqa: E501
            collection_formats['attachment_ids'] = 'csv'  # noqa: E501
        if 'media_comment_id' in params:
            form_params.append(('media_comment_id', params['media_comment_id']))  # noqa: E501
        if 'media_comment_type' in params:
            form_params.append(('media_comment_type', params['media_comment_type']))  # noqa: E501
        if 'user_note' in params:
            form_params.append(('user_note', params['user_note']))  # noqa: E501
        if 'mode' in params:
            form_params.append(('mode', params['mode']))  # noqa: E501
        if 'scope' in params:
            form_params.append(('scope', params['scope']))  # noqa: E501
        if 'filter' in params:
            form_params.append(('filter', params['filter']))  # noqa: E501
            collection_formats['filter'] = 'csv'  # noqa: E501
        if 'filter_mode' in params:
            form_params.append(('filter_mode', params['filter_mode']))  # noqa: E501
        if 'context_code' in params:
            form_params.append(('context_code', params['context_code']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/conversations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_conversation(self, id, **kwargs):  # noqa: E501
        """Delete a conversation  # noqa: E501

        Delete this conversation and its messages. Note that this only deletes this user's view of the conversation.  Response includes same fields as UPDATE action  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_conversation(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_conversation_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_conversation_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_conversation_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a conversation  # noqa: E501

        Delete this conversation and its messages. Note that this only deletes this user's view of the conversation.  Response includes same fields as UPDATE action  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_conversation_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_conversation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_conversation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/conversations/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_message(self, id, remove, **kwargs):  # noqa: E501
        """Delete a message  # noqa: E501

        Delete messages from this conversation. Note that this only affects this user's view of the conversation. If all messages are deleted, the conversation will be as well (equivalent to DELETE)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_message(id, remove, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param list[str] remove: Array of message ids to be deleted (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_message_with_http_info(id, remove, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_message_with_http_info(id, remove, **kwargs)  # noqa: E501
            return data

    def delete_message_with_http_info(self, id, remove, **kwargs):  # noqa: E501
        """Delete a message  # noqa: E501

        Delete messages from this conversation. Note that this only affects this user's view of the conversation. If all messages are deleted, the conversation will be as well (equivalent to DELETE)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_message_with_http_info(id, remove, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param list[str] remove: Array of message ids to be deleted (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'remove']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_message" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_message`")  # noqa: E501
        # verify the required parameter 'remove' is set
        if self.api_client.client_side_validation and ('remove' not in params or
                                                       params['remove'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `remove` when calling `delete_message`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'remove' in params:
            form_params.append(('remove', params['remove']))  # noqa: E501
            collection_formats['remove'] = 'csv'  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/conversations/{id}/remove_messages', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_conversation(self, id, **kwargs):  # noqa: E501
        """Edit a conversation  # noqa: E501

        Updates attributes for a single conversation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_conversation(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str conversation_workflow_state: Change the state of this conversation
        :param bool conversation_subscribed: Toggle the current user's subscription to the conversation (only valid for group conversations). If unsubscribed, the user will still have access to the latest messages, but the conversation won't be automatically flagged as unread, nor will it jump to the top of the inbox.
        :param bool conversation_starred: Toggle the starred state of the current user's view of the conversation.
        :param str scope: Used when generating \"visible\" in the API response. See the explanation under the {api:ConversationsController#index index API action}
        :param list[str] filter: Used when generating \"visible\" in the API response. See the explanation under the {api:ConversationsController#index index API action}
        :param str filter_mode: Used when generating \"visible\" in the API response. See the explanation under the {api:ConversationsController#index index API action}
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_conversation_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_conversation_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def edit_conversation_with_http_info(self, id, **kwargs):  # noqa: E501
        """Edit a conversation  # noqa: E501

        Updates attributes for a single conversation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_conversation_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str conversation_workflow_state: Change the state of this conversation
        :param bool conversation_subscribed: Toggle the current user's subscription to the conversation (only valid for group conversations). If unsubscribed, the user will still have access to the latest messages, but the conversation won't be automatically flagged as unread, nor will it jump to the top of the inbox.
        :param bool conversation_starred: Toggle the starred state of the current user's view of the conversation.
        :param str scope: Used when generating \"visible\" in the API response. See the explanation under the {api:ConversationsController#index index API action}
        :param list[str] filter: Used when generating \"visible\" in the API response. See the explanation under the {api:ConversationsController#index index API action}
        :param str filter_mode: Used when generating \"visible\" in the API response. See the explanation under the {api:ConversationsController#index index API action}
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'conversation_workflow_state', 'conversation_subscribed', 'conversation_starred', 'scope', 'filter', 'filter_mode']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_conversation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `edit_conversation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'conversation_workflow_state' in params:
            form_params.append(('conversation[workflow_state]', params['conversation_workflow_state']))  # noqa: E501
        if 'conversation_subscribed' in params:
            form_params.append(('conversation[subscribed]', params['conversation_subscribed']))  # noqa: E501
        if 'conversation_starred' in params:
            form_params.append(('conversation[starred]', params['conversation_starred']))  # noqa: E501
        if 'scope' in params:
            form_params.append(('scope', params['scope']))  # noqa: E501
        if 'filter' in params:
            form_params.append(('filter', params['filter']))  # noqa: E501
            collection_formats['filter'] = 'csv'  # noqa: E501
        if 'filter_mode' in params:
            form_params.append(('filter_mode', params['filter_mode']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/conversations/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_running_batches(self, **kwargs):  # noqa: E501
        """Get running batches  # noqa: E501

        Returns any currently running conversation batches for the current user. Conversation batches are created when a bulk private message is sent asynchronously (see the mode argument to the {api:ConversationsController#create create API action}).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_running_batches(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_running_batches_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_running_batches_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_running_batches_with_http_info(self, **kwargs):  # noqa: E501
        """Get running batches  # noqa: E501

        Returns any currently running conversation batches for the current user. Conversation batches are created when a bulk private message is sent asynchronously (see the mode argument to the {api:ConversationsController#create create API action}).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_running_batches_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_running_batches" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/conversations/batches', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_single_conversation(self, id, **kwargs):  # noqa: E501
        """Get a single conversation  # noqa: E501

        Returns information for a single conversation for the current user. Response includes all fields that are present in the list/index action as well as messages and extended participant information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_single_conversation(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param bool interleave_submissions: (Obsolete) Submissions are no longer linked to conversations. This parameter is ignored.
        :param str scope: Used when generating \"visible\" in the API response. See the explanation under the {api:ConversationsController#index index API action}
        :param list[str] filter: Used when generating \"visible\" in the API response. See the explanation under the {api:ConversationsController#index index API action}
        :param str filter_mode: Used when generating \"visible\" in the API response. See the explanation under the {api:ConversationsController#index index API action}
        :param bool auto_mark_as_read: Default true. If true, unread conversations will be automatically marked as read. This will default to false in a future API release, so clients should explicitly send true if that is the desired behavior.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_single_conversation_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_single_conversation_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_single_conversation_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a single conversation  # noqa: E501

        Returns information for a single conversation for the current user. Response includes all fields that are present in the list/index action as well as messages and extended participant information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_single_conversation_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param bool interleave_submissions: (Obsolete) Submissions are no longer linked to conversations. This parameter is ignored.
        :param str scope: Used when generating \"visible\" in the API response. See the explanation under the {api:ConversationsController#index index API action}
        :param list[str] filter: Used when generating \"visible\" in the API response. See the explanation under the {api:ConversationsController#index index API action}
        :param str filter_mode: Used when generating \"visible\" in the API response. See the explanation under the {api:ConversationsController#index index API action}
        :param bool auto_mark_as_read: Default true. If true, unread conversations will be automatically marked as read. This will default to false in a future API release, so clients should explicitly send true if that is the desired behavior.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'interleave_submissions', 'scope', 'filter', 'filter_mode', 'auto_mark_as_read']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_single_conversation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_single_conversation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'interleave_submissions' in params:
            query_params.append(('interleave_submissions', params['interleave_submissions']))  # noqa: E501
        if 'scope' in params:
            query_params.append(('scope', params['scope']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
            collection_formats['filter'] = 'csv'  # noqa: E501
        if 'filter_mode' in params:
            query_params.append(('filter_mode', params['filter_mode']))  # noqa: E501
        if 'auto_mark_as_read' in params:
            query_params.append(('auto_mark_as_read', params['auto_mark_as_read']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/conversations/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_conversations(self, **kwargs):  # noqa: E501
        """List conversations  # noqa: E501

        Returns the paginated list of conversations for the current user, most recent ones first.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_conversations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str scope: When set, only return conversations of the specified type. For example, set to \"unread\" to return only conversations that haven't been read. The default behavior is to return all non-archived conversations (i.e. read and unread).
        :param list[str] filter: When set, only return conversations for the specified courses, groups or users. The id should be prefixed with its type, e.g. \"user_123\" or \"course_456\". Can be an array (by setting \"filter[]\") or single value (by setting \"filter\")
        :param str filter_mode: When filter[] contains multiple filters, combine them with this mode, filtering conversations that at have at least all of the contexts (\"and\") or at least one of the contexts (\"or\")
        :param bool interleave_submissions: (Obsolete) Submissions are no longer linked to conversations. This parameter is ignored.
        :param bool include_all_conversation_ids: Default is false. If true, the top-level element of the response will be an object rather than an array, and will have the keys \"conversations\" which will contain the paged conversation data, and \"conversation_ids\" which will contain the ids of all conversations under this scope/filter in the same order.
        :param list[str] include: \"participant_avatars\":: Optionally include an \"avatar_url\" key for each user participanting in the conversation
        :return: list[Conversation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_conversations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_conversations_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_conversations_with_http_info(self, **kwargs):  # noqa: E501
        """List conversations  # noqa: E501

        Returns the paginated list of conversations for the current user, most recent ones first.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_conversations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str scope: When set, only return conversations of the specified type. For example, set to \"unread\" to return only conversations that haven't been read. The default behavior is to return all non-archived conversations (i.e. read and unread).
        :param list[str] filter: When set, only return conversations for the specified courses, groups or users. The id should be prefixed with its type, e.g. \"user_123\" or \"course_456\". Can be an array (by setting \"filter[]\") or single value (by setting \"filter\")
        :param str filter_mode: When filter[] contains multiple filters, combine them with this mode, filtering conversations that at have at least all of the contexts (\"and\") or at least one of the contexts (\"or\")
        :param bool interleave_submissions: (Obsolete) Submissions are no longer linked to conversations. This parameter is ignored.
        :param bool include_all_conversation_ids: Default is false. If true, the top-level element of the response will be an object rather than an array, and will have the keys \"conversations\" which will contain the paged conversation data, and \"conversation_ids\" which will contain the ids of all conversations under this scope/filter in the same order.
        :param list[str] include: \"participant_avatars\":: Optionally include an \"avatar_url\" key for each user participanting in the conversation
        :return: list[Conversation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['scope', 'filter', 'filter_mode', 'interleave_submissions', 'include_all_conversation_ids', 'include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_conversations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'scope' in params:
            query_params.append(('scope', params['scope']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
            collection_formats['filter'] = 'csv'  # noqa: E501
        if 'filter_mode' in params:
            query_params.append(('filter_mode', params['filter_mode']))  # noqa: E501
        if 'interleave_submissions' in params:
            query_params.append(('interleave_submissions', params['interleave_submissions']))  # noqa: E501
        if 'include_all_conversation_ids' in params:
            query_params.append(('include_all_conversation_ids', params['include_all_conversation_ids']))  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/conversations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Conversation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mark_all_as_read(self, **kwargs):  # noqa: E501
        """Mark all as read  # noqa: E501

        Mark all conversations as read.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_all_as_read(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mark_all_as_read_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.mark_all_as_read_with_http_info(**kwargs)  # noqa: E501
            return data

    def mark_all_as_read_with_http_info(self, **kwargs):  # noqa: E501
        """Mark all as read  # noqa: E501

        Mark all conversations as read.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_all_as_read_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_all_as_read" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/conversations/mark_all_as_read', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unread_count(self, **kwargs):  # noqa: E501
        """Unread count  # noqa: E501

        Get the number of unread conversations for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unread_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unread_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.unread_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def unread_count_with_http_info(self, **kwargs):  # noqa: E501
        """Unread count  # noqa: E501

        Get the number of unread conversations for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unread_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unread_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/conversations/unread_count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
