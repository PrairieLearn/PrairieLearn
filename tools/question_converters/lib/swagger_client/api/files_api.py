# coding: utf-8

"""

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class FilesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def copy_file(self, dest_folder_id, source_file_id, **kwargs):  # noqa: E501
        """Copy a file  # noqa: E501

        Copy a file from elsewhere in Canvas into a folder.  Copying a file across contexts (between courses and users) is permitted, but the source and destination must belong to the same institution.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_file(dest_folder_id, source_file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dest_folder_id: ID (required)
        :param str source_file_id: The id of the source file (required)
        :param str on_duplicate: What to do if a file with the same name already exists at the destination. If such a file exists and this parameter is not given, the call will fail.  \"overwrite\":: Replace an existing file with the same name \"rename\":: Add a qualifier to make the new filename unique
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.copy_file_with_http_info(dest_folder_id, source_file_id, **kwargs)  # noqa: E501
        else:
            (data) = self.copy_file_with_http_info(dest_folder_id, source_file_id, **kwargs)  # noqa: E501
            return data

    def copy_file_with_http_info(self, dest_folder_id, source_file_id, **kwargs):  # noqa: E501
        """Copy a file  # noqa: E501

        Copy a file from elsewhere in Canvas into a folder.  Copying a file across contexts (between courses and users) is permitted, but the source and destination must belong to the same institution.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_file_with_http_info(dest_folder_id, source_file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dest_folder_id: ID (required)
        :param str source_file_id: The id of the source file (required)
        :param str on_duplicate: What to do if a file with the same name already exists at the destination. If such a file exists and this parameter is not given, the call will fail.  \"overwrite\":: Replace an existing file with the same name \"rename\":: Add a qualifier to make the new filename unique
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dest_folder_id', 'source_file_id', 'on_duplicate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dest_folder_id' is set
        if self.api_client.client_side_validation and ('dest_folder_id' not in params or
                                                       params['dest_folder_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `dest_folder_id` when calling `copy_file`")  # noqa: E501
        # verify the required parameter 'source_file_id' is set
        if self.api_client.client_side_validation and ('source_file_id' not in params or
                                                       params['source_file_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `source_file_id` when calling `copy_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dest_folder_id' in params:
            path_params['dest_folder_id'] = params['dest_folder_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'source_file_id' in params:
            form_params.append(('source_file_id', params['source_file_id']))  # noqa: E501
        if 'on_duplicate' in params:
            form_params.append(('on_duplicate', params['on_duplicate']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders/{dest_folder_id}/copy_file', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def copy_folder(self, dest_folder_id, source_folder_id, **kwargs):  # noqa: E501
        """Copy a folder  # noqa: E501

        Copy a folder (and its contents) from elsewhere in Canvas into a folder.  Copying a folder across contexts (between courses and users) is permitted, but the source and destination must belong to the same institution. If the source and destination folders are in the same context, the source folder may not contain the destination folder. A folder will be renamed at its destination if another folder with the same name already exists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_folder(dest_folder_id, source_folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dest_folder_id: ID (required)
        :param str source_folder_id: The id of the source folder (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.copy_folder_with_http_info(dest_folder_id, source_folder_id, **kwargs)  # noqa: E501
        else:
            (data) = self.copy_folder_with_http_info(dest_folder_id, source_folder_id, **kwargs)  # noqa: E501
            return data

    def copy_folder_with_http_info(self, dest_folder_id, source_folder_id, **kwargs):  # noqa: E501
        """Copy a folder  # noqa: E501

        Copy a folder (and its contents) from elsewhere in Canvas into a folder.  Copying a folder across contexts (between courses and users) is permitted, but the source and destination must belong to the same institution. If the source and destination folders are in the same context, the source folder may not contain the destination folder. A folder will be renamed at its destination if another folder with the same name already exists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_folder_with_http_info(dest_folder_id, source_folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dest_folder_id: ID (required)
        :param str source_folder_id: The id of the source folder (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dest_folder_id', 'source_folder_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dest_folder_id' is set
        if self.api_client.client_side_validation and ('dest_folder_id' not in params or
                                                       params['dest_folder_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `dest_folder_id` when calling `copy_folder`")  # noqa: E501
        # verify the required parameter 'source_folder_id' is set
        if self.api_client.client_side_validation and ('source_folder_id' not in params or
                                                       params['source_folder_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `source_folder_id` when calling `copy_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dest_folder_id' in params:
            path_params['dest_folder_id'] = params['dest_folder_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'source_folder_id' in params:
            form_params.append(('source_folder_id', params['source_folder_id']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders/{dest_folder_id}/copy_folder', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Folder',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_folder_courses(self, course_id, name, **kwargs):  # noqa: E501
        """Create folder  # noqa: E501

        Creates a folder in the specified context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_folder_courses(course_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str name: The name of the folder (required)
        :param str parent_folder_id: The id of the folder to store the new folder in. An error will be returned if this does not correspond to an existing folder. If this and parent_folder_path are sent an error will be returned. If neither is given, a default folder will be used.
        :param str parent_folder_path: The path of the folder to store the new folder in. The path separator is the forward slash `/`, never a back slash. The parent folder will be created if it does not already exist. This parameter only applies to new folders in a context that has folders, such as a user, a course, or a group. If this and parent_folder_id are sent an error will be returned. If neither is given, a default folder will be used.
        :param Object lock_at: The datetime to lock the folder at
        :param Object unlock_at: The datetime to unlock the folder at
        :param bool locked: Flag the folder as locked
        :param bool hidden: Flag the folder as hidden
        :param int position: Set an explicit sort position for the folder
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_folder_courses_with_http_info(course_id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.create_folder_courses_with_http_info(course_id, name, **kwargs)  # noqa: E501
            return data

    def create_folder_courses_with_http_info(self, course_id, name, **kwargs):  # noqa: E501
        """Create folder  # noqa: E501

        Creates a folder in the specified context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_folder_courses_with_http_info(course_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str name: The name of the folder (required)
        :param str parent_folder_id: The id of the folder to store the new folder in. An error will be returned if this does not correspond to an existing folder. If this and parent_folder_path are sent an error will be returned. If neither is given, a default folder will be used.
        :param str parent_folder_path: The path of the folder to store the new folder in. The path separator is the forward slash `/`, never a back slash. The parent folder will be created if it does not already exist. This parameter only applies to new folders in a context that has folders, such as a user, a course, or a group. If this and parent_folder_id are sent an error will be returned. If neither is given, a default folder will be used.
        :param Object lock_at: The datetime to lock the folder at
        :param Object unlock_at: The datetime to unlock the folder at
        :param bool locked: Flag the folder as locked
        :param bool hidden: Flag the folder as hidden
        :param int position: Set an explicit sort position for the folder
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'name', 'parent_folder_id', 'parent_folder_path', 'lock_at', 'unlock_at', 'locked', 'hidden', 'position']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_folder_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `create_folder_courses`")  # noqa: E501
        # verify the required parameter 'name' is set
        if self.api_client.client_side_validation and ('name' not in params or
                                                       params['name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `name` when calling `create_folder_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'parent_folder_id' in params:
            form_params.append(('parent_folder_id', params['parent_folder_id']))  # noqa: E501
        if 'parent_folder_path' in params:
            form_params.append(('parent_folder_path', params['parent_folder_path']))  # noqa: E501
        if 'lock_at' in params:
            form_params.append(('lock_at', params['lock_at']))  # noqa: E501
        if 'unlock_at' in params:
            form_params.append(('unlock_at', params['unlock_at']))  # noqa: E501
        if 'locked' in params:
            form_params.append(('locked', params['locked']))  # noqa: E501
        if 'hidden' in params:
            form_params.append(('hidden', params['hidden']))  # noqa: E501
        if 'position' in params:
            form_params.append(('position', params['position']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/folders', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Folder',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_folder_folders(self, folder_id, name, **kwargs):  # noqa: E501
        """Create folder  # noqa: E501

        Creates a folder in the specified context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_folder_folders(folder_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: ID (required)
        :param str name: The name of the folder (required)
        :param str parent_folder_id: The id of the folder to store the new folder in. An error will be returned if this does not correspond to an existing folder. If this and parent_folder_path are sent an error will be returned. If neither is given, a default folder will be used.
        :param str parent_folder_path: The path of the folder to store the new folder in. The path separator is the forward slash `/`, never a back slash. The parent folder will be created if it does not already exist. This parameter only applies to new folders in a context that has folders, such as a user, a course, or a group. If this and parent_folder_id are sent an error will be returned. If neither is given, a default folder will be used.
        :param Object lock_at: The datetime to lock the folder at
        :param Object unlock_at: The datetime to unlock the folder at
        :param bool locked: Flag the folder as locked
        :param bool hidden: Flag the folder as hidden
        :param int position: Set an explicit sort position for the folder
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_folder_folders_with_http_info(folder_id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.create_folder_folders_with_http_info(folder_id, name, **kwargs)  # noqa: E501
            return data

    def create_folder_folders_with_http_info(self, folder_id, name, **kwargs):  # noqa: E501
        """Create folder  # noqa: E501

        Creates a folder in the specified context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_folder_folders_with_http_info(folder_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: ID (required)
        :param str name: The name of the folder (required)
        :param str parent_folder_id: The id of the folder to store the new folder in. An error will be returned if this does not correspond to an existing folder. If this and parent_folder_path are sent an error will be returned. If neither is given, a default folder will be used.
        :param str parent_folder_path: The path of the folder to store the new folder in. The path separator is the forward slash `/`, never a back slash. The parent folder will be created if it does not already exist. This parameter only applies to new folders in a context that has folders, such as a user, a course, or a group. If this and parent_folder_id are sent an error will be returned. If neither is given, a default folder will be used.
        :param Object lock_at: The datetime to lock the folder at
        :param Object unlock_at: The datetime to unlock the folder at
        :param bool locked: Flag the folder as locked
        :param bool hidden: Flag the folder as hidden
        :param int position: Set an explicit sort position for the folder
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id', 'name', 'parent_folder_id', 'parent_folder_path', 'lock_at', 'unlock_at', 'locked', 'hidden', 'position']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_folder_folders" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if self.api_client.client_side_validation and ('folder_id' not in params or
                                                       params['folder_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `folder_id` when calling `create_folder_folders`")  # noqa: E501
        # verify the required parameter 'name' is set
        if self.api_client.client_side_validation and ('name' not in params or
                                                       params['name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `name` when calling `create_folder_folders`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folder_id'] = params['folder_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'parent_folder_id' in params:
            form_params.append(('parent_folder_id', params['parent_folder_id']))  # noqa: E501
        if 'parent_folder_path' in params:
            form_params.append(('parent_folder_path', params['parent_folder_path']))  # noqa: E501
        if 'lock_at' in params:
            form_params.append(('lock_at', params['lock_at']))  # noqa: E501
        if 'unlock_at' in params:
            form_params.append(('unlock_at', params['unlock_at']))  # noqa: E501
        if 'locked' in params:
            form_params.append(('locked', params['locked']))  # noqa: E501
        if 'hidden' in params:
            form_params.append(('hidden', params['hidden']))  # noqa: E501
        if 'position' in params:
            form_params.append(('position', params['position']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders/{folder_id}/folders', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Folder',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_folder_groups(self, group_id, name, **kwargs):  # noqa: E501
        """Create folder  # noqa: E501

        Creates a folder in the specified context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_folder_groups(group_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str name: The name of the folder (required)
        :param str parent_folder_id: The id of the folder to store the new folder in. An error will be returned if this does not correspond to an existing folder. If this and parent_folder_path are sent an error will be returned. If neither is given, a default folder will be used.
        :param str parent_folder_path: The path of the folder to store the new folder in. The path separator is the forward slash `/`, never a back slash. The parent folder will be created if it does not already exist. This parameter only applies to new folders in a context that has folders, such as a user, a course, or a group. If this and parent_folder_id are sent an error will be returned. If neither is given, a default folder will be used.
        :param Object lock_at: The datetime to lock the folder at
        :param Object unlock_at: The datetime to unlock the folder at
        :param bool locked: Flag the folder as locked
        :param bool hidden: Flag the folder as hidden
        :param int position: Set an explicit sort position for the folder
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_folder_groups_with_http_info(group_id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.create_folder_groups_with_http_info(group_id, name, **kwargs)  # noqa: E501
            return data

    def create_folder_groups_with_http_info(self, group_id, name, **kwargs):  # noqa: E501
        """Create folder  # noqa: E501

        Creates a folder in the specified context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_folder_groups_with_http_info(group_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str name: The name of the folder (required)
        :param str parent_folder_id: The id of the folder to store the new folder in. An error will be returned if this does not correspond to an existing folder. If this and parent_folder_path are sent an error will be returned. If neither is given, a default folder will be used.
        :param str parent_folder_path: The path of the folder to store the new folder in. The path separator is the forward slash `/`, never a back slash. The parent folder will be created if it does not already exist. This parameter only applies to new folders in a context that has folders, such as a user, a course, or a group. If this and parent_folder_id are sent an error will be returned. If neither is given, a default folder will be used.
        :param Object lock_at: The datetime to lock the folder at
        :param Object unlock_at: The datetime to unlock the folder at
        :param bool locked: Flag the folder as locked
        :param bool hidden: Flag the folder as hidden
        :param int position: Set an explicit sort position for the folder
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'name', 'parent_folder_id', 'parent_folder_path', 'lock_at', 'unlock_at', 'locked', 'hidden', 'position']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_folder_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `create_folder_groups`")  # noqa: E501
        # verify the required parameter 'name' is set
        if self.api_client.client_side_validation and ('name' not in params or
                                                       params['name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `name` when calling `create_folder_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'parent_folder_id' in params:
            form_params.append(('parent_folder_id', params['parent_folder_id']))  # noqa: E501
        if 'parent_folder_path' in params:
            form_params.append(('parent_folder_path', params['parent_folder_path']))  # noqa: E501
        if 'lock_at' in params:
            form_params.append(('lock_at', params['lock_at']))  # noqa: E501
        if 'unlock_at' in params:
            form_params.append(('unlock_at', params['unlock_at']))  # noqa: E501
        if 'locked' in params:
            form_params.append(('locked', params['locked']))  # noqa: E501
        if 'hidden' in params:
            form_params.append(('hidden', params['hidden']))  # noqa: E501
        if 'position' in params:
            form_params.append(('position', params['position']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/folders', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Folder',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_folder_users(self, user_id, name, **kwargs):  # noqa: E501
        """Create folder  # noqa: E501

        Creates a folder in the specified context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_folder_users(user_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str name: The name of the folder (required)
        :param str parent_folder_id: The id of the folder to store the new folder in. An error will be returned if this does not correspond to an existing folder. If this and parent_folder_path are sent an error will be returned. If neither is given, a default folder will be used.
        :param str parent_folder_path: The path of the folder to store the new folder in. The path separator is the forward slash `/`, never a back slash. The parent folder will be created if it does not already exist. This parameter only applies to new folders in a context that has folders, such as a user, a course, or a group. If this and parent_folder_id are sent an error will be returned. If neither is given, a default folder will be used.
        :param Object lock_at: The datetime to lock the folder at
        :param Object unlock_at: The datetime to unlock the folder at
        :param bool locked: Flag the folder as locked
        :param bool hidden: Flag the folder as hidden
        :param int position: Set an explicit sort position for the folder
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_folder_users_with_http_info(user_id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.create_folder_users_with_http_info(user_id, name, **kwargs)  # noqa: E501
            return data

    def create_folder_users_with_http_info(self, user_id, name, **kwargs):  # noqa: E501
        """Create folder  # noqa: E501

        Creates a folder in the specified context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_folder_users_with_http_info(user_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str name: The name of the folder (required)
        :param str parent_folder_id: The id of the folder to store the new folder in. An error will be returned if this does not correspond to an existing folder. If this and parent_folder_path are sent an error will be returned. If neither is given, a default folder will be used.
        :param str parent_folder_path: The path of the folder to store the new folder in. The path separator is the forward slash `/`, never a back slash. The parent folder will be created if it does not already exist. This parameter only applies to new folders in a context that has folders, such as a user, a course, or a group. If this and parent_folder_id are sent an error will be returned. If neither is given, a default folder will be used.
        :param Object lock_at: The datetime to lock the folder at
        :param Object unlock_at: The datetime to unlock the folder at
        :param bool locked: Flag the folder as locked
        :param bool hidden: Flag the folder as hidden
        :param int position: Set an explicit sort position for the folder
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'name', 'parent_folder_id', 'parent_folder_path', 'lock_at', 'unlock_at', 'locked', 'hidden', 'position']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_folder_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `create_folder_users`")  # noqa: E501
        # verify the required parameter 'name' is set
        if self.api_client.client_side_validation and ('name' not in params or
                                                       params['name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `name` when calling `create_folder_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'parent_folder_id' in params:
            form_params.append(('parent_folder_id', params['parent_folder_id']))  # noqa: E501
        if 'parent_folder_path' in params:
            form_params.append(('parent_folder_path', params['parent_folder_path']))  # noqa: E501
        if 'lock_at' in params:
            form_params.append(('lock_at', params['lock_at']))  # noqa: E501
        if 'unlock_at' in params:
            form_params.append(('unlock_at', params['unlock_at']))  # noqa: E501
        if 'locked' in params:
            form_params.append(('locked', params['locked']))  # noqa: E501
        if 'hidden' in params:
            form_params.append(('hidden', params['hidden']))  # noqa: E501
        if 'position' in params:
            form_params.append(('position', params['position']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/folders', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Folder',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_file(self, id, **kwargs):  # noqa: E501
        """Delete file  # noqa: E501

        Remove the specified file. Unlike most other DELETE endpoints, using this endpoint will result in comprehensive, irretrievable destruction of the file. It should be used with the `replace` parameter set to true in cases where the file preview also needs to be destroyed (such as to remove files that violate privacy laws).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_file(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param bool replace: This action is irreversible. If replace is set to true the file contents will be replaced with a generic \"file has been removed\" file. This also destroys any previews that have been generated for the file. Must have manage files and become other users permissions
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_file_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_file_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_file_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete file  # noqa: E501

        Remove the specified file. Unlike most other DELETE endpoints, using this endpoint will result in comprehensive, irretrievable destruction of the file. It should be used with the `replace` parameter set to true in cases where the file preview also needs to be destroyed (such as to remove files that violate privacy laws).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_file_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param bool replace: This action is irreversible. If replace is set to true the file contents will be replaced with a generic \"file has been removed\" file. This also destroys any previews that have been generated for the file. Must have manage files and become other users permissions
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'replace']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'replace' in params:
            query_params.append(('replace', params['replace']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/files/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_folder(self, id, **kwargs):  # noqa: E501
        """Delete folder  # noqa: E501

        Remove the specified folder. You can only delete empty folders unless you set the 'force' flag  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_folder(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param bool force: Set to 'true' to allow deleting a non-empty folder
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_folder_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_folder_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_folder_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete folder  # noqa: E501

        Remove the specified folder. You can only delete empty folders unless you set the 'force' flag  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_folder_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param bool force: Set to 'true' to allow deleting a non-empty folder
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'force']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_file_courses(self, course_id, id, **kwargs):  # noqa: E501
        """Get file  # noqa: E501

        Returns the standard attachment json object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_courses(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :param list[str] include: Array of additional information to include.  \"user\":: the user who uploaded the file or last edited its content \"usage_rights\":: copyright and license information for the file (see UsageRights)
        :param str replacement_chain_context_type: When a user replaces a file during upload, Canvas keeps track of the \"replacement chain.\"  Include this parameter if you wish Canvas to follow the replacement chain if the requested file was deleted and replaced by another.  Must be set to 'course' or 'account'. The \"replacement_chain_context_id\" parameter must also be included.
        :param int replacement_chain_context_id: When a user replaces a file during upload, Canvas keeps track of the \"replacement chain.\"  Include this parameter if you wish Canvas to follow the replacement chain if the requested file was deleted and replaced by another.  Indicates the context ID Canvas should use when following the \"replacement chain.\" The \"replacement_chain_context_type\" parameter must also be included.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_file_courses_with_http_info(course_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_file_courses_with_http_info(course_id, id, **kwargs)  # noqa: E501
            return data

    def get_file_courses_with_http_info(self, course_id, id, **kwargs):  # noqa: E501
        """Get file  # noqa: E501

        Returns the standard attachment json object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_courses_with_http_info(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :param list[str] include: Array of additional information to include.  \"user\":: the user who uploaded the file or last edited its content \"usage_rights\":: copyright and license information for the file (see UsageRights)
        :param str replacement_chain_context_type: When a user replaces a file during upload, Canvas keeps track of the \"replacement chain.\"  Include this parameter if you wish Canvas to follow the replacement chain if the requested file was deleted and replaced by another.  Must be set to 'course' or 'account'. The \"replacement_chain_context_id\" parameter must also be included.
        :param int replacement_chain_context_id: When a user replaces a file during upload, Canvas keeps track of the \"replacement chain.\"  Include this parameter if you wish Canvas to follow the replacement chain if the requested file was deleted and replaced by another.  Indicates the context ID Canvas should use when following the \"replacement chain.\" The \"replacement_chain_context_type\" parameter must also be included.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'id', 'include', 'replacement_chain_context_type', 'replacement_chain_context_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `get_file_courses`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_file_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'replacement_chain_context_type' in params:
            query_params.append(('replacement_chain_context_type', params['replacement_chain_context_type']))  # noqa: E501
        if 'replacement_chain_context_id' in params:
            query_params.append(('replacement_chain_context_id', params['replacement_chain_context_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/files/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_file_files(self, id, **kwargs):  # noqa: E501
        """Get file  # noqa: E501

        Returns the standard attachment json object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_files(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param list[str] include: Array of additional information to include.  \"user\":: the user who uploaded the file or last edited its content \"usage_rights\":: copyright and license information for the file (see UsageRights)
        :param str replacement_chain_context_type: When a user replaces a file during upload, Canvas keeps track of the \"replacement chain.\"  Include this parameter if you wish Canvas to follow the replacement chain if the requested file was deleted and replaced by another.  Must be set to 'course' or 'account'. The \"replacement_chain_context_id\" parameter must also be included.
        :param int replacement_chain_context_id: When a user replaces a file during upload, Canvas keeps track of the \"replacement chain.\"  Include this parameter if you wish Canvas to follow the replacement chain if the requested file was deleted and replaced by another.  Indicates the context ID Canvas should use when following the \"replacement chain.\" The \"replacement_chain_context_type\" parameter must also be included.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_file_files_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_file_files_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_file_files_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get file  # noqa: E501

        Returns the standard attachment json object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_files_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param list[str] include: Array of additional information to include.  \"user\":: the user who uploaded the file or last edited its content \"usage_rights\":: copyright and license information for the file (see UsageRights)
        :param str replacement_chain_context_type: When a user replaces a file during upload, Canvas keeps track of the \"replacement chain.\"  Include this parameter if you wish Canvas to follow the replacement chain if the requested file was deleted and replaced by another.  Must be set to 'course' or 'account'. The \"replacement_chain_context_id\" parameter must also be included.
        :param int replacement_chain_context_id: When a user replaces a file during upload, Canvas keeps track of the \"replacement chain.\"  Include this parameter if you wish Canvas to follow the replacement chain if the requested file was deleted and replaced by another.  Indicates the context ID Canvas should use when following the \"replacement chain.\" The \"replacement_chain_context_type\" parameter must also be included.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'include', 'replacement_chain_context_type', 'replacement_chain_context_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_files" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_file_files`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'replacement_chain_context_type' in params:
            query_params.append(('replacement_chain_context_type', params['replacement_chain_context_type']))  # noqa: E501
        if 'replacement_chain_context_id' in params:
            query_params.append(('replacement_chain_context_id', params['replacement_chain_context_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/files/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_file_groups(self, group_id, id, **kwargs):  # noqa: E501
        """Get file  # noqa: E501

        Returns the standard attachment json object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_groups(group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str id: ID (required)
        :param list[str] include: Array of additional information to include.  \"user\":: the user who uploaded the file or last edited its content \"usage_rights\":: copyright and license information for the file (see UsageRights)
        :param str replacement_chain_context_type: When a user replaces a file during upload, Canvas keeps track of the \"replacement chain.\"  Include this parameter if you wish Canvas to follow the replacement chain if the requested file was deleted and replaced by another.  Must be set to 'course' or 'account'. The \"replacement_chain_context_id\" parameter must also be included.
        :param int replacement_chain_context_id: When a user replaces a file during upload, Canvas keeps track of the \"replacement chain.\"  Include this parameter if you wish Canvas to follow the replacement chain if the requested file was deleted and replaced by another.  Indicates the context ID Canvas should use when following the \"replacement chain.\" The \"replacement_chain_context_type\" parameter must also be included.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_file_groups_with_http_info(group_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_file_groups_with_http_info(group_id, id, **kwargs)  # noqa: E501
            return data

    def get_file_groups_with_http_info(self, group_id, id, **kwargs):  # noqa: E501
        """Get file  # noqa: E501

        Returns the standard attachment json object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_groups_with_http_info(group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str id: ID (required)
        :param list[str] include: Array of additional information to include.  \"user\":: the user who uploaded the file or last edited its content \"usage_rights\":: copyright and license information for the file (see UsageRights)
        :param str replacement_chain_context_type: When a user replaces a file during upload, Canvas keeps track of the \"replacement chain.\"  Include this parameter if you wish Canvas to follow the replacement chain if the requested file was deleted and replaced by another.  Must be set to 'course' or 'account'. The \"replacement_chain_context_id\" parameter must also be included.
        :param int replacement_chain_context_id: When a user replaces a file during upload, Canvas keeps track of the \"replacement chain.\"  Include this parameter if you wish Canvas to follow the replacement chain if the requested file was deleted and replaced by another.  Indicates the context ID Canvas should use when following the \"replacement chain.\" The \"replacement_chain_context_type\" parameter must also be included.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'id', 'include', 'replacement_chain_context_type', 'replacement_chain_context_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `get_file_groups`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_file_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'replacement_chain_context_type' in params:
            query_params.append(('replacement_chain_context_type', params['replacement_chain_context_type']))  # noqa: E501
        if 'replacement_chain_context_id' in params:
            query_params.append(('replacement_chain_context_id', params['replacement_chain_context_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/files/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_file_users(self, user_id, id, **kwargs):  # noqa: E501
        """Get file  # noqa: E501

        Returns the standard attachment json object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_users(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str id: ID (required)
        :param list[str] include: Array of additional information to include.  \"user\":: the user who uploaded the file or last edited its content \"usage_rights\":: copyright and license information for the file (see UsageRights)
        :param str replacement_chain_context_type: When a user replaces a file during upload, Canvas keeps track of the \"replacement chain.\"  Include this parameter if you wish Canvas to follow the replacement chain if the requested file was deleted and replaced by another.  Must be set to 'course' or 'account'. The \"replacement_chain_context_id\" parameter must also be included.
        :param int replacement_chain_context_id: When a user replaces a file during upload, Canvas keeps track of the \"replacement chain.\"  Include this parameter if you wish Canvas to follow the replacement chain if the requested file was deleted and replaced by another.  Indicates the context ID Canvas should use when following the \"replacement chain.\" The \"replacement_chain_context_type\" parameter must also be included.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_file_users_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_file_users_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def get_file_users_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Get file  # noqa: E501

        Returns the standard attachment json object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_users_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str id: ID (required)
        :param list[str] include: Array of additional information to include.  \"user\":: the user who uploaded the file or last edited its content \"usage_rights\":: copyright and license information for the file (see UsageRights)
        :param str replacement_chain_context_type: When a user replaces a file during upload, Canvas keeps track of the \"replacement chain.\"  Include this parameter if you wish Canvas to follow the replacement chain if the requested file was deleted and replaced by another.  Must be set to 'course' or 'account'. The \"replacement_chain_context_id\" parameter must also be included.
        :param int replacement_chain_context_id: When a user replaces a file during upload, Canvas keeps track of the \"replacement chain.\"  Include this parameter if you wish Canvas to follow the replacement chain if the requested file was deleted and replaced by another.  Indicates the context ID Canvas should use when following the \"replacement chain.\" The \"replacement_chain_context_type\" parameter must also be included.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'include', 'replacement_chain_context_type', 'replacement_chain_context_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `get_file_users`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_file_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'replacement_chain_context_type' in params:
            query_params.append(('replacement_chain_context_type', params['replacement_chain_context_type']))  # noqa: E501
        if 'replacement_chain_context_id' in params:
            query_params.append(('replacement_chain_context_id', params['replacement_chain_context_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/files/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_folder_courses(self, course_id, id, **kwargs):  # noqa: E501
        """Get folder  # noqa: E501

        Returns the details for a folder  You can get the root folder from a context by using 'root' as the :id. For example, you could get the root folder for a course like:  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folder_courses(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_folder_courses_with_http_info(course_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_folder_courses_with_http_info(course_id, id, **kwargs)  # noqa: E501
            return data

    def get_folder_courses_with_http_info(self, course_id, id, **kwargs):  # noqa: E501
        """Get folder  # noqa: E501

        Returns the details for a folder  You can get the root folder from a context by using 'root' as the :id. For example, you could get the root folder for a course like:  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folder_courses_with_http_info(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_folder_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `get_folder_courses`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_folder_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/folders/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Folder',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_folder_folders(self, id, **kwargs):  # noqa: E501
        """Get folder  # noqa: E501

        Returns the details for a folder  You can get the root folder from a context by using 'root' as the :id. For example, you could get the root folder for a course like:  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folder_folders(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_folder_folders_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_folder_folders_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_folder_folders_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get folder  # noqa: E501

        Returns the details for a folder  You can get the root folder from a context by using 'root' as the :id. For example, you could get the root folder for a course like:  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folder_folders_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_folder_folders" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_folder_folders`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Folder',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_folder_groups(self, group_id, id, **kwargs):  # noqa: E501
        """Get folder  # noqa: E501

        Returns the details for a folder  You can get the root folder from a context by using 'root' as the :id. For example, you could get the root folder for a course like:  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folder_groups(group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str id: ID (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_folder_groups_with_http_info(group_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_folder_groups_with_http_info(group_id, id, **kwargs)  # noqa: E501
            return data

    def get_folder_groups_with_http_info(self, group_id, id, **kwargs):  # noqa: E501
        """Get folder  # noqa: E501

        Returns the details for a folder  You can get the root folder from a context by using 'root' as the :id. For example, you could get the root folder for a course like:  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folder_groups_with_http_info(group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str id: ID (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_folder_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `get_folder_groups`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_folder_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/folders/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Folder',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_folder_users(self, user_id, id, **kwargs):  # noqa: E501
        """Get folder  # noqa: E501

        Returns the details for a folder  You can get the root folder from a context by using 'root' as the :id. For example, you could get the root folder for a course like:  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folder_users(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str id: ID (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_folder_users_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_folder_users_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def get_folder_users_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Get folder  # noqa: E501

        Returns the details for a folder  You can get the root folder from a context by using 'root' as the :id. For example, you could get the root folder for a course like:  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folder_users_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str id: ID (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_folder_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `get_folder_users`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_folder_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/folders/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Folder',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_icon_metadata(self, id, **kwargs):  # noqa: E501
        """Get icon metadata  # noqa: E501

        Returns the icon maker file attachment metadata  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_icon_metadata(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_icon_metadata_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_icon_metadata_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_icon_metadata_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get icon metadata  # noqa: E501

        Returns the icon maker file attachment metadata  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_icon_metadata_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_icon_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_icon_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/files/{id}/icon_metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_public_inline_preview_url(self, id, **kwargs):  # noqa: E501
        """Get public inline preview url  # noqa: E501

        Determine the URL that should be used for inline preview of the file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_public_inline_preview_url(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param int submission_id: The id of the submission the file is associated with.  Provide this argument to gain access to a file that has been submitted to an assignment (Canvas will verify that the file belongs to the submission and the calling user has rights to view the submission).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_public_inline_preview_url_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_public_inline_preview_url_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_public_inline_preview_url_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get public inline preview url  # noqa: E501

        Determine the URL that should be used for inline preview of the file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_public_inline_preview_url_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param int submission_id: The id of the submission the file is associated with.  Provide this argument to gain access to a file that has been submitted to an assignment (Canvas will verify that the file belongs to the submission and the calling user has rights to view the submission).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'submission_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_public_inline_preview_url" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_public_inline_preview_url`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'submission_id' in params:
            query_params.append(('submission_id', params['submission_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/files/{id}/public_url', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_quota_information_courses(self, course_id, **kwargs):  # noqa: E501
        """Get quota information  # noqa: E501

        Returns the total and used storage quota for the course, group, or user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_quota_information_courses(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_quota_information_courses_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_quota_information_courses_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def get_quota_information_courses_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Get quota information  # noqa: E501

        Returns the total and used storage quota for the course, group, or user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_quota_information_courses_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_quota_information_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `get_quota_information_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/files/quota', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_quota_information_groups(self, group_id, **kwargs):  # noqa: E501
        """Get quota information  # noqa: E501

        Returns the total and used storage quota for the course, group, or user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_quota_information_groups(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_quota_information_groups_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_quota_information_groups_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def get_quota_information_groups_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """Get quota information  # noqa: E501

        Returns the total and used storage quota for the course, group, or user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_quota_information_groups_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_quota_information_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `get_quota_information_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/files/quota', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_quota_information_users(self, user_id, **kwargs):  # noqa: E501
        """Get quota information  # noqa: E501

        Returns the total and used storage quota for the course, group, or user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_quota_information_users(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_quota_information_users_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_quota_information_users_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def get_quota_information_users_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get quota information  # noqa: E501

        Returns the total and used storage quota for the course, group, or user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_quota_information_users_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_quota_information_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `get_quota_information_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/files/quota', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_uploaded_media_folder_for_user_courses(self, course_id, **kwargs):  # noqa: E501
        """Get uploaded media folder for user  # noqa: E501

        Returns the details for a designated upload folder that the user has rights to upload to, and creates it if it doesn't exist.  If the current user does not have the permissions to manage files in the course or group, the folder will belong to the current user directly.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_uploaded_media_folder_for_user_courses(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_uploaded_media_folder_for_user_courses_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_uploaded_media_folder_for_user_courses_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def get_uploaded_media_folder_for_user_courses_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Get uploaded media folder for user  # noqa: E501

        Returns the details for a designated upload folder that the user has rights to upload to, and creates it if it doesn't exist.  If the current user does not have the permissions to manage files in the course or group, the folder will belong to the current user directly.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_uploaded_media_folder_for_user_courses_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_uploaded_media_folder_for_user_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `get_uploaded_media_folder_for_user_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/folders/media', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Folder',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_uploaded_media_folder_for_user_groups(self, group_id, **kwargs):  # noqa: E501
        """Get uploaded media folder for user  # noqa: E501

        Returns the details for a designated upload folder that the user has rights to upload to, and creates it if it doesn't exist.  If the current user does not have the permissions to manage files in the course or group, the folder will belong to the current user directly.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_uploaded_media_folder_for_user_groups(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_uploaded_media_folder_for_user_groups_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_uploaded_media_folder_for_user_groups_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def get_uploaded_media_folder_for_user_groups_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """Get uploaded media folder for user  # noqa: E501

        Returns the details for a designated upload folder that the user has rights to upload to, and creates it if it doesn't exist.  If the current user does not have the permissions to manage files in the course or group, the folder will belong to the current user directly.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_uploaded_media_folder_for_user_groups_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_uploaded_media_folder_for_user_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `get_uploaded_media_folder_for_user_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/folders/media', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Folder',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_all_folders_courses(self, course_id, **kwargs):  # noqa: E501
        """List all folders  # noqa: E501

        Returns the paginated list of all folders for the given context. This will be returned as a flat list containing all subfolders as well.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_all_folders_courses(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_all_folders_courses_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_all_folders_courses_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def list_all_folders_courses_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """List all folders  # noqa: E501

        Returns the paginated list of all folders for the given context. This will be returned as a flat list containing all subfolders as well.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_all_folders_courses_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_all_folders_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `list_all_folders_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/folders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Folder]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_all_folders_groups(self, group_id, **kwargs):  # noqa: E501
        """List all folders  # noqa: E501

        Returns the paginated list of all folders for the given context. This will be returned as a flat list containing all subfolders as well.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_all_folders_groups(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_all_folders_groups_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_all_folders_groups_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def list_all_folders_groups_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """List all folders  # noqa: E501

        Returns the paginated list of all folders for the given context. This will be returned as a flat list containing all subfolders as well.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_all_folders_groups_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_all_folders_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `list_all_folders_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/folders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Folder]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_all_folders_users(self, user_id, **kwargs):  # noqa: E501
        """List all folders  # noqa: E501

        Returns the paginated list of all folders for the given context. This will be returned as a flat list containing all subfolders as well.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_all_folders_users(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_all_folders_users_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_all_folders_users_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def list_all_folders_users_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List all folders  # noqa: E501

        Returns the paginated list of all folders for the given context. This will be returned as a flat list containing all subfolders as well.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_all_folders_users_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_all_folders_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `list_all_folders_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/folders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Folder]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_files_courses(self, course_id, **kwargs):  # noqa: E501
        """List files  # noqa: E501

        Returns the paginated list of files for the folder or course.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_files_courses(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param list[str] content_types: Filter results by content-type. You can specify type/subtype pairs (e.g., 'image/jpeg'), or simply types (e.g., 'image', which will match 'image/gif', 'image/jpeg', etc.).
        :param list[str] exclude_content_types: Exclude given content-types from your results. You can specify type/subtype pairs (e.g., 'image/jpeg'), or simply types (e.g., 'image', which will match 'image/gif', 'image/jpeg', etc.).
        :param str search_term: The partial name of the files to match and return.
        :param list[str] include: Array of additional information to include.  \"user\":: the user who uploaded the file or last edited its content \"usage_rights\":: copyright and license information for the file (see UsageRights)
        :param list[Array] only: Array of information to restrict to. Overrides include[]  \"names\":: only returns file name information
        :param str sort: Sort results by this field. Defaults to 'name'. Note that `sort=user` implies `include[]=user`.
        :param str order: The sorting order. Defaults to 'asc'.
        :return: list[File]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_files_courses_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_files_courses_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def list_files_courses_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """List files  # noqa: E501

        Returns the paginated list of files for the folder or course.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_files_courses_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param list[str] content_types: Filter results by content-type. You can specify type/subtype pairs (e.g., 'image/jpeg'), or simply types (e.g., 'image', which will match 'image/gif', 'image/jpeg', etc.).
        :param list[str] exclude_content_types: Exclude given content-types from your results. You can specify type/subtype pairs (e.g., 'image/jpeg'), or simply types (e.g., 'image', which will match 'image/gif', 'image/jpeg', etc.).
        :param str search_term: The partial name of the files to match and return.
        :param list[str] include: Array of additional information to include.  \"user\":: the user who uploaded the file or last edited its content \"usage_rights\":: copyright and license information for the file (see UsageRights)
        :param list[Array] only: Array of information to restrict to. Overrides include[]  \"names\":: only returns file name information
        :param str sort: Sort results by this field. Defaults to 'name'. Note that `sort=user` implies `include[]=user`.
        :param str order: The sorting order. Defaults to 'asc'.
        :return: list[File]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'content_types', 'exclude_content_types', 'search_term', 'include', 'only', 'sort', 'order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_files_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `list_files_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []
        if 'content_types' in params:
            query_params.append(('content_types', params['content_types']))  # noqa: E501
            collection_formats['content_types'] = 'csv'  # noqa: E501
        if 'exclude_content_types' in params:
            query_params.append(('exclude_content_types', params['exclude_content_types']))  # noqa: E501
            collection_formats['exclude_content_types'] = 'csv'  # noqa: E501
        if 'search_term' in params:
            query_params.append(('search_term', params['search_term']))  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'only' in params:
            query_params.append(('only', params['only']))  # noqa: E501
            collection_formats['only'] = 'csv'  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'order' in params:
            query_params.append(('order', params['order']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/files', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[File]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_files_folders(self, id, **kwargs):  # noqa: E501
        """List files  # noqa: E501

        Returns the paginated list of files for the folder or course.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_files_folders(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param list[str] content_types: Filter results by content-type. You can specify type/subtype pairs (e.g., 'image/jpeg'), or simply types (e.g., 'image', which will match 'image/gif', 'image/jpeg', etc.).
        :param list[str] exclude_content_types: Exclude given content-types from your results. You can specify type/subtype pairs (e.g., 'image/jpeg'), or simply types (e.g., 'image', which will match 'image/gif', 'image/jpeg', etc.).
        :param str search_term: The partial name of the files to match and return.
        :param list[str] include: Array of additional information to include.  \"user\":: the user who uploaded the file or last edited its content \"usage_rights\":: copyright and license information for the file (see UsageRights)
        :param list[Array] only: Array of information to restrict to. Overrides include[]  \"names\":: only returns file name information
        :param str sort: Sort results by this field. Defaults to 'name'. Note that `sort=user` implies `include[]=user`.
        :param str order: The sorting order. Defaults to 'asc'.
        :return: list[File]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_files_folders_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_files_folders_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def list_files_folders_with_http_info(self, id, **kwargs):  # noqa: E501
        """List files  # noqa: E501

        Returns the paginated list of files for the folder or course.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_files_folders_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param list[str] content_types: Filter results by content-type. You can specify type/subtype pairs (e.g., 'image/jpeg'), or simply types (e.g., 'image', which will match 'image/gif', 'image/jpeg', etc.).
        :param list[str] exclude_content_types: Exclude given content-types from your results. You can specify type/subtype pairs (e.g., 'image/jpeg'), or simply types (e.g., 'image', which will match 'image/gif', 'image/jpeg', etc.).
        :param str search_term: The partial name of the files to match and return.
        :param list[str] include: Array of additional information to include.  \"user\":: the user who uploaded the file or last edited its content \"usage_rights\":: copyright and license information for the file (see UsageRights)
        :param list[Array] only: Array of information to restrict to. Overrides include[]  \"names\":: only returns file name information
        :param str sort: Sort results by this field. Defaults to 'name'. Note that `sort=user` implies `include[]=user`.
        :param str order: The sorting order. Defaults to 'asc'.
        :return: list[File]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'content_types', 'exclude_content_types', 'search_term', 'include', 'only', 'sort', 'order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_files_folders" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `list_files_folders`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'content_types' in params:
            query_params.append(('content_types', params['content_types']))  # noqa: E501
            collection_formats['content_types'] = 'csv'  # noqa: E501
        if 'exclude_content_types' in params:
            query_params.append(('exclude_content_types', params['exclude_content_types']))  # noqa: E501
            collection_formats['exclude_content_types'] = 'csv'  # noqa: E501
        if 'search_term' in params:
            query_params.append(('search_term', params['search_term']))  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'only' in params:
            query_params.append(('only', params['only']))  # noqa: E501
            collection_formats['only'] = 'csv'  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'order' in params:
            query_params.append(('order', params['order']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders/{id}/files', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[File]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_files_groups(self, group_id, **kwargs):  # noqa: E501
        """List files  # noqa: E501

        Returns the paginated list of files for the folder or course.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_files_groups(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param list[str] content_types: Filter results by content-type. You can specify type/subtype pairs (e.g., 'image/jpeg'), or simply types (e.g., 'image', which will match 'image/gif', 'image/jpeg', etc.).
        :param list[str] exclude_content_types: Exclude given content-types from your results. You can specify type/subtype pairs (e.g., 'image/jpeg'), or simply types (e.g., 'image', which will match 'image/gif', 'image/jpeg', etc.).
        :param str search_term: The partial name of the files to match and return.
        :param list[str] include: Array of additional information to include.  \"user\":: the user who uploaded the file or last edited its content \"usage_rights\":: copyright and license information for the file (see UsageRights)
        :param list[Array] only: Array of information to restrict to. Overrides include[]  \"names\":: only returns file name information
        :param str sort: Sort results by this field. Defaults to 'name'. Note that `sort=user` implies `include[]=user`.
        :param str order: The sorting order. Defaults to 'asc'.
        :return: list[File]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_files_groups_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_files_groups_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def list_files_groups_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """List files  # noqa: E501

        Returns the paginated list of files for the folder or course.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_files_groups_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param list[str] content_types: Filter results by content-type. You can specify type/subtype pairs (e.g., 'image/jpeg'), or simply types (e.g., 'image', which will match 'image/gif', 'image/jpeg', etc.).
        :param list[str] exclude_content_types: Exclude given content-types from your results. You can specify type/subtype pairs (e.g., 'image/jpeg'), or simply types (e.g., 'image', which will match 'image/gif', 'image/jpeg', etc.).
        :param str search_term: The partial name of the files to match and return.
        :param list[str] include: Array of additional information to include.  \"user\":: the user who uploaded the file or last edited its content \"usage_rights\":: copyright and license information for the file (see UsageRights)
        :param list[Array] only: Array of information to restrict to. Overrides include[]  \"names\":: only returns file name information
        :param str sort: Sort results by this field. Defaults to 'name'. Note that `sort=user` implies `include[]=user`.
        :param str order: The sorting order. Defaults to 'asc'.
        :return: list[File]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'content_types', 'exclude_content_types', 'search_term', 'include', 'only', 'sort', 'order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_files_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `list_files_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []
        if 'content_types' in params:
            query_params.append(('content_types', params['content_types']))  # noqa: E501
            collection_formats['content_types'] = 'csv'  # noqa: E501
        if 'exclude_content_types' in params:
            query_params.append(('exclude_content_types', params['exclude_content_types']))  # noqa: E501
            collection_formats['exclude_content_types'] = 'csv'  # noqa: E501
        if 'search_term' in params:
            query_params.append(('search_term', params['search_term']))  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'only' in params:
            query_params.append(('only', params['only']))  # noqa: E501
            collection_formats['only'] = 'csv'  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'order' in params:
            query_params.append(('order', params['order']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/files', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[File]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_files_users(self, user_id, **kwargs):  # noqa: E501
        """List files  # noqa: E501

        Returns the paginated list of files for the folder or course.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_files_users(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param list[str] content_types: Filter results by content-type. You can specify type/subtype pairs (e.g., 'image/jpeg'), or simply types (e.g., 'image', which will match 'image/gif', 'image/jpeg', etc.).
        :param list[str] exclude_content_types: Exclude given content-types from your results. You can specify type/subtype pairs (e.g., 'image/jpeg'), or simply types (e.g., 'image', which will match 'image/gif', 'image/jpeg', etc.).
        :param str search_term: The partial name of the files to match and return.
        :param list[str] include: Array of additional information to include.  \"user\":: the user who uploaded the file or last edited its content \"usage_rights\":: copyright and license information for the file (see UsageRights)
        :param list[Array] only: Array of information to restrict to. Overrides include[]  \"names\":: only returns file name information
        :param str sort: Sort results by this field. Defaults to 'name'. Note that `sort=user` implies `include[]=user`.
        :param str order: The sorting order. Defaults to 'asc'.
        :return: list[File]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_files_users_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_files_users_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def list_files_users_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List files  # noqa: E501

        Returns the paginated list of files for the folder or course.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_files_users_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param list[str] content_types: Filter results by content-type. You can specify type/subtype pairs (e.g., 'image/jpeg'), or simply types (e.g., 'image', which will match 'image/gif', 'image/jpeg', etc.).
        :param list[str] exclude_content_types: Exclude given content-types from your results. You can specify type/subtype pairs (e.g., 'image/jpeg'), or simply types (e.g., 'image', which will match 'image/gif', 'image/jpeg', etc.).
        :param str search_term: The partial name of the files to match and return.
        :param list[str] include: Array of additional information to include.  \"user\":: the user who uploaded the file or last edited its content \"usage_rights\":: copyright and license information for the file (see UsageRights)
        :param list[Array] only: Array of information to restrict to. Overrides include[]  \"names\":: only returns file name information
        :param str sort: Sort results by this field. Defaults to 'name'. Note that `sort=user` implies `include[]=user`.
        :param str order: The sorting order. Defaults to 'asc'.
        :return: list[File]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'content_types', 'exclude_content_types', 'search_term', 'include', 'only', 'sort', 'order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_files_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `list_files_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'content_types' in params:
            query_params.append(('content_types', params['content_types']))  # noqa: E501
            collection_formats['content_types'] = 'csv'  # noqa: E501
        if 'exclude_content_types' in params:
            query_params.append(('exclude_content_types', params['exclude_content_types']))  # noqa: E501
            collection_formats['exclude_content_types'] = 'csv'  # noqa: E501
        if 'search_term' in params:
            query_params.append(('search_term', params['search_term']))  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'only' in params:
            query_params.append(('only', params['only']))  # noqa: E501
            collection_formats['only'] = 'csv'  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'order' in params:
            query_params.append(('order', params['order']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/files', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[File]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_folders(self, id, **kwargs):  # noqa: E501
        """List folders  # noqa: E501

        Returns the paginated list of folders in the folder.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_folders(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_folders_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_folders_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def list_folders_with_http_info(self, id, **kwargs):  # noqa: E501
        """List folders  # noqa: E501

        Returns the paginated list of folders in the folder.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_folders_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_folders" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `list_folders`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders/{id}/folders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Folder]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_licenses_courses(self, course_id, **kwargs):  # noqa: E501
        """List licenses  # noqa: E501

        A paginated list of licenses that can be applied  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_licenses_courses(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: list[License]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_licenses_courses_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_licenses_courses_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def list_licenses_courses_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """List licenses  # noqa: E501

        A paginated list of licenses that can be applied  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_licenses_courses_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: list[License]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_licenses_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `list_licenses_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/content_licenses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[License]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_licenses_groups(self, group_id, **kwargs):  # noqa: E501
        """List licenses  # noqa: E501

        A paginated list of licenses that can be applied  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_licenses_groups(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: list[License]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_licenses_groups_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_licenses_groups_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def list_licenses_groups_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """List licenses  # noqa: E501

        A paginated list of licenses that can be applied  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_licenses_groups_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: list[License]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_licenses_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `list_licenses_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/content_licenses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[License]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_licenses_users(self, user_id, **kwargs):  # noqa: E501
        """List licenses  # noqa: E501

        A paginated list of licenses that can be applied  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_licenses_users(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: list[License]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_licenses_users_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_licenses_users_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def list_licenses_users_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List licenses  # noqa: E501

        A paginated list of licenses that can be applied  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_licenses_users_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: list[License]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_licenses_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `list_licenses_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/content_licenses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[License]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_usage_rights_courses(self, course_id, file_ids, **kwargs):  # noqa: E501
        """Remove usage rights  # noqa: E501

        Removes copyright and license information associated with one or more files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_usage_rights_courses(course_id, file_ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param list[str] file_ids: List of ids of files to remove associated usage rights from. (required)
        :param list[str] folder_ids: List of ids of folders. Usage rights will be removed from all files in these folders.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_usage_rights_courses_with_http_info(course_id, file_ids, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_usage_rights_courses_with_http_info(course_id, file_ids, **kwargs)  # noqa: E501
            return data

    def remove_usage_rights_courses_with_http_info(self, course_id, file_ids, **kwargs):  # noqa: E501
        """Remove usage rights  # noqa: E501

        Removes copyright and license information associated with one or more files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_usage_rights_courses_with_http_info(course_id, file_ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param list[str] file_ids: List of ids of files to remove associated usage rights from. (required)
        :param list[str] folder_ids: List of ids of folders. Usage rights will be removed from all files in these folders.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'file_ids', 'folder_ids']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_usage_rights_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `remove_usage_rights_courses`")  # noqa: E501
        # verify the required parameter 'file_ids' is set
        if self.api_client.client_side_validation and ('file_ids' not in params or
                                                       params['file_ids'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `file_ids` when calling `remove_usage_rights_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []
        if 'file_ids' in params:
            query_params.append(('file_ids', params['file_ids']))  # noqa: E501
            collection_formats['file_ids'] = 'csv'  # noqa: E501
        if 'folder_ids' in params:
            query_params.append(('folder_ids', params['folder_ids']))  # noqa: E501
            collection_formats['folder_ids'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/usage_rights', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_usage_rights_groups(self, group_id, file_ids, **kwargs):  # noqa: E501
        """Remove usage rights  # noqa: E501

        Removes copyright and license information associated with one or more files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_usage_rights_groups(group_id, file_ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param list[str] file_ids: List of ids of files to remove associated usage rights from. (required)
        :param list[str] folder_ids: List of ids of folders. Usage rights will be removed from all files in these folders.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_usage_rights_groups_with_http_info(group_id, file_ids, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_usage_rights_groups_with_http_info(group_id, file_ids, **kwargs)  # noqa: E501
            return data

    def remove_usage_rights_groups_with_http_info(self, group_id, file_ids, **kwargs):  # noqa: E501
        """Remove usage rights  # noqa: E501

        Removes copyright and license information associated with one or more files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_usage_rights_groups_with_http_info(group_id, file_ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param list[str] file_ids: List of ids of files to remove associated usage rights from. (required)
        :param list[str] folder_ids: List of ids of folders. Usage rights will be removed from all files in these folders.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'file_ids', 'folder_ids']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_usage_rights_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `remove_usage_rights_groups`")  # noqa: E501
        # verify the required parameter 'file_ids' is set
        if self.api_client.client_side_validation and ('file_ids' not in params or
                                                       params['file_ids'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `file_ids` when calling `remove_usage_rights_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []
        if 'file_ids' in params:
            query_params.append(('file_ids', params['file_ids']))  # noqa: E501
            collection_formats['file_ids'] = 'csv'  # noqa: E501
        if 'folder_ids' in params:
            query_params.append(('folder_ids', params['folder_ids']))  # noqa: E501
            collection_formats['folder_ids'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/usage_rights', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_usage_rights_users(self, user_id, file_ids, **kwargs):  # noqa: E501
        """Remove usage rights  # noqa: E501

        Removes copyright and license information associated with one or more files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_usage_rights_users(user_id, file_ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param list[str] file_ids: List of ids of files to remove associated usage rights from. (required)
        :param list[str] folder_ids: List of ids of folders. Usage rights will be removed from all files in these folders.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_usage_rights_users_with_http_info(user_id, file_ids, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_usage_rights_users_with_http_info(user_id, file_ids, **kwargs)  # noqa: E501
            return data

    def remove_usage_rights_users_with_http_info(self, user_id, file_ids, **kwargs):  # noqa: E501
        """Remove usage rights  # noqa: E501

        Removes copyright and license information associated with one or more files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_usage_rights_users_with_http_info(user_id, file_ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param list[str] file_ids: List of ids of files to remove associated usage rights from. (required)
        :param list[str] folder_ids: List of ids of folders. Usage rights will be removed from all files in these folders.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'file_ids', 'folder_ids']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_usage_rights_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `remove_usage_rights_users`")  # noqa: E501
        # verify the required parameter 'file_ids' is set
        if self.api_client.client_side_validation and ('file_ids' not in params or
                                                       params['file_ids'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `file_ids` when calling `remove_usage_rights_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'file_ids' in params:
            query_params.append(('file_ids', params['file_ids']))  # noqa: E501
            collection_formats['file_ids'] = 'csv'  # noqa: E501
        if 'folder_ids' in params:
            query_params.append(('folder_ids', params['folder_ids']))  # noqa: E501
            collection_formats['folder_ids'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/usage_rights', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reset_link_verifier(self, id, **kwargs):  # noqa: E501
        """Reset link verifier  # noqa: E501

        Resets the link verifier. Any existing links to the file using the previous hard-coded \"verifier\" parameter will no longer automatically grant access.  Must have manage files and become other users permissions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_link_verifier(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reset_link_verifier_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.reset_link_verifier_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def reset_link_verifier_with_http_info(self, id, **kwargs):  # noqa: E501
        """Reset link verifier  # noqa: E501

        Resets the link verifier. Any existing links to the file using the previous hard-coded \"verifier\" parameter will no longer automatically grant access.  Must have manage files and become other users permissions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_link_verifier_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_link_verifier" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `reset_link_verifier`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/files/{id}/reset_verifier', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def resolve_path_courses(self, course_id, **kwargs):  # noqa: E501
        """Resolve path  # noqa: E501

        Given the full path to a folder, returns a list of all Folders in the path hierarchy, starting at the root folder, and ending at the requested folder. The given path is relative to the context's root folder and does not include the root folder's name (e.g., \"course files\"). If an empty path is given, the context's root folder alone is returned. Otherwise, if no folder exists with the given full path, a Not Found error is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resolve_path_courses(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.resolve_path_courses_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.resolve_path_courses_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def resolve_path_courses_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Resolve path  # noqa: E501

        Given the full path to a folder, returns a list of all Folders in the path hierarchy, starting at the root folder, and ending at the requested folder. The given path is relative to the context's root folder and does not include the root folder's name (e.g., \"course files\"). If an empty path is given, the context's root folder alone is returned. Otherwise, if no folder exists with the given full path, a Not Found error is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resolve_path_courses_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resolve_path_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `resolve_path_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/folders/by_path', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Folder]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def resolve_path_courses_full_path(self, course_id, **kwargs):  # noqa: E501
        """Resolve path  # noqa: E501

        Given the full path to a folder, returns a list of all Folders in the path hierarchy, starting at the root folder, and ending at the requested folder. The given path is relative to the context's root folder and does not include the root folder's name (e.g., \"course files\"). If an empty path is given, the context's root folder alone is returned. Otherwise, if no folder exists with the given full path, a Not Found error is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resolve_path_courses_full_path(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.resolve_path_courses_full_path_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.resolve_path_courses_full_path_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def resolve_path_courses_full_path_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Resolve path  # noqa: E501

        Given the full path to a folder, returns a list of all Folders in the path hierarchy, starting at the root folder, and ending at the requested folder. The given path is relative to the context's root folder and does not include the root folder's name (e.g., \"course files\"). If an empty path is given, the context's root folder alone is returned. Otherwise, if no folder exists with the given full path, a Not Found error is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resolve_path_courses_full_path_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resolve_path_courses_full_path" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `resolve_path_courses_full_path`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/folders/by_path/*full_path', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Folder]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def resolve_path_groups(self, group_id, **kwargs):  # noqa: E501
        """Resolve path  # noqa: E501

        Given the full path to a folder, returns a list of all Folders in the path hierarchy, starting at the root folder, and ending at the requested folder. The given path is relative to the context's root folder and does not include the root folder's name (e.g., \"course files\"). If an empty path is given, the context's root folder alone is returned. Otherwise, if no folder exists with the given full path, a Not Found error is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resolve_path_groups(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.resolve_path_groups_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.resolve_path_groups_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def resolve_path_groups_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """Resolve path  # noqa: E501

        Given the full path to a folder, returns a list of all Folders in the path hierarchy, starting at the root folder, and ending at the requested folder. The given path is relative to the context's root folder and does not include the root folder's name (e.g., \"course files\"). If an empty path is given, the context's root folder alone is returned. Otherwise, if no folder exists with the given full path, a Not Found error is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resolve_path_groups_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resolve_path_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `resolve_path_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/folders/by_path', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Folder]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def resolve_path_groups_full_path(self, group_id, **kwargs):  # noqa: E501
        """Resolve path  # noqa: E501

        Given the full path to a folder, returns a list of all Folders in the path hierarchy, starting at the root folder, and ending at the requested folder. The given path is relative to the context's root folder and does not include the root folder's name (e.g., \"course files\"). If an empty path is given, the context's root folder alone is returned. Otherwise, if no folder exists with the given full path, a Not Found error is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resolve_path_groups_full_path(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.resolve_path_groups_full_path_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.resolve_path_groups_full_path_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def resolve_path_groups_full_path_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """Resolve path  # noqa: E501

        Given the full path to a folder, returns a list of all Folders in the path hierarchy, starting at the root folder, and ending at the requested folder. The given path is relative to the context's root folder and does not include the root folder's name (e.g., \"course files\"). If an empty path is given, the context's root folder alone is returned. Otherwise, if no folder exists with the given full path, a Not Found error is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resolve_path_groups_full_path_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resolve_path_groups_full_path" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `resolve_path_groups_full_path`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/folders/by_path/*full_path', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Folder]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def resolve_path_users(self, user_id, **kwargs):  # noqa: E501
        """Resolve path  # noqa: E501

        Given the full path to a folder, returns a list of all Folders in the path hierarchy, starting at the root folder, and ending at the requested folder. The given path is relative to the context's root folder and does not include the root folder's name (e.g., \"course files\"). If an empty path is given, the context's root folder alone is returned. Otherwise, if no folder exists with the given full path, a Not Found error is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resolve_path_users(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.resolve_path_users_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.resolve_path_users_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def resolve_path_users_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Resolve path  # noqa: E501

        Given the full path to a folder, returns a list of all Folders in the path hierarchy, starting at the root folder, and ending at the requested folder. The given path is relative to the context's root folder and does not include the root folder's name (e.g., \"course files\"). If an empty path is given, the context's root folder alone is returned. Otherwise, if no folder exists with the given full path, a Not Found error is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resolve_path_users_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resolve_path_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `resolve_path_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/folders/by_path', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Folder]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def resolve_path_users_full_path(self, user_id, **kwargs):  # noqa: E501
        """Resolve path  # noqa: E501

        Given the full path to a folder, returns a list of all Folders in the path hierarchy, starting at the root folder, and ending at the requested folder. The given path is relative to the context's root folder and does not include the root folder's name (e.g., \"course files\"). If an empty path is given, the context's root folder alone is returned. Otherwise, if no folder exists with the given full path, a Not Found error is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resolve_path_users_full_path(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.resolve_path_users_full_path_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.resolve_path_users_full_path_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def resolve_path_users_full_path_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Resolve path  # noqa: E501

        Given the full path to a folder, returns a list of all Folders in the path hierarchy, starting at the root folder, and ending at the requested folder. The given path is relative to the context's root folder and does not include the root folder's name (e.g., \"course files\"). If an empty path is given, the context's root folder alone is returned. Otherwise, if no folder exists with the given full path, a Not Found error is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resolve_path_users_full_path_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: list[Folder]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resolve_path_users_full_path" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `resolve_path_users_full_path`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/folders/by_path/*full_path', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Folder]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_usage_rights_courses(self, course_id, file_ids, usage_rights_use_justification, **kwargs):  # noqa: E501
        """Set usage rights  # noqa: E501

        Sets copyright and license information for one or more files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_usage_rights_courses(course_id, file_ids, usage_rights_use_justification, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param list[str] file_ids: List of ids of files to set usage rights for. (required)
        :param str usage_rights_use_justification: The intellectual property justification for using the files in Canvas (required)
        :param list[str] folder_ids: List of ids of folders to search for files to set usage rights for. Note that new files uploaded to these folders do not automatically inherit these rights.
        :param bool publish: Whether the file(s) or folder(s) should be published on save, provided that usage rights have been specified (set to `true` to publish on save).
        :param str usage_rights_legal_copyright: The legal copyright line for the files
        :param str usage_rights_license: The license that applies to the files. See the {api:UsageRightsController#licenses List licenses endpoint} for the supported license types.
        :return: UsageRights
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_usage_rights_courses_with_http_info(course_id, file_ids, usage_rights_use_justification, **kwargs)  # noqa: E501
        else:
            (data) = self.set_usage_rights_courses_with_http_info(course_id, file_ids, usage_rights_use_justification, **kwargs)  # noqa: E501
            return data

    def set_usage_rights_courses_with_http_info(self, course_id, file_ids, usage_rights_use_justification, **kwargs):  # noqa: E501
        """Set usage rights  # noqa: E501

        Sets copyright and license information for one or more files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_usage_rights_courses_with_http_info(course_id, file_ids, usage_rights_use_justification, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param list[str] file_ids: List of ids of files to set usage rights for. (required)
        :param str usage_rights_use_justification: The intellectual property justification for using the files in Canvas (required)
        :param list[str] folder_ids: List of ids of folders to search for files to set usage rights for. Note that new files uploaded to these folders do not automatically inherit these rights.
        :param bool publish: Whether the file(s) or folder(s) should be published on save, provided that usage rights have been specified (set to `true` to publish on save).
        :param str usage_rights_legal_copyright: The legal copyright line for the files
        :param str usage_rights_license: The license that applies to the files. See the {api:UsageRightsController#licenses List licenses endpoint} for the supported license types.
        :return: UsageRights
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'file_ids', 'usage_rights_use_justification', 'folder_ids', 'publish', 'usage_rights_legal_copyright', 'usage_rights_license']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_usage_rights_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `set_usage_rights_courses`")  # noqa: E501
        # verify the required parameter 'file_ids' is set
        if self.api_client.client_side_validation and ('file_ids' not in params or
                                                       params['file_ids'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `file_ids` when calling `set_usage_rights_courses`")  # noqa: E501
        # verify the required parameter 'usage_rights_use_justification' is set
        if self.api_client.client_side_validation and ('usage_rights_use_justification' not in params or
                                                       params['usage_rights_use_justification'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `usage_rights_use_justification` when calling `set_usage_rights_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file_ids' in params:
            form_params.append(('file_ids', params['file_ids']))  # noqa: E501
            collection_formats['file_ids'] = 'csv'  # noqa: E501
        if 'folder_ids' in params:
            form_params.append(('folder_ids', params['folder_ids']))  # noqa: E501
            collection_formats['folder_ids'] = 'csv'  # noqa: E501
        if 'publish' in params:
            form_params.append(('publish', params['publish']))  # noqa: E501
        if 'usage_rights_use_justification' in params:
            form_params.append(('usage_rights[use_justification]', params['usage_rights_use_justification']))  # noqa: E501
        if 'usage_rights_legal_copyright' in params:
            form_params.append(('usage_rights[legal_copyright]', params['usage_rights_legal_copyright']))  # noqa: E501
        if 'usage_rights_license' in params:
            form_params.append(('usage_rights[license]', params['usage_rights_license']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/usage_rights', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UsageRights',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_usage_rights_groups(self, group_id, file_ids, usage_rights_use_justification, **kwargs):  # noqa: E501
        """Set usage rights  # noqa: E501

        Sets copyright and license information for one or more files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_usage_rights_groups(group_id, file_ids, usage_rights_use_justification, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param list[str] file_ids: List of ids of files to set usage rights for. (required)
        :param str usage_rights_use_justification: The intellectual property justification for using the files in Canvas (required)
        :param list[str] folder_ids: List of ids of folders to search for files to set usage rights for. Note that new files uploaded to these folders do not automatically inherit these rights.
        :param bool publish: Whether the file(s) or folder(s) should be published on save, provided that usage rights have been specified (set to `true` to publish on save).
        :param str usage_rights_legal_copyright: The legal copyright line for the files
        :param str usage_rights_license: The license that applies to the files. See the {api:UsageRightsController#licenses List licenses endpoint} for the supported license types.
        :return: UsageRights
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_usage_rights_groups_with_http_info(group_id, file_ids, usage_rights_use_justification, **kwargs)  # noqa: E501
        else:
            (data) = self.set_usage_rights_groups_with_http_info(group_id, file_ids, usage_rights_use_justification, **kwargs)  # noqa: E501
            return data

    def set_usage_rights_groups_with_http_info(self, group_id, file_ids, usage_rights_use_justification, **kwargs):  # noqa: E501
        """Set usage rights  # noqa: E501

        Sets copyright and license information for one or more files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_usage_rights_groups_with_http_info(group_id, file_ids, usage_rights_use_justification, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param list[str] file_ids: List of ids of files to set usage rights for. (required)
        :param str usage_rights_use_justification: The intellectual property justification for using the files in Canvas (required)
        :param list[str] folder_ids: List of ids of folders to search for files to set usage rights for. Note that new files uploaded to these folders do not automatically inherit these rights.
        :param bool publish: Whether the file(s) or folder(s) should be published on save, provided that usage rights have been specified (set to `true` to publish on save).
        :param str usage_rights_legal_copyright: The legal copyright line for the files
        :param str usage_rights_license: The license that applies to the files. See the {api:UsageRightsController#licenses List licenses endpoint} for the supported license types.
        :return: UsageRights
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'file_ids', 'usage_rights_use_justification', 'folder_ids', 'publish', 'usage_rights_legal_copyright', 'usage_rights_license']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_usage_rights_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `set_usage_rights_groups`")  # noqa: E501
        # verify the required parameter 'file_ids' is set
        if self.api_client.client_side_validation and ('file_ids' not in params or
                                                       params['file_ids'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `file_ids` when calling `set_usage_rights_groups`")  # noqa: E501
        # verify the required parameter 'usage_rights_use_justification' is set
        if self.api_client.client_side_validation and ('usage_rights_use_justification' not in params or
                                                       params['usage_rights_use_justification'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `usage_rights_use_justification` when calling `set_usage_rights_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file_ids' in params:
            form_params.append(('file_ids', params['file_ids']))  # noqa: E501
            collection_formats['file_ids'] = 'csv'  # noqa: E501
        if 'folder_ids' in params:
            form_params.append(('folder_ids', params['folder_ids']))  # noqa: E501
            collection_formats['folder_ids'] = 'csv'  # noqa: E501
        if 'publish' in params:
            form_params.append(('publish', params['publish']))  # noqa: E501
        if 'usage_rights_use_justification' in params:
            form_params.append(('usage_rights[use_justification]', params['usage_rights_use_justification']))  # noqa: E501
        if 'usage_rights_legal_copyright' in params:
            form_params.append(('usage_rights[legal_copyright]', params['usage_rights_legal_copyright']))  # noqa: E501
        if 'usage_rights_license' in params:
            form_params.append(('usage_rights[license]', params['usage_rights_license']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/usage_rights', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UsageRights',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_usage_rights_users(self, user_id, file_ids, usage_rights_use_justification, **kwargs):  # noqa: E501
        """Set usage rights  # noqa: E501

        Sets copyright and license information for one or more files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_usage_rights_users(user_id, file_ids, usage_rights_use_justification, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param list[str] file_ids: List of ids of files to set usage rights for. (required)
        :param str usage_rights_use_justification: The intellectual property justification for using the files in Canvas (required)
        :param list[str] folder_ids: List of ids of folders to search for files to set usage rights for. Note that new files uploaded to these folders do not automatically inherit these rights.
        :param bool publish: Whether the file(s) or folder(s) should be published on save, provided that usage rights have been specified (set to `true` to publish on save).
        :param str usage_rights_legal_copyright: The legal copyright line for the files
        :param str usage_rights_license: The license that applies to the files. See the {api:UsageRightsController#licenses List licenses endpoint} for the supported license types.
        :return: UsageRights
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_usage_rights_users_with_http_info(user_id, file_ids, usage_rights_use_justification, **kwargs)  # noqa: E501
        else:
            (data) = self.set_usage_rights_users_with_http_info(user_id, file_ids, usage_rights_use_justification, **kwargs)  # noqa: E501
            return data

    def set_usage_rights_users_with_http_info(self, user_id, file_ids, usage_rights_use_justification, **kwargs):  # noqa: E501
        """Set usage rights  # noqa: E501

        Sets copyright and license information for one or more files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_usage_rights_users_with_http_info(user_id, file_ids, usage_rights_use_justification, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param list[str] file_ids: List of ids of files to set usage rights for. (required)
        :param str usage_rights_use_justification: The intellectual property justification for using the files in Canvas (required)
        :param list[str] folder_ids: List of ids of folders to search for files to set usage rights for. Note that new files uploaded to these folders do not automatically inherit these rights.
        :param bool publish: Whether the file(s) or folder(s) should be published on save, provided that usage rights have been specified (set to `true` to publish on save).
        :param str usage_rights_legal_copyright: The legal copyright line for the files
        :param str usage_rights_license: The license that applies to the files. See the {api:UsageRightsController#licenses List licenses endpoint} for the supported license types.
        :return: UsageRights
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'file_ids', 'usage_rights_use_justification', 'folder_ids', 'publish', 'usage_rights_legal_copyright', 'usage_rights_license']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_usage_rights_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `set_usage_rights_users`")  # noqa: E501
        # verify the required parameter 'file_ids' is set
        if self.api_client.client_side_validation and ('file_ids' not in params or
                                                       params['file_ids'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `file_ids` when calling `set_usage_rights_users`")  # noqa: E501
        # verify the required parameter 'usage_rights_use_justification' is set
        if self.api_client.client_side_validation and ('usage_rights_use_justification' not in params or
                                                       params['usage_rights_use_justification'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `usage_rights_use_justification` when calling `set_usage_rights_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file_ids' in params:
            form_params.append(('file_ids', params['file_ids']))  # noqa: E501
            collection_formats['file_ids'] = 'csv'  # noqa: E501
        if 'folder_ids' in params:
            form_params.append(('folder_ids', params['folder_ids']))  # noqa: E501
            collection_formats['folder_ids'] = 'csv'  # noqa: E501
        if 'publish' in params:
            form_params.append(('publish', params['publish']))  # noqa: E501
        if 'usage_rights_use_justification' in params:
            form_params.append(('usage_rights[use_justification]', params['usage_rights_use_justification']))  # noqa: E501
        if 'usage_rights_legal_copyright' in params:
            form_params.append(('usage_rights[legal_copyright]', params['usage_rights_legal_copyright']))  # noqa: E501
        if 'usage_rights_license' in params:
            form_params.append(('usage_rights[license]', params['usage_rights_license']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/usage_rights', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UsageRights',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def translate_file_reference(self, course_id, migration_id, **kwargs):  # noqa: E501
        """Translate file reference  # noqa: E501

        Get information about a file from a course copy file reference  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.translate_file_reference(course_id, migration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str migration_id: ID (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.translate_file_reference_with_http_info(course_id, migration_id, **kwargs)  # noqa: E501
        else:
            (data) = self.translate_file_reference_with_http_info(course_id, migration_id, **kwargs)  # noqa: E501
            return data

    def translate_file_reference_with_http_info(self, course_id, migration_id, **kwargs):  # noqa: E501
        """Translate file reference  # noqa: E501

        Get information about a file from a course copy file reference  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.translate_file_reference_with_http_info(course_id, migration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str migration_id: ID (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'migration_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method translate_file_reference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `translate_file_reference`")  # noqa: E501
        # verify the required parameter 'migration_id' is set
        if self.api_client.client_side_validation and ('migration_id' not in params or
                                                       params['migration_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `migration_id` when calling `translate_file_reference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'migration_id' in params:
            path_params['migration_id'] = params['migration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/files/file_ref/{migration_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_file(self, id, **kwargs):  # noqa: E501
        """Update file  # noqa: E501

        Update some settings on the specified file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_file(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str name: The new display name of the file, with a limit of 255 characters.
        :param str parent_folder_id: The id of the folder to move this file into. The new folder must be in the same context as the original parent folder. If the file is in a context without folders this does not apply.
        :param str on_duplicate: If the file is moved to a folder containing a file with the same name, or renamed to a name matching an existing file, the API call will fail unless this parameter is supplied.  \"overwrite\":: Replace the existing file with the same name \"rename\":: Add a qualifier to make the new filename unique
        :param Object lock_at: The datetime to lock the file at
        :param Object unlock_at: The datetime to unlock the file at
        :param bool locked: Flag the file as locked
        :param bool hidden: Flag the file as hidden
        :param str visibility_level: Configure which roles can access this file
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_file_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_file_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_file_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update file  # noqa: E501

        Update some settings on the specified file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_file_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str name: The new display name of the file, with a limit of 255 characters.
        :param str parent_folder_id: The id of the folder to move this file into. The new folder must be in the same context as the original parent folder. If the file is in a context without folders this does not apply.
        :param str on_duplicate: If the file is moved to a folder containing a file with the same name, or renamed to a name matching an existing file, the API call will fail unless this parameter is supplied.  \"overwrite\":: Replace the existing file with the same name \"rename\":: Add a qualifier to make the new filename unique
        :param Object lock_at: The datetime to lock the file at
        :param Object unlock_at: The datetime to unlock the file at
        :param bool locked: Flag the file as locked
        :param bool hidden: Flag the file as hidden
        :param str visibility_level: Configure which roles can access this file
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'parent_folder_id', 'on_duplicate', 'lock_at', 'unlock_at', 'locked', 'hidden', 'visibility_level']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'parent_folder_id' in params:
            form_params.append(('parent_folder_id', params['parent_folder_id']))  # noqa: E501
        if 'on_duplicate' in params:
            form_params.append(('on_duplicate', params['on_duplicate']))  # noqa: E501
        if 'lock_at' in params:
            form_params.append(('lock_at', params['lock_at']))  # noqa: E501
        if 'unlock_at' in params:
            form_params.append(('unlock_at', params['unlock_at']))  # noqa: E501
        if 'locked' in params:
            form_params.append(('locked', params['locked']))  # noqa: E501
        if 'hidden' in params:
            form_params.append(('hidden', params['hidden']))  # noqa: E501
        if 'visibility_level' in params:
            form_params.append(('visibility_level', params['visibility_level']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/files/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_folder(self, id, **kwargs):  # noqa: E501
        """Update folder  # noqa: E501

        Updates a folder  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_folder(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str name: The new name of the folder
        :param str parent_folder_id: The id of the folder to move this folder into. The new folder must be in the same context as the original parent folder.
        :param Object lock_at: The datetime to lock the folder at
        :param Object unlock_at: The datetime to unlock the folder at
        :param bool locked: Flag the folder as locked
        :param bool hidden: Flag the folder as hidden
        :param int position: Set an explicit sort position for the folder
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_folder_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_folder_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_folder_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update folder  # noqa: E501

        Updates a folder  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_folder_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str name: The new name of the folder
        :param str parent_folder_id: The id of the folder to move this folder into. The new folder must be in the same context as the original parent folder.
        :param Object lock_at: The datetime to lock the folder at
        :param Object unlock_at: The datetime to unlock the folder at
        :param bool locked: Flag the folder as locked
        :param bool hidden: Flag the folder as hidden
        :param int position: Set an explicit sort position for the folder
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'parent_folder_id', 'lock_at', 'unlock_at', 'locked', 'hidden', 'position']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'parent_folder_id' in params:
            form_params.append(('parent_folder_id', params['parent_folder_id']))  # noqa: E501
        if 'lock_at' in params:
            form_params.append(('lock_at', params['lock_at']))  # noqa: E501
        if 'unlock_at' in params:
            form_params.append(('unlock_at', params['unlock_at']))  # noqa: E501
        if 'locked' in params:
            form_params.append(('locked', params['locked']))  # noqa: E501
        if 'hidden' in params:
            form_params.append(('hidden', params['hidden']))  # noqa: E501
        if 'position' in params:
            form_params.append(('position', params['position']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Folder',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_file(self, folder_id, **kwargs):  # noqa: E501
        """Upload a file  # noqa: E501

        Upload a file to a folder.  This API endpoint is the first step in uploading a file. See the {file:file_uploads.html File Upload Documentation} for details on the file upload workflow.  Only those with the \"Manage Files\" permission on a course or group can upload files to a folder in that course or group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_file_with_http_info(folder_id, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_file_with_http_info(folder_id, **kwargs)  # noqa: E501
            return data

    def upload_file_with_http_info(self, folder_id, **kwargs):  # noqa: E501
        """Upload a file  # noqa: E501

        Upload a file to a folder.  This API endpoint is the first step in uploading a file. See the {file:file_uploads.html File Upload Documentation} for details on the file upload workflow.  Only those with the \"Manage Files\" permission on a course or group can upload files to a folder in that course or group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file_with_http_info(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if self.api_client.client_side_validation and ('folder_id' not in params or
                                                       params['folder_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `folder_id` when calling `upload_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folder_id'] = params['folder_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders/{folder_id}/files', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
