# coding: utf-8

"""

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ContentMigrationsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_content_migration_accounts(self, account_id, migration_type, **kwargs):  # noqa: E501
        """Create a content migration  # noqa: E501

        Create a content migration. If the migration requires a file to be uploaded the actual processing of the file will start once the file upload process is completed. File uploading works as described in the {file:file_uploads.html File Upload Documentation} except that the values are set on a *pre_attachment* sub-hash.  For migrations that don't require a file to be uploaded, like course copy, the processing will begin as soon as the migration is created.  You can use the {api:ProgressController#show Progress API} to track the progress of the migration. The migration's progress is linked to with the _progress_url_ value.  The two general workflows are:  If no file upload is needed:  1. POST to create 2. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress  For file uploading:  1. POST to create with file info in *pre_attachment* 2. Do {file:file_uploads.html file upload processing} using the data in the *pre_attachment* data 3. {api:ContentMigrationsController#show GET} the ContentMigration 4. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress   (required if doing .zip file upload)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_content_migration_accounts(account_id, migration_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str migration_type: The type of the migration. Use the {api:ContentMigrationsController#available_migrators Migrator} endpoint to see all available migrators. Default allowed values: canvas_cartridge_importer, common_cartridge_importer, course_copy_importer, zip_file_importer, qti_converter, moodle_converter (required)
        :param str pre_attachment_name: Required if uploading a file. This is the first step in uploading a file to the content migration. See the {file:file_uploads.html File Upload Documentation} for details on the file upload workflow.
        :param str pre_attachment_: Other file upload properties, See {file:file_uploads.html File Upload Documentation}
        :param str settings_file_url: A URL to download the file from. Must not require authentication.
        :param str settings_content_export_id: The id of a ContentExport to import. This allows you to import content previously exported from Canvas without needing to download and re-upload it.
        :param str settings_source_course_id: The course to copy from for a course copy migration. (required if doing course copy)
        :param str settings_folder_id: The folder to unzip the .zip file into for a zip_file_import.
        :param bool settings_overwrite_quizzes: Whether to overwrite quizzes with the same identifiers between content packages.
        :param int settings_question_bank_id: The existing question bank ID to import questions into if not specified in the content package.
        :param str settings_question_bank_name: The question bank to import questions into if not specified in the content package, if both bank id and name are set, id will take precedence.
        :param int settings_insert_into_module_id: The id of a module in the target course. This will add all imported items (that can be added to a module) to the given module.
        :param str settings_insert_into_module_type: If provided (and +insert_into_module_id+ is supplied), only add objects of the specified type to the module.
        :param int settings_insert_into_module_position: The (1-based) position to insert the imported items into the course (if +insert_into_module_id+ is supplied). If this parameter is omitted, items will be added to the end of the module.
        :param int settings_move_to_assignment_group_id: The id of an assignment group in the target course. If provided, all imported assignments will be moved to the given assignment group.
        :param Object settings_importer_skips: Set of importers to skip, even if otherwise selected by migration settings.
        :param bool settings_import_blueprint_settings: Import the \"use as blueprint course\" setting as well as the list of locked items from the source course or package. The destination course must not be associated with an existing blueprint course and cannot have any student or observer enrollments.
        :param bool date_shift_options_shift_dates: Whether to shift dates in the copied course
        :param Object date_shift_options_old_start_date: The original start date of the source content/course
        :param Object date_shift_options_old_end_date: The original end date of the source content/course
        :param Object date_shift_options_new_start_date: The new start date for the content/course
        :param Object date_shift_options_new_end_date: The new end date for the source content/course
        :param int date_shift_options_day_substitutions_x: Move anything scheduled for day 'X' to the specified day. (0-Sunday, 1-Monday, 2-Tuesday, 3-Wednesday, 4-Thursday, 5-Friday, 6-Saturday)
        :param bool date_shift_options_remove_dates: Whether to remove dates in the copied course. Cannot be used in conjunction with *shift_dates*.
        :param bool selective_import: If set, perform a selective import instead of importing all content. The migration will identify the contents of the package and then stop in the +waiting_for_select+ workflow state. At this point, use the {api:ContentMigrationsController#content_list List items endpoint} to enumerate the contents of the package, identifying the copy parameters for the desired content. Then call the {api:ContentMigrationsController#update Update endpoint} and provide these copy parameters to start the import.
        :param Object select: For +course_copy_importer+ migrations, this parameter allows you to select the objects to copy without using the +selective_import+ argument and +waiting_for_select+ state as is required for uploaded imports (though that workflow is also supported for course copy migrations). The keys are object types like 'files', 'folders', 'pages', etc. The value for each key is a list of object ids. An id can be an integer or a string. Multiple object types can be selected in the same call.
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_content_migration_accounts_with_http_info(account_id, migration_type, **kwargs)  # noqa: E501
        else:
            (data) = self.create_content_migration_accounts_with_http_info(account_id, migration_type, **kwargs)  # noqa: E501
            return data

    def create_content_migration_accounts_with_http_info(self, account_id, migration_type, **kwargs):  # noqa: E501
        """Create a content migration  # noqa: E501

        Create a content migration. If the migration requires a file to be uploaded the actual processing of the file will start once the file upload process is completed. File uploading works as described in the {file:file_uploads.html File Upload Documentation} except that the values are set on a *pre_attachment* sub-hash.  For migrations that don't require a file to be uploaded, like course copy, the processing will begin as soon as the migration is created.  You can use the {api:ProgressController#show Progress API} to track the progress of the migration. The migration's progress is linked to with the _progress_url_ value.  The two general workflows are:  If no file upload is needed:  1. POST to create 2. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress  For file uploading:  1. POST to create with file info in *pre_attachment* 2. Do {file:file_uploads.html file upload processing} using the data in the *pre_attachment* data 3. {api:ContentMigrationsController#show GET} the ContentMigration 4. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress   (required if doing .zip file upload)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_content_migration_accounts_with_http_info(account_id, migration_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str migration_type: The type of the migration. Use the {api:ContentMigrationsController#available_migrators Migrator} endpoint to see all available migrators. Default allowed values: canvas_cartridge_importer, common_cartridge_importer, course_copy_importer, zip_file_importer, qti_converter, moodle_converter (required)
        :param str pre_attachment_name: Required if uploading a file. This is the first step in uploading a file to the content migration. See the {file:file_uploads.html File Upload Documentation} for details on the file upload workflow.
        :param str pre_attachment_: Other file upload properties, See {file:file_uploads.html File Upload Documentation}
        :param str settings_file_url: A URL to download the file from. Must not require authentication.
        :param str settings_content_export_id: The id of a ContentExport to import. This allows you to import content previously exported from Canvas without needing to download and re-upload it.
        :param str settings_source_course_id: The course to copy from for a course copy migration. (required if doing course copy)
        :param str settings_folder_id: The folder to unzip the .zip file into for a zip_file_import.
        :param bool settings_overwrite_quizzes: Whether to overwrite quizzes with the same identifiers between content packages.
        :param int settings_question_bank_id: The existing question bank ID to import questions into if not specified in the content package.
        :param str settings_question_bank_name: The question bank to import questions into if not specified in the content package, if both bank id and name are set, id will take precedence.
        :param int settings_insert_into_module_id: The id of a module in the target course. This will add all imported items (that can be added to a module) to the given module.
        :param str settings_insert_into_module_type: If provided (and +insert_into_module_id+ is supplied), only add objects of the specified type to the module.
        :param int settings_insert_into_module_position: The (1-based) position to insert the imported items into the course (if +insert_into_module_id+ is supplied). If this parameter is omitted, items will be added to the end of the module.
        :param int settings_move_to_assignment_group_id: The id of an assignment group in the target course. If provided, all imported assignments will be moved to the given assignment group.
        :param Object settings_importer_skips: Set of importers to skip, even if otherwise selected by migration settings.
        :param bool settings_import_blueprint_settings: Import the \"use as blueprint course\" setting as well as the list of locked items from the source course or package. The destination course must not be associated with an existing blueprint course and cannot have any student or observer enrollments.
        :param bool date_shift_options_shift_dates: Whether to shift dates in the copied course
        :param Object date_shift_options_old_start_date: The original start date of the source content/course
        :param Object date_shift_options_old_end_date: The original end date of the source content/course
        :param Object date_shift_options_new_start_date: The new start date for the content/course
        :param Object date_shift_options_new_end_date: The new end date for the source content/course
        :param int date_shift_options_day_substitutions_x: Move anything scheduled for day 'X' to the specified day. (0-Sunday, 1-Monday, 2-Tuesday, 3-Wednesday, 4-Thursday, 5-Friday, 6-Saturday)
        :param bool date_shift_options_remove_dates: Whether to remove dates in the copied course. Cannot be used in conjunction with *shift_dates*.
        :param bool selective_import: If set, perform a selective import instead of importing all content. The migration will identify the contents of the package and then stop in the +waiting_for_select+ workflow state. At this point, use the {api:ContentMigrationsController#content_list List items endpoint} to enumerate the contents of the package, identifying the copy parameters for the desired content. Then call the {api:ContentMigrationsController#update Update endpoint} and provide these copy parameters to start the import.
        :param Object select: For +course_copy_importer+ migrations, this parameter allows you to select the objects to copy without using the +selective_import+ argument and +waiting_for_select+ state as is required for uploaded imports (though that workflow is also supported for course copy migrations). The keys are object types like 'files', 'folders', 'pages', etc. The value for each key is a list of object ids. An id can be an integer or a string. Multiple object types can be selected in the same call.
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'migration_type', 'pre_attachment_name', 'pre_attachment_', 'settings_file_url', 'settings_content_export_id', 'settings_source_course_id', 'settings_folder_id', 'settings_overwrite_quizzes', 'settings_question_bank_id', 'settings_question_bank_name', 'settings_insert_into_module_id', 'settings_insert_into_module_type', 'settings_insert_into_module_position', 'settings_move_to_assignment_group_id', 'settings_importer_skips', 'settings_import_blueprint_settings', 'date_shift_options_shift_dates', 'date_shift_options_old_start_date', 'date_shift_options_old_end_date', 'date_shift_options_new_start_date', 'date_shift_options_new_end_date', 'date_shift_options_day_substitutions_x', 'date_shift_options_remove_dates', 'selective_import', 'select']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_content_migration_accounts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `create_content_migration_accounts`")  # noqa: E501
        # verify the required parameter 'migration_type' is set
        if self.api_client.client_side_validation and ('migration_type' not in params or
                                                       params['migration_type'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `migration_type` when calling `create_content_migration_accounts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'migration_type' in params:
            form_params.append(('migration_type', params['migration_type']))  # noqa: E501
        if 'pre_attachment_name' in params:
            form_params.append(('pre_attachment[name]', params['pre_attachment_name']))  # noqa: E501
        if 'pre_attachment_' in params:
            form_params.append(('pre_attachment[*]', params['pre_attachment_']))  # noqa: E501
        if 'settings_file_url' in params:
            form_params.append(('settings[file_url]', params['settings_file_url']))  # noqa: E501
        if 'settings_content_export_id' in params:
            form_params.append(('settings[content_export_id]', params['settings_content_export_id']))  # noqa: E501
        if 'settings_source_course_id' in params:
            form_params.append(('settings[source_course_id]', params['settings_source_course_id']))  # noqa: E501
        if 'settings_folder_id' in params:
            form_params.append(('settings[folder_id]', params['settings_folder_id']))  # noqa: E501
        if 'settings_overwrite_quizzes' in params:
            form_params.append(('settings[overwrite_quizzes]', params['settings_overwrite_quizzes']))  # noqa: E501
        if 'settings_question_bank_id' in params:
            form_params.append(('settings[question_bank_id]', params['settings_question_bank_id']))  # noqa: E501
        if 'settings_question_bank_name' in params:
            form_params.append(('settings[question_bank_name]', params['settings_question_bank_name']))  # noqa: E501
        if 'settings_insert_into_module_id' in params:
            form_params.append(('settings[insert_into_module_id]', params['settings_insert_into_module_id']))  # noqa: E501
        if 'settings_insert_into_module_type' in params:
            form_params.append(('settings[insert_into_module_type]', params['settings_insert_into_module_type']))  # noqa: E501
        if 'settings_insert_into_module_position' in params:
            form_params.append(('settings[insert_into_module_position]', params['settings_insert_into_module_position']))  # noqa: E501
        if 'settings_move_to_assignment_group_id' in params:
            form_params.append(('settings[move_to_assignment_group_id]', params['settings_move_to_assignment_group_id']))  # noqa: E501
        if 'settings_importer_skips' in params:
            form_params.append(('settings[importer_skips]', params['settings_importer_skips']))  # noqa: E501
        if 'settings_import_blueprint_settings' in params:
            form_params.append(('settings[import_blueprint_settings]', params['settings_import_blueprint_settings']))  # noqa: E501
        if 'date_shift_options_shift_dates' in params:
            form_params.append(('date_shift_options[shift_dates]', params['date_shift_options_shift_dates']))  # noqa: E501
        if 'date_shift_options_old_start_date' in params:
            form_params.append(('date_shift_options[old_start_date]', params['date_shift_options_old_start_date']))  # noqa: E501
        if 'date_shift_options_old_end_date' in params:
            form_params.append(('date_shift_options[old_end_date]', params['date_shift_options_old_end_date']))  # noqa: E501
        if 'date_shift_options_new_start_date' in params:
            form_params.append(('date_shift_options[new_start_date]', params['date_shift_options_new_start_date']))  # noqa: E501
        if 'date_shift_options_new_end_date' in params:
            form_params.append(('date_shift_options[new_end_date]', params['date_shift_options_new_end_date']))  # noqa: E501
        if 'date_shift_options_day_substitutions_x' in params:
            form_params.append(('date_shift_options[day_substitutions][X]', params['date_shift_options_day_substitutions_x']))  # noqa: E501
        if 'date_shift_options_remove_dates' in params:
            form_params.append(('date_shift_options[remove_dates]', params['date_shift_options_remove_dates']))  # noqa: E501
        if 'selective_import' in params:
            form_params.append(('selective_import', params['selective_import']))  # noqa: E501
        if 'select' in params:
            form_params.append(('select', params['select']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/content_migrations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContentMigration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_content_migration_courses(self, course_id, migration_type, **kwargs):  # noqa: E501
        """Create a content migration  # noqa: E501

        Create a content migration. If the migration requires a file to be uploaded the actual processing of the file will start once the file upload process is completed. File uploading works as described in the {file:file_uploads.html File Upload Documentation} except that the values are set on a *pre_attachment* sub-hash.  For migrations that don't require a file to be uploaded, like course copy, the processing will begin as soon as the migration is created.  You can use the {api:ProgressController#show Progress API} to track the progress of the migration. The migration's progress is linked to with the _progress_url_ value.  The two general workflows are:  If no file upload is needed:  1. POST to create 2. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress  For file uploading:  1. POST to create with file info in *pre_attachment* 2. Do {file:file_uploads.html file upload processing} using the data in the *pre_attachment* data 3. {api:ContentMigrationsController#show GET} the ContentMigration 4. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress   (required if doing .zip file upload)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_content_migration_courses(course_id, migration_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str migration_type: The type of the migration. Use the {api:ContentMigrationsController#available_migrators Migrator} endpoint to see all available migrators. Default allowed values: canvas_cartridge_importer, common_cartridge_importer, course_copy_importer, zip_file_importer, qti_converter, moodle_converter (required)
        :param str pre_attachment_name: Required if uploading a file. This is the first step in uploading a file to the content migration. See the {file:file_uploads.html File Upload Documentation} for details on the file upload workflow.
        :param str pre_attachment_: Other file upload properties, See {file:file_uploads.html File Upload Documentation}
        :param str settings_file_url: A URL to download the file from. Must not require authentication.
        :param str settings_content_export_id: The id of a ContentExport to import. This allows you to import content previously exported from Canvas without needing to download and re-upload it.
        :param str settings_source_course_id: The course to copy from for a course copy migration. (required if doing course copy)
        :param str settings_folder_id: The folder to unzip the .zip file into for a zip_file_import.
        :param bool settings_overwrite_quizzes: Whether to overwrite quizzes with the same identifiers between content packages.
        :param int settings_question_bank_id: The existing question bank ID to import questions into if not specified in the content package.
        :param str settings_question_bank_name: The question bank to import questions into if not specified in the content package, if both bank id and name are set, id will take precedence.
        :param int settings_insert_into_module_id: The id of a module in the target course. This will add all imported items (that can be added to a module) to the given module.
        :param str settings_insert_into_module_type: If provided (and +insert_into_module_id+ is supplied), only add objects of the specified type to the module.
        :param int settings_insert_into_module_position: The (1-based) position to insert the imported items into the course (if +insert_into_module_id+ is supplied). If this parameter is omitted, items will be added to the end of the module.
        :param int settings_move_to_assignment_group_id: The id of an assignment group in the target course. If provided, all imported assignments will be moved to the given assignment group.
        :param Object settings_importer_skips: Set of importers to skip, even if otherwise selected by migration settings.
        :param bool settings_import_blueprint_settings: Import the \"use as blueprint course\" setting as well as the list of locked items from the source course or package. The destination course must not be associated with an existing blueprint course and cannot have any student or observer enrollments.
        :param bool date_shift_options_shift_dates: Whether to shift dates in the copied course
        :param Object date_shift_options_old_start_date: The original start date of the source content/course
        :param Object date_shift_options_old_end_date: The original end date of the source content/course
        :param Object date_shift_options_new_start_date: The new start date for the content/course
        :param Object date_shift_options_new_end_date: The new end date for the source content/course
        :param int date_shift_options_day_substitutions_x: Move anything scheduled for day 'X' to the specified day. (0-Sunday, 1-Monday, 2-Tuesday, 3-Wednesday, 4-Thursday, 5-Friday, 6-Saturday)
        :param bool date_shift_options_remove_dates: Whether to remove dates in the copied course. Cannot be used in conjunction with *shift_dates*.
        :param bool selective_import: If set, perform a selective import instead of importing all content. The migration will identify the contents of the package and then stop in the +waiting_for_select+ workflow state. At this point, use the {api:ContentMigrationsController#content_list List items endpoint} to enumerate the contents of the package, identifying the copy parameters for the desired content. Then call the {api:ContentMigrationsController#update Update endpoint} and provide these copy parameters to start the import.
        :param Object select: For +course_copy_importer+ migrations, this parameter allows you to select the objects to copy without using the +selective_import+ argument and +waiting_for_select+ state as is required for uploaded imports (though that workflow is also supported for course copy migrations). The keys are object types like 'files', 'folders', 'pages', etc. The value for each key is a list of object ids. An id can be an integer or a string. Multiple object types can be selected in the same call.
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_content_migration_courses_with_http_info(course_id, migration_type, **kwargs)  # noqa: E501
        else:
            (data) = self.create_content_migration_courses_with_http_info(course_id, migration_type, **kwargs)  # noqa: E501
            return data

    def create_content_migration_courses_with_http_info(self, course_id, migration_type, **kwargs):  # noqa: E501
        """Create a content migration  # noqa: E501

        Create a content migration. If the migration requires a file to be uploaded the actual processing of the file will start once the file upload process is completed. File uploading works as described in the {file:file_uploads.html File Upload Documentation} except that the values are set on a *pre_attachment* sub-hash.  For migrations that don't require a file to be uploaded, like course copy, the processing will begin as soon as the migration is created.  You can use the {api:ProgressController#show Progress API} to track the progress of the migration. The migration's progress is linked to with the _progress_url_ value.  The two general workflows are:  If no file upload is needed:  1. POST to create 2. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress  For file uploading:  1. POST to create with file info in *pre_attachment* 2. Do {file:file_uploads.html file upload processing} using the data in the *pre_attachment* data 3. {api:ContentMigrationsController#show GET} the ContentMigration 4. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress   (required if doing .zip file upload)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_content_migration_courses_with_http_info(course_id, migration_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str migration_type: The type of the migration. Use the {api:ContentMigrationsController#available_migrators Migrator} endpoint to see all available migrators. Default allowed values: canvas_cartridge_importer, common_cartridge_importer, course_copy_importer, zip_file_importer, qti_converter, moodle_converter (required)
        :param str pre_attachment_name: Required if uploading a file. This is the first step in uploading a file to the content migration. See the {file:file_uploads.html File Upload Documentation} for details on the file upload workflow.
        :param str pre_attachment_: Other file upload properties, See {file:file_uploads.html File Upload Documentation}
        :param str settings_file_url: A URL to download the file from. Must not require authentication.
        :param str settings_content_export_id: The id of a ContentExport to import. This allows you to import content previously exported from Canvas without needing to download and re-upload it.
        :param str settings_source_course_id: The course to copy from for a course copy migration. (required if doing course copy)
        :param str settings_folder_id: The folder to unzip the .zip file into for a zip_file_import.
        :param bool settings_overwrite_quizzes: Whether to overwrite quizzes with the same identifiers between content packages.
        :param int settings_question_bank_id: The existing question bank ID to import questions into if not specified in the content package.
        :param str settings_question_bank_name: The question bank to import questions into if not specified in the content package, if both bank id and name are set, id will take precedence.
        :param int settings_insert_into_module_id: The id of a module in the target course. This will add all imported items (that can be added to a module) to the given module.
        :param str settings_insert_into_module_type: If provided (and +insert_into_module_id+ is supplied), only add objects of the specified type to the module.
        :param int settings_insert_into_module_position: The (1-based) position to insert the imported items into the course (if +insert_into_module_id+ is supplied). If this parameter is omitted, items will be added to the end of the module.
        :param int settings_move_to_assignment_group_id: The id of an assignment group in the target course. If provided, all imported assignments will be moved to the given assignment group.
        :param Object settings_importer_skips: Set of importers to skip, even if otherwise selected by migration settings.
        :param bool settings_import_blueprint_settings: Import the \"use as blueprint course\" setting as well as the list of locked items from the source course or package. The destination course must not be associated with an existing blueprint course and cannot have any student or observer enrollments.
        :param bool date_shift_options_shift_dates: Whether to shift dates in the copied course
        :param Object date_shift_options_old_start_date: The original start date of the source content/course
        :param Object date_shift_options_old_end_date: The original end date of the source content/course
        :param Object date_shift_options_new_start_date: The new start date for the content/course
        :param Object date_shift_options_new_end_date: The new end date for the source content/course
        :param int date_shift_options_day_substitutions_x: Move anything scheduled for day 'X' to the specified day. (0-Sunday, 1-Monday, 2-Tuesday, 3-Wednesday, 4-Thursday, 5-Friday, 6-Saturday)
        :param bool date_shift_options_remove_dates: Whether to remove dates in the copied course. Cannot be used in conjunction with *shift_dates*.
        :param bool selective_import: If set, perform a selective import instead of importing all content. The migration will identify the contents of the package and then stop in the +waiting_for_select+ workflow state. At this point, use the {api:ContentMigrationsController#content_list List items endpoint} to enumerate the contents of the package, identifying the copy parameters for the desired content. Then call the {api:ContentMigrationsController#update Update endpoint} and provide these copy parameters to start the import.
        :param Object select: For +course_copy_importer+ migrations, this parameter allows you to select the objects to copy without using the +selective_import+ argument and +waiting_for_select+ state as is required for uploaded imports (though that workflow is also supported for course copy migrations). The keys are object types like 'files', 'folders', 'pages', etc. The value for each key is a list of object ids. An id can be an integer or a string. Multiple object types can be selected in the same call.
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'migration_type', 'pre_attachment_name', 'pre_attachment_', 'settings_file_url', 'settings_content_export_id', 'settings_source_course_id', 'settings_folder_id', 'settings_overwrite_quizzes', 'settings_question_bank_id', 'settings_question_bank_name', 'settings_insert_into_module_id', 'settings_insert_into_module_type', 'settings_insert_into_module_position', 'settings_move_to_assignment_group_id', 'settings_importer_skips', 'settings_import_blueprint_settings', 'date_shift_options_shift_dates', 'date_shift_options_old_start_date', 'date_shift_options_old_end_date', 'date_shift_options_new_start_date', 'date_shift_options_new_end_date', 'date_shift_options_day_substitutions_x', 'date_shift_options_remove_dates', 'selective_import', 'select']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_content_migration_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `create_content_migration_courses`")  # noqa: E501
        # verify the required parameter 'migration_type' is set
        if self.api_client.client_side_validation and ('migration_type' not in params or
                                                       params['migration_type'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `migration_type` when calling `create_content_migration_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'migration_type' in params:
            form_params.append(('migration_type', params['migration_type']))  # noqa: E501
        if 'pre_attachment_name' in params:
            form_params.append(('pre_attachment[name]', params['pre_attachment_name']))  # noqa: E501
        if 'pre_attachment_' in params:
            form_params.append(('pre_attachment[*]', params['pre_attachment_']))  # noqa: E501
        if 'settings_file_url' in params:
            form_params.append(('settings[file_url]', params['settings_file_url']))  # noqa: E501
        if 'settings_content_export_id' in params:
            form_params.append(('settings[content_export_id]', params['settings_content_export_id']))  # noqa: E501
        if 'settings_source_course_id' in params:
            form_params.append(('settings[source_course_id]', params['settings_source_course_id']))  # noqa: E501
        if 'settings_folder_id' in params:
            form_params.append(('settings[folder_id]', params['settings_folder_id']))  # noqa: E501
        if 'settings_overwrite_quizzes' in params:
            form_params.append(('settings[overwrite_quizzes]', params['settings_overwrite_quizzes']))  # noqa: E501
        if 'settings_question_bank_id' in params:
            form_params.append(('settings[question_bank_id]', params['settings_question_bank_id']))  # noqa: E501
        if 'settings_question_bank_name' in params:
            form_params.append(('settings[question_bank_name]', params['settings_question_bank_name']))  # noqa: E501
        if 'settings_insert_into_module_id' in params:
            form_params.append(('settings[insert_into_module_id]', params['settings_insert_into_module_id']))  # noqa: E501
        if 'settings_insert_into_module_type' in params:
            form_params.append(('settings[insert_into_module_type]', params['settings_insert_into_module_type']))  # noqa: E501
        if 'settings_insert_into_module_position' in params:
            form_params.append(('settings[insert_into_module_position]', params['settings_insert_into_module_position']))  # noqa: E501
        if 'settings_move_to_assignment_group_id' in params:
            form_params.append(('settings[move_to_assignment_group_id]', params['settings_move_to_assignment_group_id']))  # noqa: E501
        if 'settings_importer_skips' in params:
            form_params.append(('settings[importer_skips]', params['settings_importer_skips']))  # noqa: E501
        if 'settings_import_blueprint_settings' in params:
            form_params.append(('settings[import_blueprint_settings]', params['settings_import_blueprint_settings']))  # noqa: E501
        if 'date_shift_options_shift_dates' in params:
            form_params.append(('date_shift_options[shift_dates]', params['date_shift_options_shift_dates']))  # noqa: E501
        if 'date_shift_options_old_start_date' in params:
            form_params.append(('date_shift_options[old_start_date]', params['date_shift_options_old_start_date']))  # noqa: E501
        if 'date_shift_options_old_end_date' in params:
            form_params.append(('date_shift_options[old_end_date]', params['date_shift_options_old_end_date']))  # noqa: E501
        if 'date_shift_options_new_start_date' in params:
            form_params.append(('date_shift_options[new_start_date]', params['date_shift_options_new_start_date']))  # noqa: E501
        if 'date_shift_options_new_end_date' in params:
            form_params.append(('date_shift_options[new_end_date]', params['date_shift_options_new_end_date']))  # noqa: E501
        if 'date_shift_options_day_substitutions_x' in params:
            form_params.append(('date_shift_options[day_substitutions][X]', params['date_shift_options_day_substitutions_x']))  # noqa: E501
        if 'date_shift_options_remove_dates' in params:
            form_params.append(('date_shift_options[remove_dates]', params['date_shift_options_remove_dates']))  # noqa: E501
        if 'selective_import' in params:
            form_params.append(('selective_import', params['selective_import']))  # noqa: E501
        if 'select' in params:
            form_params.append(('select', params['select']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/content_migrations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContentMigration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_content_migration_groups(self, group_id, migration_type, **kwargs):  # noqa: E501
        """Create a content migration  # noqa: E501

        Create a content migration. If the migration requires a file to be uploaded the actual processing of the file will start once the file upload process is completed. File uploading works as described in the {file:file_uploads.html File Upload Documentation} except that the values are set on a *pre_attachment* sub-hash.  For migrations that don't require a file to be uploaded, like course copy, the processing will begin as soon as the migration is created.  You can use the {api:ProgressController#show Progress API} to track the progress of the migration. The migration's progress is linked to with the _progress_url_ value.  The two general workflows are:  If no file upload is needed:  1. POST to create 2. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress  For file uploading:  1. POST to create with file info in *pre_attachment* 2. Do {file:file_uploads.html file upload processing} using the data in the *pre_attachment* data 3. {api:ContentMigrationsController#show GET} the ContentMigration 4. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress   (required if doing .zip file upload)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_content_migration_groups(group_id, migration_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str migration_type: The type of the migration. Use the {api:ContentMigrationsController#available_migrators Migrator} endpoint to see all available migrators. Default allowed values: canvas_cartridge_importer, common_cartridge_importer, course_copy_importer, zip_file_importer, qti_converter, moodle_converter (required)
        :param str pre_attachment_name: Required if uploading a file. This is the first step in uploading a file to the content migration. See the {file:file_uploads.html File Upload Documentation} for details on the file upload workflow.
        :param str pre_attachment_: Other file upload properties, See {file:file_uploads.html File Upload Documentation}
        :param str settings_file_url: A URL to download the file from. Must not require authentication.
        :param str settings_content_export_id: The id of a ContentExport to import. This allows you to import content previously exported from Canvas without needing to download and re-upload it.
        :param str settings_source_course_id: The course to copy from for a course copy migration. (required if doing course copy)
        :param str settings_folder_id: The folder to unzip the .zip file into for a zip_file_import.
        :param bool settings_overwrite_quizzes: Whether to overwrite quizzes with the same identifiers between content packages.
        :param int settings_question_bank_id: The existing question bank ID to import questions into if not specified in the content package.
        :param str settings_question_bank_name: The question bank to import questions into if not specified in the content package, if both bank id and name are set, id will take precedence.
        :param int settings_insert_into_module_id: The id of a module in the target course. This will add all imported items (that can be added to a module) to the given module.
        :param str settings_insert_into_module_type: If provided (and +insert_into_module_id+ is supplied), only add objects of the specified type to the module.
        :param int settings_insert_into_module_position: The (1-based) position to insert the imported items into the course (if +insert_into_module_id+ is supplied). If this parameter is omitted, items will be added to the end of the module.
        :param int settings_move_to_assignment_group_id: The id of an assignment group in the target course. If provided, all imported assignments will be moved to the given assignment group.
        :param Object settings_importer_skips: Set of importers to skip, even if otherwise selected by migration settings.
        :param bool settings_import_blueprint_settings: Import the \"use as blueprint course\" setting as well as the list of locked items from the source course or package. The destination course must not be associated with an existing blueprint course and cannot have any student or observer enrollments.
        :param bool date_shift_options_shift_dates: Whether to shift dates in the copied course
        :param Object date_shift_options_old_start_date: The original start date of the source content/course
        :param Object date_shift_options_old_end_date: The original end date of the source content/course
        :param Object date_shift_options_new_start_date: The new start date for the content/course
        :param Object date_shift_options_new_end_date: The new end date for the source content/course
        :param int date_shift_options_day_substitutions_x: Move anything scheduled for day 'X' to the specified day. (0-Sunday, 1-Monday, 2-Tuesday, 3-Wednesday, 4-Thursday, 5-Friday, 6-Saturday)
        :param bool date_shift_options_remove_dates: Whether to remove dates in the copied course. Cannot be used in conjunction with *shift_dates*.
        :param bool selective_import: If set, perform a selective import instead of importing all content. The migration will identify the contents of the package and then stop in the +waiting_for_select+ workflow state. At this point, use the {api:ContentMigrationsController#content_list List items endpoint} to enumerate the contents of the package, identifying the copy parameters for the desired content. Then call the {api:ContentMigrationsController#update Update endpoint} and provide these copy parameters to start the import.
        :param Object select: For +course_copy_importer+ migrations, this parameter allows you to select the objects to copy without using the +selective_import+ argument and +waiting_for_select+ state as is required for uploaded imports (though that workflow is also supported for course copy migrations). The keys are object types like 'files', 'folders', 'pages', etc. The value for each key is a list of object ids. An id can be an integer or a string. Multiple object types can be selected in the same call.
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_content_migration_groups_with_http_info(group_id, migration_type, **kwargs)  # noqa: E501
        else:
            (data) = self.create_content_migration_groups_with_http_info(group_id, migration_type, **kwargs)  # noqa: E501
            return data

    def create_content_migration_groups_with_http_info(self, group_id, migration_type, **kwargs):  # noqa: E501
        """Create a content migration  # noqa: E501

        Create a content migration. If the migration requires a file to be uploaded the actual processing of the file will start once the file upload process is completed. File uploading works as described in the {file:file_uploads.html File Upload Documentation} except that the values are set on a *pre_attachment* sub-hash.  For migrations that don't require a file to be uploaded, like course copy, the processing will begin as soon as the migration is created.  You can use the {api:ProgressController#show Progress API} to track the progress of the migration. The migration's progress is linked to with the _progress_url_ value.  The two general workflows are:  If no file upload is needed:  1. POST to create 2. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress  For file uploading:  1. POST to create with file info in *pre_attachment* 2. Do {file:file_uploads.html file upload processing} using the data in the *pre_attachment* data 3. {api:ContentMigrationsController#show GET} the ContentMigration 4. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress   (required if doing .zip file upload)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_content_migration_groups_with_http_info(group_id, migration_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str migration_type: The type of the migration. Use the {api:ContentMigrationsController#available_migrators Migrator} endpoint to see all available migrators. Default allowed values: canvas_cartridge_importer, common_cartridge_importer, course_copy_importer, zip_file_importer, qti_converter, moodle_converter (required)
        :param str pre_attachment_name: Required if uploading a file. This is the first step in uploading a file to the content migration. See the {file:file_uploads.html File Upload Documentation} for details on the file upload workflow.
        :param str pre_attachment_: Other file upload properties, See {file:file_uploads.html File Upload Documentation}
        :param str settings_file_url: A URL to download the file from. Must not require authentication.
        :param str settings_content_export_id: The id of a ContentExport to import. This allows you to import content previously exported from Canvas without needing to download and re-upload it.
        :param str settings_source_course_id: The course to copy from for a course copy migration. (required if doing course copy)
        :param str settings_folder_id: The folder to unzip the .zip file into for a zip_file_import.
        :param bool settings_overwrite_quizzes: Whether to overwrite quizzes with the same identifiers between content packages.
        :param int settings_question_bank_id: The existing question bank ID to import questions into if not specified in the content package.
        :param str settings_question_bank_name: The question bank to import questions into if not specified in the content package, if both bank id and name are set, id will take precedence.
        :param int settings_insert_into_module_id: The id of a module in the target course. This will add all imported items (that can be added to a module) to the given module.
        :param str settings_insert_into_module_type: If provided (and +insert_into_module_id+ is supplied), only add objects of the specified type to the module.
        :param int settings_insert_into_module_position: The (1-based) position to insert the imported items into the course (if +insert_into_module_id+ is supplied). If this parameter is omitted, items will be added to the end of the module.
        :param int settings_move_to_assignment_group_id: The id of an assignment group in the target course. If provided, all imported assignments will be moved to the given assignment group.
        :param Object settings_importer_skips: Set of importers to skip, even if otherwise selected by migration settings.
        :param bool settings_import_blueprint_settings: Import the \"use as blueprint course\" setting as well as the list of locked items from the source course or package. The destination course must not be associated with an existing blueprint course and cannot have any student or observer enrollments.
        :param bool date_shift_options_shift_dates: Whether to shift dates in the copied course
        :param Object date_shift_options_old_start_date: The original start date of the source content/course
        :param Object date_shift_options_old_end_date: The original end date of the source content/course
        :param Object date_shift_options_new_start_date: The new start date for the content/course
        :param Object date_shift_options_new_end_date: The new end date for the source content/course
        :param int date_shift_options_day_substitutions_x: Move anything scheduled for day 'X' to the specified day. (0-Sunday, 1-Monday, 2-Tuesday, 3-Wednesday, 4-Thursday, 5-Friday, 6-Saturday)
        :param bool date_shift_options_remove_dates: Whether to remove dates in the copied course. Cannot be used in conjunction with *shift_dates*.
        :param bool selective_import: If set, perform a selective import instead of importing all content. The migration will identify the contents of the package and then stop in the +waiting_for_select+ workflow state. At this point, use the {api:ContentMigrationsController#content_list List items endpoint} to enumerate the contents of the package, identifying the copy parameters for the desired content. Then call the {api:ContentMigrationsController#update Update endpoint} and provide these copy parameters to start the import.
        :param Object select: For +course_copy_importer+ migrations, this parameter allows you to select the objects to copy without using the +selective_import+ argument and +waiting_for_select+ state as is required for uploaded imports (though that workflow is also supported for course copy migrations). The keys are object types like 'files', 'folders', 'pages', etc. The value for each key is a list of object ids. An id can be an integer or a string. Multiple object types can be selected in the same call.
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'migration_type', 'pre_attachment_name', 'pre_attachment_', 'settings_file_url', 'settings_content_export_id', 'settings_source_course_id', 'settings_folder_id', 'settings_overwrite_quizzes', 'settings_question_bank_id', 'settings_question_bank_name', 'settings_insert_into_module_id', 'settings_insert_into_module_type', 'settings_insert_into_module_position', 'settings_move_to_assignment_group_id', 'settings_importer_skips', 'settings_import_blueprint_settings', 'date_shift_options_shift_dates', 'date_shift_options_old_start_date', 'date_shift_options_old_end_date', 'date_shift_options_new_start_date', 'date_shift_options_new_end_date', 'date_shift_options_day_substitutions_x', 'date_shift_options_remove_dates', 'selective_import', 'select']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_content_migration_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `create_content_migration_groups`")  # noqa: E501
        # verify the required parameter 'migration_type' is set
        if self.api_client.client_side_validation and ('migration_type' not in params or
                                                       params['migration_type'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `migration_type` when calling `create_content_migration_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'migration_type' in params:
            form_params.append(('migration_type', params['migration_type']))  # noqa: E501
        if 'pre_attachment_name' in params:
            form_params.append(('pre_attachment[name]', params['pre_attachment_name']))  # noqa: E501
        if 'pre_attachment_' in params:
            form_params.append(('pre_attachment[*]', params['pre_attachment_']))  # noqa: E501
        if 'settings_file_url' in params:
            form_params.append(('settings[file_url]', params['settings_file_url']))  # noqa: E501
        if 'settings_content_export_id' in params:
            form_params.append(('settings[content_export_id]', params['settings_content_export_id']))  # noqa: E501
        if 'settings_source_course_id' in params:
            form_params.append(('settings[source_course_id]', params['settings_source_course_id']))  # noqa: E501
        if 'settings_folder_id' in params:
            form_params.append(('settings[folder_id]', params['settings_folder_id']))  # noqa: E501
        if 'settings_overwrite_quizzes' in params:
            form_params.append(('settings[overwrite_quizzes]', params['settings_overwrite_quizzes']))  # noqa: E501
        if 'settings_question_bank_id' in params:
            form_params.append(('settings[question_bank_id]', params['settings_question_bank_id']))  # noqa: E501
        if 'settings_question_bank_name' in params:
            form_params.append(('settings[question_bank_name]', params['settings_question_bank_name']))  # noqa: E501
        if 'settings_insert_into_module_id' in params:
            form_params.append(('settings[insert_into_module_id]', params['settings_insert_into_module_id']))  # noqa: E501
        if 'settings_insert_into_module_type' in params:
            form_params.append(('settings[insert_into_module_type]', params['settings_insert_into_module_type']))  # noqa: E501
        if 'settings_insert_into_module_position' in params:
            form_params.append(('settings[insert_into_module_position]', params['settings_insert_into_module_position']))  # noqa: E501
        if 'settings_move_to_assignment_group_id' in params:
            form_params.append(('settings[move_to_assignment_group_id]', params['settings_move_to_assignment_group_id']))  # noqa: E501
        if 'settings_importer_skips' in params:
            form_params.append(('settings[importer_skips]', params['settings_importer_skips']))  # noqa: E501
        if 'settings_import_blueprint_settings' in params:
            form_params.append(('settings[import_blueprint_settings]', params['settings_import_blueprint_settings']))  # noqa: E501
        if 'date_shift_options_shift_dates' in params:
            form_params.append(('date_shift_options[shift_dates]', params['date_shift_options_shift_dates']))  # noqa: E501
        if 'date_shift_options_old_start_date' in params:
            form_params.append(('date_shift_options[old_start_date]', params['date_shift_options_old_start_date']))  # noqa: E501
        if 'date_shift_options_old_end_date' in params:
            form_params.append(('date_shift_options[old_end_date]', params['date_shift_options_old_end_date']))  # noqa: E501
        if 'date_shift_options_new_start_date' in params:
            form_params.append(('date_shift_options[new_start_date]', params['date_shift_options_new_start_date']))  # noqa: E501
        if 'date_shift_options_new_end_date' in params:
            form_params.append(('date_shift_options[new_end_date]', params['date_shift_options_new_end_date']))  # noqa: E501
        if 'date_shift_options_day_substitutions_x' in params:
            form_params.append(('date_shift_options[day_substitutions][X]', params['date_shift_options_day_substitutions_x']))  # noqa: E501
        if 'date_shift_options_remove_dates' in params:
            form_params.append(('date_shift_options[remove_dates]', params['date_shift_options_remove_dates']))  # noqa: E501
        if 'selective_import' in params:
            form_params.append(('selective_import', params['selective_import']))  # noqa: E501
        if 'select' in params:
            form_params.append(('select', params['select']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/content_migrations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContentMigration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_content_migration_users(self, user_id, migration_type, **kwargs):  # noqa: E501
        """Create a content migration  # noqa: E501

        Create a content migration. If the migration requires a file to be uploaded the actual processing of the file will start once the file upload process is completed. File uploading works as described in the {file:file_uploads.html File Upload Documentation} except that the values are set on a *pre_attachment* sub-hash.  For migrations that don't require a file to be uploaded, like course copy, the processing will begin as soon as the migration is created.  You can use the {api:ProgressController#show Progress API} to track the progress of the migration. The migration's progress is linked to with the _progress_url_ value.  The two general workflows are:  If no file upload is needed:  1. POST to create 2. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress  For file uploading:  1. POST to create with file info in *pre_attachment* 2. Do {file:file_uploads.html file upload processing} using the data in the *pre_attachment* data 3. {api:ContentMigrationsController#show GET} the ContentMigration 4. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress   (required if doing .zip file upload)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_content_migration_users(user_id, migration_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str migration_type: The type of the migration. Use the {api:ContentMigrationsController#available_migrators Migrator} endpoint to see all available migrators. Default allowed values: canvas_cartridge_importer, common_cartridge_importer, course_copy_importer, zip_file_importer, qti_converter, moodle_converter (required)
        :param str pre_attachment_name: Required if uploading a file. This is the first step in uploading a file to the content migration. See the {file:file_uploads.html File Upload Documentation} for details on the file upload workflow.
        :param str pre_attachment_: Other file upload properties, See {file:file_uploads.html File Upload Documentation}
        :param str settings_file_url: A URL to download the file from. Must not require authentication.
        :param str settings_content_export_id: The id of a ContentExport to import. This allows you to import content previously exported from Canvas without needing to download and re-upload it.
        :param str settings_source_course_id: The course to copy from for a course copy migration. (required if doing course copy)
        :param str settings_folder_id: The folder to unzip the .zip file into for a zip_file_import.
        :param bool settings_overwrite_quizzes: Whether to overwrite quizzes with the same identifiers between content packages.
        :param int settings_question_bank_id: The existing question bank ID to import questions into if not specified in the content package.
        :param str settings_question_bank_name: The question bank to import questions into if not specified in the content package, if both bank id and name are set, id will take precedence.
        :param int settings_insert_into_module_id: The id of a module in the target course. This will add all imported items (that can be added to a module) to the given module.
        :param str settings_insert_into_module_type: If provided (and +insert_into_module_id+ is supplied), only add objects of the specified type to the module.
        :param int settings_insert_into_module_position: The (1-based) position to insert the imported items into the course (if +insert_into_module_id+ is supplied). If this parameter is omitted, items will be added to the end of the module.
        :param int settings_move_to_assignment_group_id: The id of an assignment group in the target course. If provided, all imported assignments will be moved to the given assignment group.
        :param Object settings_importer_skips: Set of importers to skip, even if otherwise selected by migration settings.
        :param bool settings_import_blueprint_settings: Import the \"use as blueprint course\" setting as well as the list of locked items from the source course or package. The destination course must not be associated with an existing blueprint course and cannot have any student or observer enrollments.
        :param bool date_shift_options_shift_dates: Whether to shift dates in the copied course
        :param Object date_shift_options_old_start_date: The original start date of the source content/course
        :param Object date_shift_options_old_end_date: The original end date of the source content/course
        :param Object date_shift_options_new_start_date: The new start date for the content/course
        :param Object date_shift_options_new_end_date: The new end date for the source content/course
        :param int date_shift_options_day_substitutions_x: Move anything scheduled for day 'X' to the specified day. (0-Sunday, 1-Monday, 2-Tuesday, 3-Wednesday, 4-Thursday, 5-Friday, 6-Saturday)
        :param bool date_shift_options_remove_dates: Whether to remove dates in the copied course. Cannot be used in conjunction with *shift_dates*.
        :param bool selective_import: If set, perform a selective import instead of importing all content. The migration will identify the contents of the package and then stop in the +waiting_for_select+ workflow state. At this point, use the {api:ContentMigrationsController#content_list List items endpoint} to enumerate the contents of the package, identifying the copy parameters for the desired content. Then call the {api:ContentMigrationsController#update Update endpoint} and provide these copy parameters to start the import.
        :param Object select: For +course_copy_importer+ migrations, this parameter allows you to select the objects to copy without using the +selective_import+ argument and +waiting_for_select+ state as is required for uploaded imports (though that workflow is also supported for course copy migrations). The keys are object types like 'files', 'folders', 'pages', etc. The value for each key is a list of object ids. An id can be an integer or a string. Multiple object types can be selected in the same call.
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_content_migration_users_with_http_info(user_id, migration_type, **kwargs)  # noqa: E501
        else:
            (data) = self.create_content_migration_users_with_http_info(user_id, migration_type, **kwargs)  # noqa: E501
            return data

    def create_content_migration_users_with_http_info(self, user_id, migration_type, **kwargs):  # noqa: E501
        """Create a content migration  # noqa: E501

        Create a content migration. If the migration requires a file to be uploaded the actual processing of the file will start once the file upload process is completed. File uploading works as described in the {file:file_uploads.html File Upload Documentation} except that the values are set on a *pre_attachment* sub-hash.  For migrations that don't require a file to be uploaded, like course copy, the processing will begin as soon as the migration is created.  You can use the {api:ProgressController#show Progress API} to track the progress of the migration. The migration's progress is linked to with the _progress_url_ value.  The two general workflows are:  If no file upload is needed:  1. POST to create 2. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress  For file uploading:  1. POST to create with file info in *pre_attachment* 2. Do {file:file_uploads.html file upload processing} using the data in the *pre_attachment* data 3. {api:ContentMigrationsController#show GET} the ContentMigration 4. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress   (required if doing .zip file upload)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_content_migration_users_with_http_info(user_id, migration_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str migration_type: The type of the migration. Use the {api:ContentMigrationsController#available_migrators Migrator} endpoint to see all available migrators. Default allowed values: canvas_cartridge_importer, common_cartridge_importer, course_copy_importer, zip_file_importer, qti_converter, moodle_converter (required)
        :param str pre_attachment_name: Required if uploading a file. This is the first step in uploading a file to the content migration. See the {file:file_uploads.html File Upload Documentation} for details on the file upload workflow.
        :param str pre_attachment_: Other file upload properties, See {file:file_uploads.html File Upload Documentation}
        :param str settings_file_url: A URL to download the file from. Must not require authentication.
        :param str settings_content_export_id: The id of a ContentExport to import. This allows you to import content previously exported from Canvas without needing to download and re-upload it.
        :param str settings_source_course_id: The course to copy from for a course copy migration. (required if doing course copy)
        :param str settings_folder_id: The folder to unzip the .zip file into for a zip_file_import.
        :param bool settings_overwrite_quizzes: Whether to overwrite quizzes with the same identifiers between content packages.
        :param int settings_question_bank_id: The existing question bank ID to import questions into if not specified in the content package.
        :param str settings_question_bank_name: The question bank to import questions into if not specified in the content package, if both bank id and name are set, id will take precedence.
        :param int settings_insert_into_module_id: The id of a module in the target course. This will add all imported items (that can be added to a module) to the given module.
        :param str settings_insert_into_module_type: If provided (and +insert_into_module_id+ is supplied), only add objects of the specified type to the module.
        :param int settings_insert_into_module_position: The (1-based) position to insert the imported items into the course (if +insert_into_module_id+ is supplied). If this parameter is omitted, items will be added to the end of the module.
        :param int settings_move_to_assignment_group_id: The id of an assignment group in the target course. If provided, all imported assignments will be moved to the given assignment group.
        :param Object settings_importer_skips: Set of importers to skip, even if otherwise selected by migration settings.
        :param bool settings_import_blueprint_settings: Import the \"use as blueprint course\" setting as well as the list of locked items from the source course or package. The destination course must not be associated with an existing blueprint course and cannot have any student or observer enrollments.
        :param bool date_shift_options_shift_dates: Whether to shift dates in the copied course
        :param Object date_shift_options_old_start_date: The original start date of the source content/course
        :param Object date_shift_options_old_end_date: The original end date of the source content/course
        :param Object date_shift_options_new_start_date: The new start date for the content/course
        :param Object date_shift_options_new_end_date: The new end date for the source content/course
        :param int date_shift_options_day_substitutions_x: Move anything scheduled for day 'X' to the specified day. (0-Sunday, 1-Monday, 2-Tuesday, 3-Wednesday, 4-Thursday, 5-Friday, 6-Saturday)
        :param bool date_shift_options_remove_dates: Whether to remove dates in the copied course. Cannot be used in conjunction with *shift_dates*.
        :param bool selective_import: If set, perform a selective import instead of importing all content. The migration will identify the contents of the package and then stop in the +waiting_for_select+ workflow state. At this point, use the {api:ContentMigrationsController#content_list List items endpoint} to enumerate the contents of the package, identifying the copy parameters for the desired content. Then call the {api:ContentMigrationsController#update Update endpoint} and provide these copy parameters to start the import.
        :param Object select: For +course_copy_importer+ migrations, this parameter allows you to select the objects to copy without using the +selective_import+ argument and +waiting_for_select+ state as is required for uploaded imports (though that workflow is also supported for course copy migrations). The keys are object types like 'files', 'folders', 'pages', etc. The value for each key is a list of object ids. An id can be an integer or a string. Multiple object types can be selected in the same call.
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'migration_type', 'pre_attachment_name', 'pre_attachment_', 'settings_file_url', 'settings_content_export_id', 'settings_source_course_id', 'settings_folder_id', 'settings_overwrite_quizzes', 'settings_question_bank_id', 'settings_question_bank_name', 'settings_insert_into_module_id', 'settings_insert_into_module_type', 'settings_insert_into_module_position', 'settings_move_to_assignment_group_id', 'settings_importer_skips', 'settings_import_blueprint_settings', 'date_shift_options_shift_dates', 'date_shift_options_old_start_date', 'date_shift_options_old_end_date', 'date_shift_options_new_start_date', 'date_shift_options_new_end_date', 'date_shift_options_day_substitutions_x', 'date_shift_options_remove_dates', 'selective_import', 'select']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_content_migration_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `create_content_migration_users`")  # noqa: E501
        # verify the required parameter 'migration_type' is set
        if self.api_client.client_side_validation and ('migration_type' not in params or
                                                       params['migration_type'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `migration_type` when calling `create_content_migration_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'migration_type' in params:
            form_params.append(('migration_type', params['migration_type']))  # noqa: E501
        if 'pre_attachment_name' in params:
            form_params.append(('pre_attachment[name]', params['pre_attachment_name']))  # noqa: E501
        if 'pre_attachment_' in params:
            form_params.append(('pre_attachment[*]', params['pre_attachment_']))  # noqa: E501
        if 'settings_file_url' in params:
            form_params.append(('settings[file_url]', params['settings_file_url']))  # noqa: E501
        if 'settings_content_export_id' in params:
            form_params.append(('settings[content_export_id]', params['settings_content_export_id']))  # noqa: E501
        if 'settings_source_course_id' in params:
            form_params.append(('settings[source_course_id]', params['settings_source_course_id']))  # noqa: E501
        if 'settings_folder_id' in params:
            form_params.append(('settings[folder_id]', params['settings_folder_id']))  # noqa: E501
        if 'settings_overwrite_quizzes' in params:
            form_params.append(('settings[overwrite_quizzes]', params['settings_overwrite_quizzes']))  # noqa: E501
        if 'settings_question_bank_id' in params:
            form_params.append(('settings[question_bank_id]', params['settings_question_bank_id']))  # noqa: E501
        if 'settings_question_bank_name' in params:
            form_params.append(('settings[question_bank_name]', params['settings_question_bank_name']))  # noqa: E501
        if 'settings_insert_into_module_id' in params:
            form_params.append(('settings[insert_into_module_id]', params['settings_insert_into_module_id']))  # noqa: E501
        if 'settings_insert_into_module_type' in params:
            form_params.append(('settings[insert_into_module_type]', params['settings_insert_into_module_type']))  # noqa: E501
        if 'settings_insert_into_module_position' in params:
            form_params.append(('settings[insert_into_module_position]', params['settings_insert_into_module_position']))  # noqa: E501
        if 'settings_move_to_assignment_group_id' in params:
            form_params.append(('settings[move_to_assignment_group_id]', params['settings_move_to_assignment_group_id']))  # noqa: E501
        if 'settings_importer_skips' in params:
            form_params.append(('settings[importer_skips]', params['settings_importer_skips']))  # noqa: E501
        if 'settings_import_blueprint_settings' in params:
            form_params.append(('settings[import_blueprint_settings]', params['settings_import_blueprint_settings']))  # noqa: E501
        if 'date_shift_options_shift_dates' in params:
            form_params.append(('date_shift_options[shift_dates]', params['date_shift_options_shift_dates']))  # noqa: E501
        if 'date_shift_options_old_start_date' in params:
            form_params.append(('date_shift_options[old_start_date]', params['date_shift_options_old_start_date']))  # noqa: E501
        if 'date_shift_options_old_end_date' in params:
            form_params.append(('date_shift_options[old_end_date]', params['date_shift_options_old_end_date']))  # noqa: E501
        if 'date_shift_options_new_start_date' in params:
            form_params.append(('date_shift_options[new_start_date]', params['date_shift_options_new_start_date']))  # noqa: E501
        if 'date_shift_options_new_end_date' in params:
            form_params.append(('date_shift_options[new_end_date]', params['date_shift_options_new_end_date']))  # noqa: E501
        if 'date_shift_options_day_substitutions_x' in params:
            form_params.append(('date_shift_options[day_substitutions][X]', params['date_shift_options_day_substitutions_x']))  # noqa: E501
        if 'date_shift_options_remove_dates' in params:
            form_params.append(('date_shift_options[remove_dates]', params['date_shift_options_remove_dates']))  # noqa: E501
        if 'selective_import' in params:
            form_params.append(('selective_import', params['selective_import']))  # noqa: E501
        if 'select' in params:
            form_params.append(('select', params['select']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/content_migrations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContentMigration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_asset_id_mapping(self, course_id, id, **kwargs):  # noqa: E501
        """Get asset id mapping  # noqa: E501

        Given a complete course copy or blueprint import content migration, return a mapping of asset ids from the source course to the destination course that were copied in this migration or an earlier one with the same course pair and migration_type (course copy or blueprint).  The returned object's keys are asset types as they appear in API URLs (+announcements+, +assignments+, +discussion_topics+, +files+, +module_items+, +modules+, +pages+, and +quizzes+). The values are a mapping from id in source course to id in destination course for objects of this type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_asset_id_mapping(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_asset_id_mapping_with_http_info(course_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_asset_id_mapping_with_http_info(course_id, id, **kwargs)  # noqa: E501
            return data

    def get_asset_id_mapping_with_http_info(self, course_id, id, **kwargs):  # noqa: E501
        """Get asset id mapping  # noqa: E501

        Given a complete course copy or blueprint import content migration, return a mapping of asset ids from the source course to the destination course that were copied in this migration or an earlier one with the same course pair and migration_type (course copy or blueprint).  The returned object's keys are asset types as they appear in API URLs (+announcements+, +assignments+, +discussion_topics+, +files+, +module_items+, +modules+, +pages+, and +quizzes+). The values are a mapping from id in source course to id in destination course for objects of this type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_asset_id_mapping_with_http_info(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_asset_id_mapping" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `get_asset_id_mapping`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_asset_id_mapping`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/content_migrations/{id}/asset_id_mapping', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_content_migration_accounts(self, account_id, id, **kwargs):  # noqa: E501
        """Get a content migration  # noqa: E501

        Returns data on an individual content migration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_content_migration_accounts(account_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str id: ID (required)
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_content_migration_accounts_with_http_info(account_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_content_migration_accounts_with_http_info(account_id, id, **kwargs)  # noqa: E501
            return data

    def get_content_migration_accounts_with_http_info(self, account_id, id, **kwargs):  # noqa: E501
        """Get a content migration  # noqa: E501

        Returns data on an individual content migration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_content_migration_accounts_with_http_info(account_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str id: ID (required)
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_content_migration_accounts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `get_content_migration_accounts`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_content_migration_accounts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/content_migrations/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContentMigration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_content_migration_courses(self, course_id, id, **kwargs):  # noqa: E501
        """Get a content migration  # noqa: E501

        Returns data on an individual content migration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_content_migration_courses(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_content_migration_courses_with_http_info(course_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_content_migration_courses_with_http_info(course_id, id, **kwargs)  # noqa: E501
            return data

    def get_content_migration_courses_with_http_info(self, course_id, id, **kwargs):  # noqa: E501
        """Get a content migration  # noqa: E501

        Returns data on an individual content migration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_content_migration_courses_with_http_info(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_content_migration_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `get_content_migration_courses`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_content_migration_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/content_migrations/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContentMigration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_content_migration_groups(self, group_id, id, **kwargs):  # noqa: E501
        """Get a content migration  # noqa: E501

        Returns data on an individual content migration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_content_migration_groups(group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str id: ID (required)
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_content_migration_groups_with_http_info(group_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_content_migration_groups_with_http_info(group_id, id, **kwargs)  # noqa: E501
            return data

    def get_content_migration_groups_with_http_info(self, group_id, id, **kwargs):  # noqa: E501
        """Get a content migration  # noqa: E501

        Returns data on an individual content migration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_content_migration_groups_with_http_info(group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str id: ID (required)
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_content_migration_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `get_content_migration_groups`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_content_migration_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/content_migrations/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContentMigration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_content_migration_users(self, user_id, id, **kwargs):  # noqa: E501
        """Get a content migration  # noqa: E501

        Returns data on an individual content migration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_content_migration_users(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str id: ID (required)
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_content_migration_users_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_content_migration_users_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def get_content_migration_users_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Get a content migration  # noqa: E501

        Returns data on an individual content migration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_content_migration_users_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str id: ID (required)
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_content_migration_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `get_content_migration_users`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_content_migration_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/content_migrations/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContentMigration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_migration_issue_accounts(self, account_id, content_migration_id, id, **kwargs):  # noqa: E501
        """Get a migration issue  # noqa: E501

        Returns data on an individual migration issue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_migration_issue_accounts(account_id, content_migration_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str content_migration_id: ID (required)
        :param str id: ID (required)
        :return: MigrationIssue
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_migration_issue_accounts_with_http_info(account_id, content_migration_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_migration_issue_accounts_with_http_info(account_id, content_migration_id, id, **kwargs)  # noqa: E501
            return data

    def get_migration_issue_accounts_with_http_info(self, account_id, content_migration_id, id, **kwargs):  # noqa: E501
        """Get a migration issue  # noqa: E501

        Returns data on an individual migration issue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_migration_issue_accounts_with_http_info(account_id, content_migration_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str content_migration_id: ID (required)
        :param str id: ID (required)
        :return: MigrationIssue
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'content_migration_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_migration_issue_accounts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `get_migration_issue_accounts`")  # noqa: E501
        # verify the required parameter 'content_migration_id' is set
        if self.api_client.client_side_validation and ('content_migration_id' not in params or
                                                       params['content_migration_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `content_migration_id` when calling `get_migration_issue_accounts`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_migration_issue_accounts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501
        if 'content_migration_id' in params:
            path_params['content_migration_id'] = params['content_migration_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/content_migrations/{content_migration_id}/migration_issues/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MigrationIssue',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_migration_issue_courses(self, course_id, content_migration_id, id, **kwargs):  # noqa: E501
        """Get a migration issue  # noqa: E501

        Returns data on an individual migration issue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_migration_issue_courses(course_id, content_migration_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str content_migration_id: ID (required)
        :param str id: ID (required)
        :return: MigrationIssue
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_migration_issue_courses_with_http_info(course_id, content_migration_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_migration_issue_courses_with_http_info(course_id, content_migration_id, id, **kwargs)  # noqa: E501
            return data

    def get_migration_issue_courses_with_http_info(self, course_id, content_migration_id, id, **kwargs):  # noqa: E501
        """Get a migration issue  # noqa: E501

        Returns data on an individual migration issue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_migration_issue_courses_with_http_info(course_id, content_migration_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str content_migration_id: ID (required)
        :param str id: ID (required)
        :return: MigrationIssue
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'content_migration_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_migration_issue_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `get_migration_issue_courses`")  # noqa: E501
        # verify the required parameter 'content_migration_id' is set
        if self.api_client.client_side_validation and ('content_migration_id' not in params or
                                                       params['content_migration_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `content_migration_id` when calling `get_migration_issue_courses`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_migration_issue_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'content_migration_id' in params:
            path_params['content_migration_id'] = params['content_migration_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/content_migrations/{content_migration_id}/migration_issues/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MigrationIssue',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_migration_issue_groups(self, group_id, content_migration_id, id, **kwargs):  # noqa: E501
        """Get a migration issue  # noqa: E501

        Returns data on an individual migration issue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_migration_issue_groups(group_id, content_migration_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str content_migration_id: ID (required)
        :param str id: ID (required)
        :return: MigrationIssue
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_migration_issue_groups_with_http_info(group_id, content_migration_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_migration_issue_groups_with_http_info(group_id, content_migration_id, id, **kwargs)  # noqa: E501
            return data

    def get_migration_issue_groups_with_http_info(self, group_id, content_migration_id, id, **kwargs):  # noqa: E501
        """Get a migration issue  # noqa: E501

        Returns data on an individual migration issue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_migration_issue_groups_with_http_info(group_id, content_migration_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str content_migration_id: ID (required)
        :param str id: ID (required)
        :return: MigrationIssue
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'content_migration_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_migration_issue_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `get_migration_issue_groups`")  # noqa: E501
        # verify the required parameter 'content_migration_id' is set
        if self.api_client.client_side_validation and ('content_migration_id' not in params or
                                                       params['content_migration_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `content_migration_id` when calling `get_migration_issue_groups`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_migration_issue_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'content_migration_id' in params:
            path_params['content_migration_id'] = params['content_migration_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/content_migrations/{content_migration_id}/migration_issues/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MigrationIssue',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_migration_issue_users(self, user_id, content_migration_id, id, **kwargs):  # noqa: E501
        """Get a migration issue  # noqa: E501

        Returns data on an individual migration issue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_migration_issue_users(user_id, content_migration_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str content_migration_id: ID (required)
        :param str id: ID (required)
        :return: MigrationIssue
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_migration_issue_users_with_http_info(user_id, content_migration_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_migration_issue_users_with_http_info(user_id, content_migration_id, id, **kwargs)  # noqa: E501
            return data

    def get_migration_issue_users_with_http_info(self, user_id, content_migration_id, id, **kwargs):  # noqa: E501
        """Get a migration issue  # noqa: E501

        Returns data on an individual migration issue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_migration_issue_users_with_http_info(user_id, content_migration_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str content_migration_id: ID (required)
        :param str id: ID (required)
        :return: MigrationIssue
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'content_migration_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_migration_issue_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `get_migration_issue_users`")  # noqa: E501
        # verify the required parameter 'content_migration_id' is set
        if self.api_client.client_side_validation and ('content_migration_id' not in params or
                                                       params['content_migration_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `content_migration_id` when calling `get_migration_issue_users`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_migration_issue_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'content_migration_id' in params:
            path_params['content_migration_id'] = params['content_migration_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/content_migrations/{content_migration_id}/migration_issues/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MigrationIssue',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_content_migrations_accounts(self, account_id, **kwargs):  # noqa: E501
        """List content migrations  # noqa: E501

        Returns paginated content migrations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_content_migrations_accounts(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :return: list[ContentMigration]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_content_migrations_accounts_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_content_migrations_accounts_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def list_content_migrations_accounts_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """List content migrations  # noqa: E501

        Returns paginated content migrations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_content_migrations_accounts_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :return: list[ContentMigration]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_content_migrations_accounts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `list_content_migrations_accounts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/content_migrations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContentMigration]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_content_migrations_courses(self, course_id, **kwargs):  # noqa: E501
        """List content migrations  # noqa: E501

        Returns paginated content migrations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_content_migrations_courses(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: list[ContentMigration]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_content_migrations_courses_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_content_migrations_courses_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def list_content_migrations_courses_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """List content migrations  # noqa: E501

        Returns paginated content migrations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_content_migrations_courses_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: list[ContentMigration]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_content_migrations_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `list_content_migrations_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/content_migrations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContentMigration]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_content_migrations_groups(self, group_id, **kwargs):  # noqa: E501
        """List content migrations  # noqa: E501

        Returns paginated content migrations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_content_migrations_groups(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: list[ContentMigration]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_content_migrations_groups_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_content_migrations_groups_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def list_content_migrations_groups_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """List content migrations  # noqa: E501

        Returns paginated content migrations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_content_migrations_groups_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: list[ContentMigration]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_content_migrations_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `list_content_migrations_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/content_migrations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContentMigration]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_content_migrations_users(self, user_id, **kwargs):  # noqa: E501
        """List content migrations  # noqa: E501

        Returns paginated content migrations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_content_migrations_users(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: list[ContentMigration]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_content_migrations_users_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_content_migrations_users_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def list_content_migrations_users_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List content migrations  # noqa: E501

        Returns paginated content migrations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_content_migrations_users_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: list[ContentMigration]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_content_migrations_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `list_content_migrations_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/content_migrations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContentMigration]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_items_for_selective_import_accounts(self, account_id, id, **kwargs):  # noqa: E501
        """List items for selective import  # noqa: E501

        Enumerates the content available for selective import in a tree structure. Each node provides a +property+ copy argument that can be supplied to the {api:ContentMigrationsController#update Update endpoint} to selectively copy the content associated with that tree node and its children. Each node may also provide a +sub_items_url+ or an array of +sub_items+ which you can use to obtain copy parameters for a subset of the resources in a given node.  If no +type+ is sent you will get a list of the top-level sections in the content. It will look something like this:    [{     \"type\": \"course_settings\",     \"property\": \"copy[all_course_settings]\",     \"title\": \"Course Settings\"   },   {     \"type\": \"context_modules\",     \"property\": \"copy[all_context_modules]\",     \"title\": \"Modules\",     \"count\": 5,     \"sub_items_url\": \"http://example.com/api/v1/courses/22/content_migrations/77/selective_data?type=context_modules\"   },   {     \"type\": \"assignments\",     \"property\": \"copy[all_assignments]\",     \"title\": \"Assignments\",     \"count\": 2,     \"sub_items_url\": \"http://localhost:3000/api/v1/courses/22/content_migrations/77/selective_data?type=assignments\"   }]  When a +type+ is provided, nodes may be further divided via +sub_items+. For example, using +type=assignments+ results in a node for each assignment group and a sub_item for each assignment, like this:    [{     \"type\": \"assignment_groups\",     \"title\": \"An Assignment Group\",     \"property\": \"copy[assignment_groups][id_i855cf145e5acc7435e1bf1c6e2126e5f]\",     \"sub_items\": [{         \"type\": \"assignments\",         \"title\": \"Assignment 1\",         \"property\": \"copy[assignments][id_i2102a7fa93b29226774949298626719d]\"     }, {         \"type\": \"assignments\",         \"title\": \"Assignment 2\",         \"property\": \"copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]\"     }]   }]   To import the items corresponding to a particular tree node, use the +property+ as a parameter to the {api:ContentMigrationsController#update Update endpoint} and assign a value of 1, for example:    copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]=1  You can include multiple copy parameters to selectively import multiple items or groups of items.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_items_for_selective_import_accounts(account_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str id: ID (required)
        :param str type: The type of content to enumerate.
        :return: ListOfContentItems
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_items_for_selective_import_accounts_with_http_info(account_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_items_for_selective_import_accounts_with_http_info(account_id, id, **kwargs)  # noqa: E501
            return data

    def list_items_for_selective_import_accounts_with_http_info(self, account_id, id, **kwargs):  # noqa: E501
        """List items for selective import  # noqa: E501

        Enumerates the content available for selective import in a tree structure. Each node provides a +property+ copy argument that can be supplied to the {api:ContentMigrationsController#update Update endpoint} to selectively copy the content associated with that tree node and its children. Each node may also provide a +sub_items_url+ or an array of +sub_items+ which you can use to obtain copy parameters for a subset of the resources in a given node.  If no +type+ is sent you will get a list of the top-level sections in the content. It will look something like this:    [{     \"type\": \"course_settings\",     \"property\": \"copy[all_course_settings]\",     \"title\": \"Course Settings\"   },   {     \"type\": \"context_modules\",     \"property\": \"copy[all_context_modules]\",     \"title\": \"Modules\",     \"count\": 5,     \"sub_items_url\": \"http://example.com/api/v1/courses/22/content_migrations/77/selective_data?type=context_modules\"   },   {     \"type\": \"assignments\",     \"property\": \"copy[all_assignments]\",     \"title\": \"Assignments\",     \"count\": 2,     \"sub_items_url\": \"http://localhost:3000/api/v1/courses/22/content_migrations/77/selective_data?type=assignments\"   }]  When a +type+ is provided, nodes may be further divided via +sub_items+. For example, using +type=assignments+ results in a node for each assignment group and a sub_item for each assignment, like this:    [{     \"type\": \"assignment_groups\",     \"title\": \"An Assignment Group\",     \"property\": \"copy[assignment_groups][id_i855cf145e5acc7435e1bf1c6e2126e5f]\",     \"sub_items\": [{         \"type\": \"assignments\",         \"title\": \"Assignment 1\",         \"property\": \"copy[assignments][id_i2102a7fa93b29226774949298626719d]\"     }, {         \"type\": \"assignments\",         \"title\": \"Assignment 2\",         \"property\": \"copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]\"     }]   }]   To import the items corresponding to a particular tree node, use the +property+ as a parameter to the {api:ContentMigrationsController#update Update endpoint} and assign a value of 1, for example:    copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]=1  You can include multiple copy parameters to selectively import multiple items or groups of items.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_items_for_selective_import_accounts_with_http_info(account_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str id: ID (required)
        :param str type: The type of content to enumerate.
        :return: ListOfContentItems
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'id', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_items_for_selective_import_accounts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `list_items_for_selective_import_accounts`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `list_items_for_selective_import_accounts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/content_migrations/{id}/selective_data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListOfContentItems',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_items_for_selective_import_courses(self, course_id, id, **kwargs):  # noqa: E501
        """List items for selective import  # noqa: E501

        Enumerates the content available for selective import in a tree structure. Each node provides a +property+ copy argument that can be supplied to the {api:ContentMigrationsController#update Update endpoint} to selectively copy the content associated with that tree node and its children. Each node may also provide a +sub_items_url+ or an array of +sub_items+ which you can use to obtain copy parameters for a subset of the resources in a given node.  If no +type+ is sent you will get a list of the top-level sections in the content. It will look something like this:    [{     \"type\": \"course_settings\",     \"property\": \"copy[all_course_settings]\",     \"title\": \"Course Settings\"   },   {     \"type\": \"context_modules\",     \"property\": \"copy[all_context_modules]\",     \"title\": \"Modules\",     \"count\": 5,     \"sub_items_url\": \"http://example.com/api/v1/courses/22/content_migrations/77/selective_data?type=context_modules\"   },   {     \"type\": \"assignments\",     \"property\": \"copy[all_assignments]\",     \"title\": \"Assignments\",     \"count\": 2,     \"sub_items_url\": \"http://localhost:3000/api/v1/courses/22/content_migrations/77/selective_data?type=assignments\"   }]  When a +type+ is provided, nodes may be further divided via +sub_items+. For example, using +type=assignments+ results in a node for each assignment group and a sub_item for each assignment, like this:    [{     \"type\": \"assignment_groups\",     \"title\": \"An Assignment Group\",     \"property\": \"copy[assignment_groups][id_i855cf145e5acc7435e1bf1c6e2126e5f]\",     \"sub_items\": [{         \"type\": \"assignments\",         \"title\": \"Assignment 1\",         \"property\": \"copy[assignments][id_i2102a7fa93b29226774949298626719d]\"     }, {         \"type\": \"assignments\",         \"title\": \"Assignment 2\",         \"property\": \"copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]\"     }]   }]   To import the items corresponding to a particular tree node, use the +property+ as a parameter to the {api:ContentMigrationsController#update Update endpoint} and assign a value of 1, for example:    copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]=1  You can include multiple copy parameters to selectively import multiple items or groups of items.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_items_for_selective_import_courses(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :param str type: The type of content to enumerate.
        :return: ListOfContentItems
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_items_for_selective_import_courses_with_http_info(course_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_items_for_selective_import_courses_with_http_info(course_id, id, **kwargs)  # noqa: E501
            return data

    def list_items_for_selective_import_courses_with_http_info(self, course_id, id, **kwargs):  # noqa: E501
        """List items for selective import  # noqa: E501

        Enumerates the content available for selective import in a tree structure. Each node provides a +property+ copy argument that can be supplied to the {api:ContentMigrationsController#update Update endpoint} to selectively copy the content associated with that tree node and its children. Each node may also provide a +sub_items_url+ or an array of +sub_items+ which you can use to obtain copy parameters for a subset of the resources in a given node.  If no +type+ is sent you will get a list of the top-level sections in the content. It will look something like this:    [{     \"type\": \"course_settings\",     \"property\": \"copy[all_course_settings]\",     \"title\": \"Course Settings\"   },   {     \"type\": \"context_modules\",     \"property\": \"copy[all_context_modules]\",     \"title\": \"Modules\",     \"count\": 5,     \"sub_items_url\": \"http://example.com/api/v1/courses/22/content_migrations/77/selective_data?type=context_modules\"   },   {     \"type\": \"assignments\",     \"property\": \"copy[all_assignments]\",     \"title\": \"Assignments\",     \"count\": 2,     \"sub_items_url\": \"http://localhost:3000/api/v1/courses/22/content_migrations/77/selective_data?type=assignments\"   }]  When a +type+ is provided, nodes may be further divided via +sub_items+. For example, using +type=assignments+ results in a node for each assignment group and a sub_item for each assignment, like this:    [{     \"type\": \"assignment_groups\",     \"title\": \"An Assignment Group\",     \"property\": \"copy[assignment_groups][id_i855cf145e5acc7435e1bf1c6e2126e5f]\",     \"sub_items\": [{         \"type\": \"assignments\",         \"title\": \"Assignment 1\",         \"property\": \"copy[assignments][id_i2102a7fa93b29226774949298626719d]\"     }, {         \"type\": \"assignments\",         \"title\": \"Assignment 2\",         \"property\": \"copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]\"     }]   }]   To import the items corresponding to a particular tree node, use the +property+ as a parameter to the {api:ContentMigrationsController#update Update endpoint} and assign a value of 1, for example:    copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]=1  You can include multiple copy parameters to selectively import multiple items or groups of items.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_items_for_selective_import_courses_with_http_info(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :param str type: The type of content to enumerate.
        :return: ListOfContentItems
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'id', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_items_for_selective_import_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `list_items_for_selective_import_courses`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `list_items_for_selective_import_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/content_migrations/{id}/selective_data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListOfContentItems',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_items_for_selective_import_groups(self, group_id, id, **kwargs):  # noqa: E501
        """List items for selective import  # noqa: E501

        Enumerates the content available for selective import in a tree structure. Each node provides a +property+ copy argument that can be supplied to the {api:ContentMigrationsController#update Update endpoint} to selectively copy the content associated with that tree node and its children. Each node may also provide a +sub_items_url+ or an array of +sub_items+ which you can use to obtain copy parameters for a subset of the resources in a given node.  If no +type+ is sent you will get a list of the top-level sections in the content. It will look something like this:    [{     \"type\": \"course_settings\",     \"property\": \"copy[all_course_settings]\",     \"title\": \"Course Settings\"   },   {     \"type\": \"context_modules\",     \"property\": \"copy[all_context_modules]\",     \"title\": \"Modules\",     \"count\": 5,     \"sub_items_url\": \"http://example.com/api/v1/courses/22/content_migrations/77/selective_data?type=context_modules\"   },   {     \"type\": \"assignments\",     \"property\": \"copy[all_assignments]\",     \"title\": \"Assignments\",     \"count\": 2,     \"sub_items_url\": \"http://localhost:3000/api/v1/courses/22/content_migrations/77/selective_data?type=assignments\"   }]  When a +type+ is provided, nodes may be further divided via +sub_items+. For example, using +type=assignments+ results in a node for each assignment group and a sub_item for each assignment, like this:    [{     \"type\": \"assignment_groups\",     \"title\": \"An Assignment Group\",     \"property\": \"copy[assignment_groups][id_i855cf145e5acc7435e1bf1c6e2126e5f]\",     \"sub_items\": [{         \"type\": \"assignments\",         \"title\": \"Assignment 1\",         \"property\": \"copy[assignments][id_i2102a7fa93b29226774949298626719d]\"     }, {         \"type\": \"assignments\",         \"title\": \"Assignment 2\",         \"property\": \"copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]\"     }]   }]   To import the items corresponding to a particular tree node, use the +property+ as a parameter to the {api:ContentMigrationsController#update Update endpoint} and assign a value of 1, for example:    copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]=1  You can include multiple copy parameters to selectively import multiple items or groups of items.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_items_for_selective_import_groups(group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str id: ID (required)
        :param str type: The type of content to enumerate.
        :return: ListOfContentItems
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_items_for_selective_import_groups_with_http_info(group_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_items_for_selective_import_groups_with_http_info(group_id, id, **kwargs)  # noqa: E501
            return data

    def list_items_for_selective_import_groups_with_http_info(self, group_id, id, **kwargs):  # noqa: E501
        """List items for selective import  # noqa: E501

        Enumerates the content available for selective import in a tree structure. Each node provides a +property+ copy argument that can be supplied to the {api:ContentMigrationsController#update Update endpoint} to selectively copy the content associated with that tree node and its children. Each node may also provide a +sub_items_url+ or an array of +sub_items+ which you can use to obtain copy parameters for a subset of the resources in a given node.  If no +type+ is sent you will get a list of the top-level sections in the content. It will look something like this:    [{     \"type\": \"course_settings\",     \"property\": \"copy[all_course_settings]\",     \"title\": \"Course Settings\"   },   {     \"type\": \"context_modules\",     \"property\": \"copy[all_context_modules]\",     \"title\": \"Modules\",     \"count\": 5,     \"sub_items_url\": \"http://example.com/api/v1/courses/22/content_migrations/77/selective_data?type=context_modules\"   },   {     \"type\": \"assignments\",     \"property\": \"copy[all_assignments]\",     \"title\": \"Assignments\",     \"count\": 2,     \"sub_items_url\": \"http://localhost:3000/api/v1/courses/22/content_migrations/77/selective_data?type=assignments\"   }]  When a +type+ is provided, nodes may be further divided via +sub_items+. For example, using +type=assignments+ results in a node for each assignment group and a sub_item for each assignment, like this:    [{     \"type\": \"assignment_groups\",     \"title\": \"An Assignment Group\",     \"property\": \"copy[assignment_groups][id_i855cf145e5acc7435e1bf1c6e2126e5f]\",     \"sub_items\": [{         \"type\": \"assignments\",         \"title\": \"Assignment 1\",         \"property\": \"copy[assignments][id_i2102a7fa93b29226774949298626719d]\"     }, {         \"type\": \"assignments\",         \"title\": \"Assignment 2\",         \"property\": \"copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]\"     }]   }]   To import the items corresponding to a particular tree node, use the +property+ as a parameter to the {api:ContentMigrationsController#update Update endpoint} and assign a value of 1, for example:    copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]=1  You can include multiple copy parameters to selectively import multiple items or groups of items.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_items_for_selective_import_groups_with_http_info(group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str id: ID (required)
        :param str type: The type of content to enumerate.
        :return: ListOfContentItems
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'id', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_items_for_selective_import_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `list_items_for_selective_import_groups`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `list_items_for_selective_import_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/content_migrations/{id}/selective_data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListOfContentItems',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_items_for_selective_import_users(self, user_id, id, **kwargs):  # noqa: E501
        """List items for selective import  # noqa: E501

        Enumerates the content available for selective import in a tree structure. Each node provides a +property+ copy argument that can be supplied to the {api:ContentMigrationsController#update Update endpoint} to selectively copy the content associated with that tree node and its children. Each node may also provide a +sub_items_url+ or an array of +sub_items+ which you can use to obtain copy parameters for a subset of the resources in a given node.  If no +type+ is sent you will get a list of the top-level sections in the content. It will look something like this:    [{     \"type\": \"course_settings\",     \"property\": \"copy[all_course_settings]\",     \"title\": \"Course Settings\"   },   {     \"type\": \"context_modules\",     \"property\": \"copy[all_context_modules]\",     \"title\": \"Modules\",     \"count\": 5,     \"sub_items_url\": \"http://example.com/api/v1/courses/22/content_migrations/77/selective_data?type=context_modules\"   },   {     \"type\": \"assignments\",     \"property\": \"copy[all_assignments]\",     \"title\": \"Assignments\",     \"count\": 2,     \"sub_items_url\": \"http://localhost:3000/api/v1/courses/22/content_migrations/77/selective_data?type=assignments\"   }]  When a +type+ is provided, nodes may be further divided via +sub_items+. For example, using +type=assignments+ results in a node for each assignment group and a sub_item for each assignment, like this:    [{     \"type\": \"assignment_groups\",     \"title\": \"An Assignment Group\",     \"property\": \"copy[assignment_groups][id_i855cf145e5acc7435e1bf1c6e2126e5f]\",     \"sub_items\": [{         \"type\": \"assignments\",         \"title\": \"Assignment 1\",         \"property\": \"copy[assignments][id_i2102a7fa93b29226774949298626719d]\"     }, {         \"type\": \"assignments\",         \"title\": \"Assignment 2\",         \"property\": \"copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]\"     }]   }]   To import the items corresponding to a particular tree node, use the +property+ as a parameter to the {api:ContentMigrationsController#update Update endpoint} and assign a value of 1, for example:    copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]=1  You can include multiple copy parameters to selectively import multiple items or groups of items.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_items_for_selective_import_users(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str id: ID (required)
        :param str type: The type of content to enumerate.
        :return: ListOfContentItems
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_items_for_selective_import_users_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_items_for_selective_import_users_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def list_items_for_selective_import_users_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """List items for selective import  # noqa: E501

        Enumerates the content available for selective import in a tree structure. Each node provides a +property+ copy argument that can be supplied to the {api:ContentMigrationsController#update Update endpoint} to selectively copy the content associated with that tree node and its children. Each node may also provide a +sub_items_url+ or an array of +sub_items+ which you can use to obtain copy parameters for a subset of the resources in a given node.  If no +type+ is sent you will get a list of the top-level sections in the content. It will look something like this:    [{     \"type\": \"course_settings\",     \"property\": \"copy[all_course_settings]\",     \"title\": \"Course Settings\"   },   {     \"type\": \"context_modules\",     \"property\": \"copy[all_context_modules]\",     \"title\": \"Modules\",     \"count\": 5,     \"sub_items_url\": \"http://example.com/api/v1/courses/22/content_migrations/77/selective_data?type=context_modules\"   },   {     \"type\": \"assignments\",     \"property\": \"copy[all_assignments]\",     \"title\": \"Assignments\",     \"count\": 2,     \"sub_items_url\": \"http://localhost:3000/api/v1/courses/22/content_migrations/77/selective_data?type=assignments\"   }]  When a +type+ is provided, nodes may be further divided via +sub_items+. For example, using +type=assignments+ results in a node for each assignment group and a sub_item for each assignment, like this:    [{     \"type\": \"assignment_groups\",     \"title\": \"An Assignment Group\",     \"property\": \"copy[assignment_groups][id_i855cf145e5acc7435e1bf1c6e2126e5f]\",     \"sub_items\": [{         \"type\": \"assignments\",         \"title\": \"Assignment 1\",         \"property\": \"copy[assignments][id_i2102a7fa93b29226774949298626719d]\"     }, {         \"type\": \"assignments\",         \"title\": \"Assignment 2\",         \"property\": \"copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]\"     }]   }]   To import the items corresponding to a particular tree node, use the +property+ as a parameter to the {api:ContentMigrationsController#update Update endpoint} and assign a value of 1, for example:    copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]=1  You can include multiple copy parameters to selectively import multiple items or groups of items.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_items_for_selective_import_users_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str id: ID (required)
        :param str type: The type of content to enumerate.
        :return: ListOfContentItems
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_items_for_selective_import_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `list_items_for_selective_import_users`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `list_items_for_selective_import_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/content_migrations/{id}/selective_data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListOfContentItems',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_migration_issues_accounts(self, account_id, content_migration_id, **kwargs):  # noqa: E501
        """List migration issues  # noqa: E501

        Returns paginated migration issues  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_migration_issues_accounts(account_id, content_migration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str content_migration_id: ID (required)
        :return: list[MigrationIssue]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_migration_issues_accounts_with_http_info(account_id, content_migration_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_migration_issues_accounts_with_http_info(account_id, content_migration_id, **kwargs)  # noqa: E501
            return data

    def list_migration_issues_accounts_with_http_info(self, account_id, content_migration_id, **kwargs):  # noqa: E501
        """List migration issues  # noqa: E501

        Returns paginated migration issues  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_migration_issues_accounts_with_http_info(account_id, content_migration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str content_migration_id: ID (required)
        :return: list[MigrationIssue]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'content_migration_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_migration_issues_accounts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `list_migration_issues_accounts`")  # noqa: E501
        # verify the required parameter 'content_migration_id' is set
        if self.api_client.client_side_validation and ('content_migration_id' not in params or
                                                       params['content_migration_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `content_migration_id` when calling `list_migration_issues_accounts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501
        if 'content_migration_id' in params:
            path_params['content_migration_id'] = params['content_migration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/content_migrations/{content_migration_id}/migration_issues', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MigrationIssue]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_migration_issues_courses(self, course_id, content_migration_id, **kwargs):  # noqa: E501
        """List migration issues  # noqa: E501

        Returns paginated migration issues  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_migration_issues_courses(course_id, content_migration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str content_migration_id: ID (required)
        :return: list[MigrationIssue]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_migration_issues_courses_with_http_info(course_id, content_migration_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_migration_issues_courses_with_http_info(course_id, content_migration_id, **kwargs)  # noqa: E501
            return data

    def list_migration_issues_courses_with_http_info(self, course_id, content_migration_id, **kwargs):  # noqa: E501
        """List migration issues  # noqa: E501

        Returns paginated migration issues  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_migration_issues_courses_with_http_info(course_id, content_migration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str content_migration_id: ID (required)
        :return: list[MigrationIssue]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'content_migration_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_migration_issues_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `list_migration_issues_courses`")  # noqa: E501
        # verify the required parameter 'content_migration_id' is set
        if self.api_client.client_side_validation and ('content_migration_id' not in params or
                                                       params['content_migration_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `content_migration_id` when calling `list_migration_issues_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'content_migration_id' in params:
            path_params['content_migration_id'] = params['content_migration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/content_migrations/{content_migration_id}/migration_issues', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MigrationIssue]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_migration_issues_groups(self, group_id, content_migration_id, **kwargs):  # noqa: E501
        """List migration issues  # noqa: E501

        Returns paginated migration issues  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_migration_issues_groups(group_id, content_migration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str content_migration_id: ID (required)
        :return: list[MigrationIssue]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_migration_issues_groups_with_http_info(group_id, content_migration_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_migration_issues_groups_with_http_info(group_id, content_migration_id, **kwargs)  # noqa: E501
            return data

    def list_migration_issues_groups_with_http_info(self, group_id, content_migration_id, **kwargs):  # noqa: E501
        """List migration issues  # noqa: E501

        Returns paginated migration issues  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_migration_issues_groups_with_http_info(group_id, content_migration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str content_migration_id: ID (required)
        :return: list[MigrationIssue]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'content_migration_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_migration_issues_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `list_migration_issues_groups`")  # noqa: E501
        # verify the required parameter 'content_migration_id' is set
        if self.api_client.client_side_validation and ('content_migration_id' not in params or
                                                       params['content_migration_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `content_migration_id` when calling `list_migration_issues_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'content_migration_id' in params:
            path_params['content_migration_id'] = params['content_migration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/content_migrations/{content_migration_id}/migration_issues', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MigrationIssue]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_migration_issues_users(self, user_id, content_migration_id, **kwargs):  # noqa: E501
        """List migration issues  # noqa: E501

        Returns paginated migration issues  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_migration_issues_users(user_id, content_migration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str content_migration_id: ID (required)
        :return: list[MigrationIssue]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_migration_issues_users_with_http_info(user_id, content_migration_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_migration_issues_users_with_http_info(user_id, content_migration_id, **kwargs)  # noqa: E501
            return data

    def list_migration_issues_users_with_http_info(self, user_id, content_migration_id, **kwargs):  # noqa: E501
        """List migration issues  # noqa: E501

        Returns paginated migration issues  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_migration_issues_users_with_http_info(user_id, content_migration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str content_migration_id: ID (required)
        :return: list[MigrationIssue]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'content_migration_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_migration_issues_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `list_migration_issues_users`")  # noqa: E501
        # verify the required parameter 'content_migration_id' is set
        if self.api_client.client_side_validation and ('content_migration_id' not in params or
                                                       params['content_migration_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `content_migration_id` when calling `list_migration_issues_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'content_migration_id' in params:
            path_params['content_migration_id'] = params['content_migration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/content_migrations/{content_migration_id}/migration_issues', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MigrationIssue]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_migration_systems_accounts(self, account_id, **kwargs):  # noqa: E501
        """List Migration Systems  # noqa: E501

        Lists the currently available migration types. These values may change.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_migration_systems_accounts(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :return: list[Migrator]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_migration_systems_accounts_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_migration_systems_accounts_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def list_migration_systems_accounts_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """List Migration Systems  # noqa: E501

        Lists the currently available migration types. These values may change.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_migration_systems_accounts_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :return: list[Migrator]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_migration_systems_accounts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `list_migration_systems_accounts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/content_migrations/migrators', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Migrator]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_migration_systems_courses(self, course_id, **kwargs):  # noqa: E501
        """List Migration Systems  # noqa: E501

        Lists the currently available migration types. These values may change.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_migration_systems_courses(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: list[Migrator]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_migration_systems_courses_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_migration_systems_courses_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def list_migration_systems_courses_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """List Migration Systems  # noqa: E501

        Lists the currently available migration types. These values may change.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_migration_systems_courses_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: list[Migrator]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_migration_systems_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `list_migration_systems_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/content_migrations/migrators', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Migrator]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_migration_systems_groups(self, group_id, **kwargs):  # noqa: E501
        """List Migration Systems  # noqa: E501

        Lists the currently available migration types. These values may change.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_migration_systems_groups(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: list[Migrator]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_migration_systems_groups_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_migration_systems_groups_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def list_migration_systems_groups_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """List Migration Systems  # noqa: E501

        Lists the currently available migration types. These values may change.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_migration_systems_groups_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: list[Migrator]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_migration_systems_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `list_migration_systems_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/content_migrations/migrators', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Migrator]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_migration_systems_users(self, user_id, **kwargs):  # noqa: E501
        """List Migration Systems  # noqa: E501

        Lists the currently available migration types. These values may change.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_migration_systems_users(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: list[Migrator]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_migration_systems_users_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_migration_systems_users_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def list_migration_systems_users_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List Migration Systems  # noqa: E501

        Lists the currently available migration types. These values may change.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_migration_systems_users_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: list[Migrator]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_migration_systems_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `list_migration_systems_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/content_migrations/migrators', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Migrator]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_content_migration_accounts(self, account_id, id, **kwargs):  # noqa: E501
        """Update a content migration  # noqa: E501

        Update a content migration. Takes same arguments as {api:ContentMigrationsController#create create} except that you can't change the migration type. However, changing most settings after the migration process has started will not do anything. Generally updating the content migration will be used when there is a file upload problem, or when importing content selectively. If the first upload has a problem you can supply new _pre_attachment_ values to start the process again.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_content_migration_accounts(account_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str id: ID (required)
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_content_migration_accounts_with_http_info(account_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_content_migration_accounts_with_http_info(account_id, id, **kwargs)  # noqa: E501
            return data

    def update_content_migration_accounts_with_http_info(self, account_id, id, **kwargs):  # noqa: E501
        """Update a content migration  # noqa: E501

        Update a content migration. Takes same arguments as {api:ContentMigrationsController#create create} except that you can't change the migration type. However, changing most settings after the migration process has started will not do anything. Generally updating the content migration will be used when there is a file upload problem, or when importing content selectively. If the first upload has a problem you can supply new _pre_attachment_ values to start the process again.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_content_migration_accounts_with_http_info(account_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str id: ID (required)
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_content_migration_accounts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `update_content_migration_accounts`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_content_migration_accounts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/content_migrations/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContentMigration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_content_migration_courses(self, course_id, id, **kwargs):  # noqa: E501
        """Update a content migration  # noqa: E501

        Update a content migration. Takes same arguments as {api:ContentMigrationsController#create create} except that you can't change the migration type. However, changing most settings after the migration process has started will not do anything. Generally updating the content migration will be used when there is a file upload problem, or when importing content selectively. If the first upload has a problem you can supply new _pre_attachment_ values to start the process again.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_content_migration_courses(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_content_migration_courses_with_http_info(course_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_content_migration_courses_with_http_info(course_id, id, **kwargs)  # noqa: E501
            return data

    def update_content_migration_courses_with_http_info(self, course_id, id, **kwargs):  # noqa: E501
        """Update a content migration  # noqa: E501

        Update a content migration. Takes same arguments as {api:ContentMigrationsController#create create} except that you can't change the migration type. However, changing most settings after the migration process has started will not do anything. Generally updating the content migration will be used when there is a file upload problem, or when importing content selectively. If the first upload has a problem you can supply new _pre_attachment_ values to start the process again.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_content_migration_courses_with_http_info(course_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str id: ID (required)
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_content_migration_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `update_content_migration_courses`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_content_migration_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/content_migrations/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContentMigration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_content_migration_groups(self, group_id, id, **kwargs):  # noqa: E501
        """Update a content migration  # noqa: E501

        Update a content migration. Takes same arguments as {api:ContentMigrationsController#create create} except that you can't change the migration type. However, changing most settings after the migration process has started will not do anything. Generally updating the content migration will be used when there is a file upload problem, or when importing content selectively. If the first upload has a problem you can supply new _pre_attachment_ values to start the process again.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_content_migration_groups(group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str id: ID (required)
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_content_migration_groups_with_http_info(group_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_content_migration_groups_with_http_info(group_id, id, **kwargs)  # noqa: E501
            return data

    def update_content_migration_groups_with_http_info(self, group_id, id, **kwargs):  # noqa: E501
        """Update a content migration  # noqa: E501

        Update a content migration. Takes same arguments as {api:ContentMigrationsController#create create} except that you can't change the migration type. However, changing most settings after the migration process has started will not do anything. Generally updating the content migration will be used when there is a file upload problem, or when importing content selectively. If the first upload has a problem you can supply new _pre_attachment_ values to start the process again.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_content_migration_groups_with_http_info(group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str id: ID (required)
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_content_migration_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `update_content_migration_groups`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_content_migration_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/content_migrations/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContentMigration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_content_migration_users(self, user_id, id, **kwargs):  # noqa: E501
        """Update a content migration  # noqa: E501

        Update a content migration. Takes same arguments as {api:ContentMigrationsController#create create} except that you can't change the migration type. However, changing most settings after the migration process has started will not do anything. Generally updating the content migration will be used when there is a file upload problem, or when importing content selectively. If the first upload has a problem you can supply new _pre_attachment_ values to start the process again.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_content_migration_users(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str id: ID (required)
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_content_migration_users_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_content_migration_users_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def update_content_migration_users_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Update a content migration  # noqa: E501

        Update a content migration. Takes same arguments as {api:ContentMigrationsController#create create} except that you can't change the migration type. However, changing most settings after the migration process has started will not do anything. Generally updating the content migration will be used when there is a file upload problem, or when importing content selectively. If the first upload has a problem you can supply new _pre_attachment_ values to start the process again.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_content_migration_users_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str id: ID (required)
        :return: ContentMigration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_content_migration_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `update_content_migration_users`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_content_migration_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/content_migrations/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContentMigration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_migration_issue_accounts(self, account_id, content_migration_id, id, workflow_state, **kwargs):  # noqa: E501
        """Update a migration issue  # noqa: E501

        Update the workflow_state of a migration issue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_migration_issue_accounts(account_id, content_migration_id, id, workflow_state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str content_migration_id: ID (required)
        :param str id: ID (required)
        :param str workflow_state: Set the workflow_state of the issue. (required)
        :return: MigrationIssue
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_migration_issue_accounts_with_http_info(account_id, content_migration_id, id, workflow_state, **kwargs)  # noqa: E501
        else:
            (data) = self.update_migration_issue_accounts_with_http_info(account_id, content_migration_id, id, workflow_state, **kwargs)  # noqa: E501
            return data

    def update_migration_issue_accounts_with_http_info(self, account_id, content_migration_id, id, workflow_state, **kwargs):  # noqa: E501
        """Update a migration issue  # noqa: E501

        Update the workflow_state of a migration issue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_migration_issue_accounts_with_http_info(account_id, content_migration_id, id, workflow_state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str content_migration_id: ID (required)
        :param str id: ID (required)
        :param str workflow_state: Set the workflow_state of the issue. (required)
        :return: MigrationIssue
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'content_migration_id', 'id', 'workflow_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_migration_issue_accounts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `update_migration_issue_accounts`")  # noqa: E501
        # verify the required parameter 'content_migration_id' is set
        if self.api_client.client_side_validation and ('content_migration_id' not in params or
                                                       params['content_migration_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `content_migration_id` when calling `update_migration_issue_accounts`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_migration_issue_accounts`")  # noqa: E501
        # verify the required parameter 'workflow_state' is set
        if self.api_client.client_side_validation and ('workflow_state' not in params or
                                                       params['workflow_state'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `workflow_state` when calling `update_migration_issue_accounts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501
        if 'content_migration_id' in params:
            path_params['content_migration_id'] = params['content_migration_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'workflow_state' in params:
            form_params.append(('workflow_state', params['workflow_state']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/content_migrations/{content_migration_id}/migration_issues/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MigrationIssue',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_migration_issue_courses(self, course_id, content_migration_id, id, workflow_state, **kwargs):  # noqa: E501
        """Update a migration issue  # noqa: E501

        Update the workflow_state of a migration issue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_migration_issue_courses(course_id, content_migration_id, id, workflow_state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str content_migration_id: ID (required)
        :param str id: ID (required)
        :param str workflow_state: Set the workflow_state of the issue. (required)
        :return: MigrationIssue
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_migration_issue_courses_with_http_info(course_id, content_migration_id, id, workflow_state, **kwargs)  # noqa: E501
        else:
            (data) = self.update_migration_issue_courses_with_http_info(course_id, content_migration_id, id, workflow_state, **kwargs)  # noqa: E501
            return data

    def update_migration_issue_courses_with_http_info(self, course_id, content_migration_id, id, workflow_state, **kwargs):  # noqa: E501
        """Update a migration issue  # noqa: E501

        Update the workflow_state of a migration issue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_migration_issue_courses_with_http_info(course_id, content_migration_id, id, workflow_state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str content_migration_id: ID (required)
        :param str id: ID (required)
        :param str workflow_state: Set the workflow_state of the issue. (required)
        :return: MigrationIssue
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'content_migration_id', 'id', 'workflow_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_migration_issue_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `update_migration_issue_courses`")  # noqa: E501
        # verify the required parameter 'content_migration_id' is set
        if self.api_client.client_side_validation and ('content_migration_id' not in params or
                                                       params['content_migration_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `content_migration_id` when calling `update_migration_issue_courses`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_migration_issue_courses`")  # noqa: E501
        # verify the required parameter 'workflow_state' is set
        if self.api_client.client_side_validation and ('workflow_state' not in params or
                                                       params['workflow_state'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `workflow_state` when calling `update_migration_issue_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'content_migration_id' in params:
            path_params['content_migration_id'] = params['content_migration_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'workflow_state' in params:
            form_params.append(('workflow_state', params['workflow_state']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/content_migrations/{content_migration_id}/migration_issues/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MigrationIssue',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_migration_issue_groups(self, group_id, content_migration_id, id, workflow_state, **kwargs):  # noqa: E501
        """Update a migration issue  # noqa: E501

        Update the workflow_state of a migration issue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_migration_issue_groups(group_id, content_migration_id, id, workflow_state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str content_migration_id: ID (required)
        :param str id: ID (required)
        :param str workflow_state: Set the workflow_state of the issue. (required)
        :return: MigrationIssue
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_migration_issue_groups_with_http_info(group_id, content_migration_id, id, workflow_state, **kwargs)  # noqa: E501
        else:
            (data) = self.update_migration_issue_groups_with_http_info(group_id, content_migration_id, id, workflow_state, **kwargs)  # noqa: E501
            return data

    def update_migration_issue_groups_with_http_info(self, group_id, content_migration_id, id, workflow_state, **kwargs):  # noqa: E501
        """Update a migration issue  # noqa: E501

        Update the workflow_state of a migration issue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_migration_issue_groups_with_http_info(group_id, content_migration_id, id, workflow_state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str content_migration_id: ID (required)
        :param str id: ID (required)
        :param str workflow_state: Set the workflow_state of the issue. (required)
        :return: MigrationIssue
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'content_migration_id', 'id', 'workflow_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_migration_issue_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `update_migration_issue_groups`")  # noqa: E501
        # verify the required parameter 'content_migration_id' is set
        if self.api_client.client_side_validation and ('content_migration_id' not in params or
                                                       params['content_migration_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `content_migration_id` when calling `update_migration_issue_groups`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_migration_issue_groups`")  # noqa: E501
        # verify the required parameter 'workflow_state' is set
        if self.api_client.client_side_validation and ('workflow_state' not in params or
                                                       params['workflow_state'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `workflow_state` when calling `update_migration_issue_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'content_migration_id' in params:
            path_params['content_migration_id'] = params['content_migration_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'workflow_state' in params:
            form_params.append(('workflow_state', params['workflow_state']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/content_migrations/{content_migration_id}/migration_issues/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MigrationIssue',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_migration_issue_users(self, user_id, content_migration_id, id, workflow_state, **kwargs):  # noqa: E501
        """Update a migration issue  # noqa: E501

        Update the workflow_state of a migration issue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_migration_issue_users(user_id, content_migration_id, id, workflow_state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str content_migration_id: ID (required)
        :param str id: ID (required)
        :param str workflow_state: Set the workflow_state of the issue. (required)
        :return: MigrationIssue
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_migration_issue_users_with_http_info(user_id, content_migration_id, id, workflow_state, **kwargs)  # noqa: E501
        else:
            (data) = self.update_migration_issue_users_with_http_info(user_id, content_migration_id, id, workflow_state, **kwargs)  # noqa: E501
            return data

    def update_migration_issue_users_with_http_info(self, user_id, content_migration_id, id, workflow_state, **kwargs):  # noqa: E501
        """Update a migration issue  # noqa: E501

        Update the workflow_state of a migration issue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_migration_issue_users_with_http_info(user_id, content_migration_id, id, workflow_state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str content_migration_id: ID (required)
        :param str id: ID (required)
        :param str workflow_state: Set the workflow_state of the issue. (required)
        :return: MigrationIssue
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'content_migration_id', 'id', 'workflow_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_migration_issue_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `update_migration_issue_users`")  # noqa: E501
        # verify the required parameter 'content_migration_id' is set
        if self.api_client.client_side_validation and ('content_migration_id' not in params or
                                                       params['content_migration_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `content_migration_id` when calling `update_migration_issue_users`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_migration_issue_users`")  # noqa: E501
        # verify the required parameter 'workflow_state' is set
        if self.api_client.client_side_validation and ('workflow_state' not in params or
                                                       params['workflow_state'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `workflow_state` when calling `update_migration_issue_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'content_migration_id' in params:
            path_params['content_migration_id'] = params['content_migration_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'workflow_state' in params:
            form_params.append(('workflow_state', params['workflow_state']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/content_migrations/{content_migration_id}/migration_issues/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MigrationIssue',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
