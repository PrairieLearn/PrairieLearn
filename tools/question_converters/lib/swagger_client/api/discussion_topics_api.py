# coding: utf-8

"""

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class DiscussionTopicsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_new_discussion_topic_courses(self, course_id, **kwargs):  # noqa: E501
        """Create a new discussion topic  # noqa: E501

        Create an new discussion topic for the course or group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_new_discussion_topic_courses(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str title: no description
        :param str message: no description
        :param str discussion_type: The type of discussion. Defaults to side_comment or not_threaded if not value is given. Accepted values are 'side_comment', 'not_threaded' for discussions that only allow one level of nested comments, and 'threaded' for fully threaded discussions.
        :param bool published: Whether this topic is published (true) or draft state (false). Only teachers and TAs have the ability to create draft state topics.
        :param Object delayed_post_at: If a timestamp is given, the topic will not be published until that time.
        :param bool allow_rating: Whether or not users can rate entries in this topic.
        :param Object lock_at: If a timestamp is given, the topic will be scheduled to lock at the provided timestamp. If the timestamp is in the past, the topic will be locked.
        :param bool podcast_enabled: If true, the topic will have an associated podcast feed.
        :param bool podcast_has_student_posts: If true, the podcast will include posts from students as well. Implies podcast_enabled.
        :param bool require_initial_post: If true then a user may not respond to other replies until that user has made an initial reply. Defaults to false.
        :param Object assignment: To create an assignment discussion, pass the assignment parameters as a sub-object. See the {api:AssignmentsApiController#create Create an Assignment API} for the available parameters. The name parameter will be ignored, as it's taken from the discussion title. If you want to make a discussion that was an assignment NOT an assignment, pass set_assignment = false as part of the assignment object
        :param bool is_announcement: If true, this topic is an announcement. It will appear in the announcement's section rather than the discussions section. This requires announcment-posting permissions.
        :param bool pinned: If true, this topic will be listed in the \"Pinned Discussion\" section
        :param str position_after: By default, discussions are sorted chronologically by creation date, you can pass the id of another topic to have this one show up after the other when they are listed.
        :param int group_category_id: If present, the topic will become a group discussion assigned to the group.
        :param bool only_graders_can_rate: If true, only graders will be allowed to rate entries.
        :param bool sort_by_rating: If true, entries will be sorted by rating.
        :param file attachment: A multipart/form-data form-field-style attachment. Attachments larger than 1 kilobyte are subject to quota restrictions.
        :param str specific_sections: A comma-separated list of sections ids to which the discussion topic should be made specific to.  If it is not desired to make the discussion topic specific to sections, then this parameter may be omitted or set to \"all\".  Can only be present only on announcements and only those that are for a course (as opposed to a group).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_new_discussion_topic_courses_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_new_discussion_topic_courses_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def create_new_discussion_topic_courses_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Create a new discussion topic  # noqa: E501

        Create an new discussion topic for the course or group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_new_discussion_topic_courses_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str title: no description
        :param str message: no description
        :param str discussion_type: The type of discussion. Defaults to side_comment or not_threaded if not value is given. Accepted values are 'side_comment', 'not_threaded' for discussions that only allow one level of nested comments, and 'threaded' for fully threaded discussions.
        :param bool published: Whether this topic is published (true) or draft state (false). Only teachers and TAs have the ability to create draft state topics.
        :param Object delayed_post_at: If a timestamp is given, the topic will not be published until that time.
        :param bool allow_rating: Whether or not users can rate entries in this topic.
        :param Object lock_at: If a timestamp is given, the topic will be scheduled to lock at the provided timestamp. If the timestamp is in the past, the topic will be locked.
        :param bool podcast_enabled: If true, the topic will have an associated podcast feed.
        :param bool podcast_has_student_posts: If true, the podcast will include posts from students as well. Implies podcast_enabled.
        :param bool require_initial_post: If true then a user may not respond to other replies until that user has made an initial reply. Defaults to false.
        :param Object assignment: To create an assignment discussion, pass the assignment parameters as a sub-object. See the {api:AssignmentsApiController#create Create an Assignment API} for the available parameters. The name parameter will be ignored, as it's taken from the discussion title. If you want to make a discussion that was an assignment NOT an assignment, pass set_assignment = false as part of the assignment object
        :param bool is_announcement: If true, this topic is an announcement. It will appear in the announcement's section rather than the discussions section. This requires announcment-posting permissions.
        :param bool pinned: If true, this topic will be listed in the \"Pinned Discussion\" section
        :param str position_after: By default, discussions are sorted chronologically by creation date, you can pass the id of another topic to have this one show up after the other when they are listed.
        :param int group_category_id: If present, the topic will become a group discussion assigned to the group.
        :param bool only_graders_can_rate: If true, only graders will be allowed to rate entries.
        :param bool sort_by_rating: If true, entries will be sorted by rating.
        :param file attachment: A multipart/form-data form-field-style attachment. Attachments larger than 1 kilobyte are subject to quota restrictions.
        :param str specific_sections: A comma-separated list of sections ids to which the discussion topic should be made specific to.  If it is not desired to make the discussion topic specific to sections, then this parameter may be omitted or set to \"all\".  Can only be present only on announcements and only those that are for a course (as opposed to a group).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'title', 'message', 'discussion_type', 'published', 'delayed_post_at', 'allow_rating', 'lock_at', 'podcast_enabled', 'podcast_has_student_posts', 'require_initial_post', 'assignment', 'is_announcement', 'pinned', 'position_after', 'group_category_id', 'only_graders_can_rate', 'sort_by_rating', 'attachment', 'specific_sections']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_new_discussion_topic_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `create_new_discussion_topic_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'message' in params:
            form_params.append(('message', params['message']))  # noqa: E501
        if 'discussion_type' in params:
            form_params.append(('discussion_type', params['discussion_type']))  # noqa: E501
        if 'published' in params:
            form_params.append(('published', params['published']))  # noqa: E501
        if 'delayed_post_at' in params:
            form_params.append(('delayed_post_at', params['delayed_post_at']))  # noqa: E501
        if 'allow_rating' in params:
            form_params.append(('allow_rating', params['allow_rating']))  # noqa: E501
        if 'lock_at' in params:
            form_params.append(('lock_at', params['lock_at']))  # noqa: E501
        if 'podcast_enabled' in params:
            form_params.append(('podcast_enabled', params['podcast_enabled']))  # noqa: E501
        if 'podcast_has_student_posts' in params:
            form_params.append(('podcast_has_student_posts', params['podcast_has_student_posts']))  # noqa: E501
        if 'require_initial_post' in params:
            form_params.append(('require_initial_post', params['require_initial_post']))  # noqa: E501
        if 'assignment' in params:
            form_params.append(('assignment', params['assignment']))  # noqa: E501
        if 'is_announcement' in params:
            form_params.append(('is_announcement', params['is_announcement']))  # noqa: E501
        if 'pinned' in params:
            form_params.append(('pinned', params['pinned']))  # noqa: E501
        if 'position_after' in params:
            form_params.append(('position_after', params['position_after']))  # noqa: E501
        if 'group_category_id' in params:
            form_params.append(('group_category_id', params['group_category_id']))  # noqa: E501
        if 'only_graders_can_rate' in params:
            form_params.append(('only_graders_can_rate', params['only_graders_can_rate']))  # noqa: E501
        if 'sort_by_rating' in params:
            form_params.append(('sort_by_rating', params['sort_by_rating']))  # noqa: E501
        if 'attachment' in params:
            local_var_files['attachment'] = params['attachment']  # noqa: E501
        if 'specific_sections' in params:
            form_params.append(('specific_sections', params['specific_sections']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_new_discussion_topic_groups(self, group_id, **kwargs):  # noqa: E501
        """Create a new discussion topic  # noqa: E501

        Create an new discussion topic for the course or group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_new_discussion_topic_groups(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str title: no description
        :param str message: no description
        :param str discussion_type: The type of discussion. Defaults to side_comment or not_threaded if not value is given. Accepted values are 'side_comment', 'not_threaded' for discussions that only allow one level of nested comments, and 'threaded' for fully threaded discussions.
        :param bool published: Whether this topic is published (true) or draft state (false). Only teachers and TAs have the ability to create draft state topics.
        :param Object delayed_post_at: If a timestamp is given, the topic will not be published until that time.
        :param bool allow_rating: Whether or not users can rate entries in this topic.
        :param Object lock_at: If a timestamp is given, the topic will be scheduled to lock at the provided timestamp. If the timestamp is in the past, the topic will be locked.
        :param bool podcast_enabled: If true, the topic will have an associated podcast feed.
        :param bool podcast_has_student_posts: If true, the podcast will include posts from students as well. Implies podcast_enabled.
        :param bool require_initial_post: If true then a user may not respond to other replies until that user has made an initial reply. Defaults to false.
        :param Object assignment: To create an assignment discussion, pass the assignment parameters as a sub-object. See the {api:AssignmentsApiController#create Create an Assignment API} for the available parameters. The name parameter will be ignored, as it's taken from the discussion title. If you want to make a discussion that was an assignment NOT an assignment, pass set_assignment = false as part of the assignment object
        :param bool is_announcement: If true, this topic is an announcement. It will appear in the announcement's section rather than the discussions section. This requires announcment-posting permissions.
        :param bool pinned: If true, this topic will be listed in the \"Pinned Discussion\" section
        :param str position_after: By default, discussions are sorted chronologically by creation date, you can pass the id of another topic to have this one show up after the other when they are listed.
        :param int group_category_id: If present, the topic will become a group discussion assigned to the group.
        :param bool only_graders_can_rate: If true, only graders will be allowed to rate entries.
        :param bool sort_by_rating: If true, entries will be sorted by rating.
        :param file attachment: A multipart/form-data form-field-style attachment. Attachments larger than 1 kilobyte are subject to quota restrictions.
        :param str specific_sections: A comma-separated list of sections ids to which the discussion topic should be made specific to.  If it is not desired to make the discussion topic specific to sections, then this parameter may be omitted or set to \"all\".  Can only be present only on announcements and only those that are for a course (as opposed to a group).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_new_discussion_topic_groups_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_new_discussion_topic_groups_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def create_new_discussion_topic_groups_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """Create a new discussion topic  # noqa: E501

        Create an new discussion topic for the course or group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_new_discussion_topic_groups_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str title: no description
        :param str message: no description
        :param str discussion_type: The type of discussion. Defaults to side_comment or not_threaded if not value is given. Accepted values are 'side_comment', 'not_threaded' for discussions that only allow one level of nested comments, and 'threaded' for fully threaded discussions.
        :param bool published: Whether this topic is published (true) or draft state (false). Only teachers and TAs have the ability to create draft state topics.
        :param Object delayed_post_at: If a timestamp is given, the topic will not be published until that time.
        :param bool allow_rating: Whether or not users can rate entries in this topic.
        :param Object lock_at: If a timestamp is given, the topic will be scheduled to lock at the provided timestamp. If the timestamp is in the past, the topic will be locked.
        :param bool podcast_enabled: If true, the topic will have an associated podcast feed.
        :param bool podcast_has_student_posts: If true, the podcast will include posts from students as well. Implies podcast_enabled.
        :param bool require_initial_post: If true then a user may not respond to other replies until that user has made an initial reply. Defaults to false.
        :param Object assignment: To create an assignment discussion, pass the assignment parameters as a sub-object. See the {api:AssignmentsApiController#create Create an Assignment API} for the available parameters. The name parameter will be ignored, as it's taken from the discussion title. If you want to make a discussion that was an assignment NOT an assignment, pass set_assignment = false as part of the assignment object
        :param bool is_announcement: If true, this topic is an announcement. It will appear in the announcement's section rather than the discussions section. This requires announcment-posting permissions.
        :param bool pinned: If true, this topic will be listed in the \"Pinned Discussion\" section
        :param str position_after: By default, discussions are sorted chronologically by creation date, you can pass the id of another topic to have this one show up after the other when they are listed.
        :param int group_category_id: If present, the topic will become a group discussion assigned to the group.
        :param bool only_graders_can_rate: If true, only graders will be allowed to rate entries.
        :param bool sort_by_rating: If true, entries will be sorted by rating.
        :param file attachment: A multipart/form-data form-field-style attachment. Attachments larger than 1 kilobyte are subject to quota restrictions.
        :param str specific_sections: A comma-separated list of sections ids to which the discussion topic should be made specific to.  If it is not desired to make the discussion topic specific to sections, then this parameter may be omitted or set to \"all\".  Can only be present only on announcements and only those that are for a course (as opposed to a group).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'title', 'message', 'discussion_type', 'published', 'delayed_post_at', 'allow_rating', 'lock_at', 'podcast_enabled', 'podcast_has_student_posts', 'require_initial_post', 'assignment', 'is_announcement', 'pinned', 'position_after', 'group_category_id', 'only_graders_can_rate', 'sort_by_rating', 'attachment', 'specific_sections']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_new_discussion_topic_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `create_new_discussion_topic_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'message' in params:
            form_params.append(('message', params['message']))  # noqa: E501
        if 'discussion_type' in params:
            form_params.append(('discussion_type', params['discussion_type']))  # noqa: E501
        if 'published' in params:
            form_params.append(('published', params['published']))  # noqa: E501
        if 'delayed_post_at' in params:
            form_params.append(('delayed_post_at', params['delayed_post_at']))  # noqa: E501
        if 'allow_rating' in params:
            form_params.append(('allow_rating', params['allow_rating']))  # noqa: E501
        if 'lock_at' in params:
            form_params.append(('lock_at', params['lock_at']))  # noqa: E501
        if 'podcast_enabled' in params:
            form_params.append(('podcast_enabled', params['podcast_enabled']))  # noqa: E501
        if 'podcast_has_student_posts' in params:
            form_params.append(('podcast_has_student_posts', params['podcast_has_student_posts']))  # noqa: E501
        if 'require_initial_post' in params:
            form_params.append(('require_initial_post', params['require_initial_post']))  # noqa: E501
        if 'assignment' in params:
            form_params.append(('assignment', params['assignment']))  # noqa: E501
        if 'is_announcement' in params:
            form_params.append(('is_announcement', params['is_announcement']))  # noqa: E501
        if 'pinned' in params:
            form_params.append(('pinned', params['pinned']))  # noqa: E501
        if 'position_after' in params:
            form_params.append(('position_after', params['position_after']))  # noqa: E501
        if 'group_category_id' in params:
            form_params.append(('group_category_id', params['group_category_id']))  # noqa: E501
        if 'only_graders_can_rate' in params:
            form_params.append(('only_graders_can_rate', params['only_graders_can_rate']))  # noqa: E501
        if 'sort_by_rating' in params:
            form_params.append(('sort_by_rating', params['sort_by_rating']))  # noqa: E501
        if 'attachment' in params:
            local_var_files['attachment'] = params['attachment']  # noqa: E501
        if 'specific_sections' in params:
            form_params.append(('specific_sections', params['specific_sections']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_entry_courses(self, course_id, topic_id, id, **kwargs):  # noqa: E501
        """Delete an entry  # noqa: E501

        Delete a discussion entry.  The entry must have been created by the current user, or the current user must have admin rights to the discussion. If the delete is not allowed, a 401 will be returned.  The discussion will be marked deleted, and the user_id and message will be cleared out.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_entry_courses(course_id, topic_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_entry_courses_with_http_info(course_id, topic_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_entry_courses_with_http_info(course_id, topic_id, id, **kwargs)  # noqa: E501
            return data

    def delete_entry_courses_with_http_info(self, course_id, topic_id, id, **kwargs):  # noqa: E501
        """Delete an entry  # noqa: E501

        Delete a discussion entry.  The entry must have been created by the current user, or the current user must have admin rights to the discussion. If the delete is not allowed, a 401 will be returned.  The discussion will be marked deleted, and the user_id and message will be cleared out.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_entry_courses_with_http_info(course_id, topic_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_entry_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `delete_entry_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `delete_entry_courses`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_entry_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_entry_groups(self, group_id, topic_id, id, **kwargs):  # noqa: E501
        """Delete an entry  # noqa: E501

        Delete a discussion entry.  The entry must have been created by the current user, or the current user must have admin rights to the discussion. If the delete is not allowed, a 401 will be returned.  The discussion will be marked deleted, and the user_id and message will be cleared out.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_entry_groups(group_id, topic_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_entry_groups_with_http_info(group_id, topic_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_entry_groups_with_http_info(group_id, topic_id, id, **kwargs)  # noqa: E501
            return data

    def delete_entry_groups_with_http_info(self, group_id, topic_id, id, **kwargs):  # noqa: E501
        """Delete an entry  # noqa: E501

        Delete a discussion entry.  The entry must have been created by the current user, or the current user must have admin rights to the discussion. If the delete is not allowed, a 401 will be returned.  The discussion will be marked deleted, and the user_id and message will be cleared out.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_entry_groups_with_http_info(group_id, topic_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_entry_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `delete_entry_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `delete_entry_groups`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_entry_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_topic_courses(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Delete a topic  # noqa: E501

        Deletes the discussion topic. This will also delete the assignment, if it's an assignment discussion.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_topic_courses(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_topic_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_topic_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
            return data

    def delete_topic_courses_with_http_info(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Delete a topic  # noqa: E501

        Deletes the discussion topic. This will also delete the assignment, if it's an assignment discussion.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_topic_courses_with_http_info(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_topic_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `delete_topic_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `delete_topic_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_topic_groups(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Delete a topic  # noqa: E501

        Deletes the discussion topic. This will also delete the assignment, if it's an assignment discussion.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_topic_groups(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_topic_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_topic_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
            return data

    def delete_topic_groups_with_http_info(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Delete a topic  # noqa: E501

        Deletes the discussion topic. This will also delete the assignment, if it's an assignment discussion.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_topic_groups_with_http_info(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_topic_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `delete_topic_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `delete_topic_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_summary_courses(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Disable summary  # noqa: E501

        Disables the summary for a discussion topic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_summary_courses(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_summary_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.disable_summary_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
            return data

    def disable_summary_courses_with_http_info(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Disable summary  # noqa: E501

        Disables the summary for a discussion topic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_summary_courses_with_http_info(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_summary_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `disable_summary_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `disable_summary_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/summaries/disable', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_summary_groups(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Disable summary  # noqa: E501

        Disables the summary for a discussion topic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_summary_groups(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_summary_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.disable_summary_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
            return data

    def disable_summary_groups_with_http_info(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Disable summary  # noqa: E501

        Disables the summary for a discussion topic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_summary_groups_with_http_info(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_summary_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `disable_summary_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `disable_summary_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/summaries/disable', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def duplicate_discussion_topic_courses(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Duplicate discussion topic  # noqa: E501

        Duplicate a discussion topic according to context (Course/Group)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.duplicate_discussion_topic_courses(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :return: DiscussionTopic
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.duplicate_discussion_topic_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.duplicate_discussion_topic_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
            return data

    def duplicate_discussion_topic_courses_with_http_info(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Duplicate discussion topic  # noqa: E501

        Duplicate a discussion topic according to context (Course/Group)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.duplicate_discussion_topic_courses_with_http_info(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :return: DiscussionTopic
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method duplicate_discussion_topic_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `duplicate_discussion_topic_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `duplicate_discussion_topic_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/duplicate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DiscussionTopic',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def duplicate_discussion_topic_groups(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Duplicate discussion topic  # noqa: E501

        Duplicate a discussion topic according to context (Course/Group)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.duplicate_discussion_topic_groups(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :return: DiscussionTopic
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.duplicate_discussion_topic_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.duplicate_discussion_topic_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
            return data

    def duplicate_discussion_topic_groups_with_http_info(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Duplicate discussion topic  # noqa: E501

        Duplicate a discussion topic according to context (Course/Group)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.duplicate_discussion_topic_groups_with_http_info(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :return: DiscussionTopic
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method duplicate_discussion_topic_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `duplicate_discussion_topic_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `duplicate_discussion_topic_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/duplicate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DiscussionTopic',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_full_topic_courses(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Get the full topic  # noqa: E501

        Return a cached structure of the discussion topic, containing all entries, their authors, and their message bodies.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  In some rare situations, this cached structure may not be available yet. In that case, the server will respond with a 503 error, and the caller should try again soon.  The response is an object containing the following keys: * \"participants\": A list of summary information on users who have posted to   the discussion. Each value is an object containing their id, display_name,   and avatar_url. * \"unread_entries\": A list of entry ids that are unread by the current   user. this implies that any entry not in this list is read. * \"entry_ratings\": A map of entry ids to ratings by the current user. Entries   not in this list have no rating. Only populated if rating is enabled. * \"forced_entries\": A list of entry ids that have forced_read_state set to   true. This flag is meant to indicate the entry's read_state has been   manually set to 'unread' by the user, so the entry should not be   automatically marked as read. * \"view\": A threaded view of all the entries in the discussion, containing   the id, user_id, and message. * \"new_entries\": Because this view is eventually consistent, it's possible   that newly created or updated entries won't yet be reflected in the view.   If the application wants to also get a flat list of all entries not yet   reflected in the view, pass include_new_entries=1 to the request and this   array of entries will be returned. These entries are returned in a flat   array, in ascending created_at order.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_full_topic_courses(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_full_topic_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_full_topic_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
            return data

    def get_full_topic_courses_with_http_info(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Get the full topic  # noqa: E501

        Return a cached structure of the discussion topic, containing all entries, their authors, and their message bodies.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  In some rare situations, this cached structure may not be available yet. In that case, the server will respond with a 503 error, and the caller should try again soon.  The response is an object containing the following keys: * \"participants\": A list of summary information on users who have posted to   the discussion. Each value is an object containing their id, display_name,   and avatar_url. * \"unread_entries\": A list of entry ids that are unread by the current   user. this implies that any entry not in this list is read. * \"entry_ratings\": A map of entry ids to ratings by the current user. Entries   not in this list have no rating. Only populated if rating is enabled. * \"forced_entries\": A list of entry ids that have forced_read_state set to   true. This flag is meant to indicate the entry's read_state has been   manually set to 'unread' by the user, so the entry should not be   automatically marked as read. * \"view\": A threaded view of all the entries in the discussion, containing   the id, user_id, and message. * \"new_entries\": Because this view is eventually consistent, it's possible   that newly created or updated entries won't yet be reflected in the view.   If the application wants to also get a flat list of all entries not yet   reflected in the view, pass include_new_entries=1 to the request and this   array of entries will be returned. These entries are returned in a flat   array, in ascending created_at order.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_full_topic_courses_with_http_info(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_full_topic_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `get_full_topic_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `get_full_topic_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/view', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_full_topic_groups(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Get the full topic  # noqa: E501

        Return a cached structure of the discussion topic, containing all entries, their authors, and their message bodies.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  In some rare situations, this cached structure may not be available yet. In that case, the server will respond with a 503 error, and the caller should try again soon.  The response is an object containing the following keys: * \"participants\": A list of summary information on users who have posted to   the discussion. Each value is an object containing their id, display_name,   and avatar_url. * \"unread_entries\": A list of entry ids that are unread by the current   user. this implies that any entry not in this list is read. * \"entry_ratings\": A map of entry ids to ratings by the current user. Entries   not in this list have no rating. Only populated if rating is enabled. * \"forced_entries\": A list of entry ids that have forced_read_state set to   true. This flag is meant to indicate the entry's read_state has been   manually set to 'unread' by the user, so the entry should not be   automatically marked as read. * \"view\": A threaded view of all the entries in the discussion, containing   the id, user_id, and message. * \"new_entries\": Because this view is eventually consistent, it's possible   that newly created or updated entries won't yet be reflected in the view.   If the application wants to also get a flat list of all entries not yet   reflected in the view, pass include_new_entries=1 to the request and this   array of entries will be returned. These entries are returned in a flat   array, in ascending created_at order.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_full_topic_groups(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_full_topic_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_full_topic_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
            return data

    def get_full_topic_groups_with_http_info(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Get the full topic  # noqa: E501

        Return a cached structure of the discussion topic, containing all entries, their authors, and their message bodies.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  In some rare situations, this cached structure may not be available yet. In that case, the server will respond with a 503 error, and the caller should try again soon.  The response is an object containing the following keys: * \"participants\": A list of summary information on users who have posted to   the discussion. Each value is an object containing their id, display_name,   and avatar_url. * \"unread_entries\": A list of entry ids that are unread by the current   user. this implies that any entry not in this list is read. * \"entry_ratings\": A map of entry ids to ratings by the current user. Entries   not in this list have no rating. Only populated if rating is enabled. * \"forced_entries\": A list of entry ids that have forced_read_state set to   true. This flag is meant to indicate the entry's read_state has been   manually set to 'unread' by the user, so the entry should not be   automatically marked as read. * \"view\": A threaded view of all the entries in the discussion, containing   the id, user_id, and message. * \"new_entries\": Because this view is eventually consistent, it's possible   that newly created or updated entries won't yet be reflected in the view.   If the application wants to also get a flat list of all entries not yet   reflected in the view, pass include_new_entries=1 to the request and this   array of entries will be returned. These entries are returned in a flat   array, in ascending created_at order.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_full_topic_groups_with_http_info(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_full_topic_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `get_full_topic_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `get_full_topic_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/view', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_single_topic_courses(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Get a single topic  # noqa: E501

        Returns data on an individual discussion topic. See the List action for the response formatting.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_single_topic_courses(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param list[str] include: If \"all_dates\" is passed, all dates associated with graded discussions' assignments will be included. if \"sections\" is passed, includes the course sections that are associated with the topic, if the topic is specific to certain sections of the course. If \"sections_user_count\" is passed, then:   (a) If sections were asked for *and* the topic is specific to certain       course sections, includes the number of users in each       section. (as part of the section json asked for above)   (b) Else, includes at the root level the total number of users in the       topic's context (group or course) that the topic applies to. If \"overrides\" is passed, the overrides for the assignment will be included
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_single_topic_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_single_topic_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
            return data

    def get_single_topic_courses_with_http_info(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Get a single topic  # noqa: E501

        Returns data on an individual discussion topic. See the List action for the response formatting.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_single_topic_courses_with_http_info(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param list[str] include: If \"all_dates\" is passed, all dates associated with graded discussions' assignments will be included. if \"sections\" is passed, includes the course sections that are associated with the topic, if the topic is specific to certain sections of the course. If \"sections_user_count\" is passed, then:   (a) If sections were asked for *and* the topic is specific to certain       course sections, includes the number of users in each       section. (as part of the section json asked for above)   (b) Else, includes at the root level the total number of users in the       topic's context (group or course) that the topic applies to. If \"overrides\" is passed, the overrides for the assignment will be included
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id', 'include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_single_topic_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `get_single_topic_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `get_single_topic_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_single_topic_groups(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Get a single topic  # noqa: E501

        Returns data on an individual discussion topic. See the List action for the response formatting.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_single_topic_groups(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param list[str] include: If \"all_dates\" is passed, all dates associated with graded discussions' assignments will be included. if \"sections\" is passed, includes the course sections that are associated with the topic, if the topic is specific to certain sections of the course. If \"sections_user_count\" is passed, then:   (a) If sections were asked for *and* the topic is specific to certain       course sections, includes the number of users in each       section. (as part of the section json asked for above)   (b) Else, includes at the root level the total number of users in the       topic's context (group or course) that the topic applies to. If \"overrides\" is passed, the overrides for the assignment will be included
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_single_topic_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_single_topic_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
            return data

    def get_single_topic_groups_with_http_info(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Get a single topic  # noqa: E501

        Returns data on an individual discussion topic. See the List action for the response formatting.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_single_topic_groups_with_http_info(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param list[str] include: If \"all_dates\" is passed, all dates associated with graded discussions' assignments will be included. if \"sections\" is passed, includes the course sections that are associated with the topic, if the topic is specific to certain sections of the course. If \"sections_user_count\" is passed, then:   (a) If sections were asked for *and* the topic is specific to certain       course sections, includes the number of users in each       section. (as part of the section json asked for above)   (b) Else, includes at the root level the total number of users in the       topic's context (group or course) that the topic applies to. If \"overrides\" is passed, the overrides for the assignment will be included
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id', 'include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_single_topic_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `get_single_topic_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `get_single_topic_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_discussion_topics_courses(self, course_id, **kwargs):  # noqa: E501
        """List discussion topics  # noqa: E501

        Returns the paginated list of discussion topics for this course or group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_discussion_topics_courses(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param list[str] include: If \"all_dates\" is passed, all dates associated with graded discussions' assignments will be included. if \"sections\" is passed, includes the course sections that are associated with the topic, if the topic is specific to certain sections of the course. If \"sections_user_count\" is passed, then:   (a) If sections were asked for *and* the topic is specific to certain       course sections, includes the number of users in each       section. (as part of the section json asked for above)   (b) Else, includes at the root level the total number of users in the       topic's context (group or course) that the topic applies to. If \"overrides\" is passed, the overrides for the assignment will be included
        :param str order_by: Determines the order of the discussion topic list. Defaults to \"position\".
        :param str scope: Only return discussion topics in the given state(s). Defaults to including all topics. Filtering is done after pagination, so pages may be smaller than requested if topics are filtered. Can pass multiple states as comma separated string.
        :param bool only_announcements: Return announcements instead of discussion topics. Defaults to false
        :param str filter_by: The state of the discussion topic to return. Currently only supports unread state.
        :param str search_term: The partial title of the discussion topics to match and return.
        :param bool exclude_context_module_locked_topics: For students, exclude topics that are locked by module progression. Defaults to false.
        :return: list[DiscussionTopic]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_discussion_topics_courses_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_discussion_topics_courses_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def list_discussion_topics_courses_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """List discussion topics  # noqa: E501

        Returns the paginated list of discussion topics for this course or group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_discussion_topics_courses_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param list[str] include: If \"all_dates\" is passed, all dates associated with graded discussions' assignments will be included. if \"sections\" is passed, includes the course sections that are associated with the topic, if the topic is specific to certain sections of the course. If \"sections_user_count\" is passed, then:   (a) If sections were asked for *and* the topic is specific to certain       course sections, includes the number of users in each       section. (as part of the section json asked for above)   (b) Else, includes at the root level the total number of users in the       topic's context (group or course) that the topic applies to. If \"overrides\" is passed, the overrides for the assignment will be included
        :param str order_by: Determines the order of the discussion topic list. Defaults to \"position\".
        :param str scope: Only return discussion topics in the given state(s). Defaults to including all topics. Filtering is done after pagination, so pages may be smaller than requested if topics are filtered. Can pass multiple states as comma separated string.
        :param bool only_announcements: Return announcements instead of discussion topics. Defaults to false
        :param str filter_by: The state of the discussion topic to return. Currently only supports unread state.
        :param str search_term: The partial title of the discussion topics to match and return.
        :param bool exclude_context_module_locked_topics: For students, exclude topics that are locked by module progression. Defaults to false.
        :return: list[DiscussionTopic]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'include', 'order_by', 'scope', 'only_announcements', 'filter_by', 'search_term', 'exclude_context_module_locked_topics']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_discussion_topics_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `list_discussion_topics_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'scope' in params:
            query_params.append(('scope', params['scope']))  # noqa: E501
        if 'only_announcements' in params:
            query_params.append(('only_announcements', params['only_announcements']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filter_by', params['filter_by']))  # noqa: E501
        if 'search_term' in params:
            query_params.append(('search_term', params['search_term']))  # noqa: E501
        if 'exclude_context_module_locked_topics' in params:
            query_params.append(('exclude_context_module_locked_topics', params['exclude_context_module_locked_topics']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DiscussionTopic]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_discussion_topics_groups(self, group_id, **kwargs):  # noqa: E501
        """List discussion topics  # noqa: E501

        Returns the paginated list of discussion topics for this course or group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_discussion_topics_groups(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param list[str] include: If \"all_dates\" is passed, all dates associated with graded discussions' assignments will be included. if \"sections\" is passed, includes the course sections that are associated with the topic, if the topic is specific to certain sections of the course. If \"sections_user_count\" is passed, then:   (a) If sections were asked for *and* the topic is specific to certain       course sections, includes the number of users in each       section. (as part of the section json asked for above)   (b) Else, includes at the root level the total number of users in the       topic's context (group or course) that the topic applies to. If \"overrides\" is passed, the overrides for the assignment will be included
        :param str order_by: Determines the order of the discussion topic list. Defaults to \"position\".
        :param str scope: Only return discussion topics in the given state(s). Defaults to including all topics. Filtering is done after pagination, so pages may be smaller than requested if topics are filtered. Can pass multiple states as comma separated string.
        :param bool only_announcements: Return announcements instead of discussion topics. Defaults to false
        :param str filter_by: The state of the discussion topic to return. Currently only supports unread state.
        :param str search_term: The partial title of the discussion topics to match and return.
        :param bool exclude_context_module_locked_topics: For students, exclude topics that are locked by module progression. Defaults to false.
        :return: list[DiscussionTopic]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_discussion_topics_groups_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_discussion_topics_groups_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def list_discussion_topics_groups_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """List discussion topics  # noqa: E501

        Returns the paginated list of discussion topics for this course or group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_discussion_topics_groups_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param list[str] include: If \"all_dates\" is passed, all dates associated with graded discussions' assignments will be included. if \"sections\" is passed, includes the course sections that are associated with the topic, if the topic is specific to certain sections of the course. If \"sections_user_count\" is passed, then:   (a) If sections were asked for *and* the topic is specific to certain       course sections, includes the number of users in each       section. (as part of the section json asked for above)   (b) Else, includes at the root level the total number of users in the       topic's context (group or course) that the topic applies to. If \"overrides\" is passed, the overrides for the assignment will be included
        :param str order_by: Determines the order of the discussion topic list. Defaults to \"position\".
        :param str scope: Only return discussion topics in the given state(s). Defaults to including all topics. Filtering is done after pagination, so pages may be smaller than requested if topics are filtered. Can pass multiple states as comma separated string.
        :param bool only_announcements: Return announcements instead of discussion topics. Defaults to false
        :param str filter_by: The state of the discussion topic to return. Currently only supports unread state.
        :param str search_term: The partial title of the discussion topics to match and return.
        :param bool exclude_context_module_locked_topics: For students, exclude topics that are locked by module progression. Defaults to false.
        :return: list[DiscussionTopic]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'include', 'order_by', 'scope', 'only_announcements', 'filter_by', 'search_term', 'exclude_context_module_locked_topics']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_discussion_topics_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `list_discussion_topics_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'scope' in params:
            query_params.append(('scope', params['scope']))  # noqa: E501
        if 'only_announcements' in params:
            query_params.append(('only_announcements', params['only_announcements']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filter_by', params['filter_by']))  # noqa: E501
        if 'search_term' in params:
            query_params.append(('search_term', params['search_term']))  # noqa: E501
        if 'exclude_context_module_locked_topics' in params:
            query_params.append(('exclude_context_module_locked_topics', params['exclude_context_module_locked_topics']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DiscussionTopic]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_entries_courses(self, course_id, topic_id, **kwargs):  # noqa: E501
        """List entries  # noqa: E501

        Retrieve a paginated list of discussion entries, given a list of ids.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_entries_courses(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param list[str] ids: A list of entry ids to retrieve. Entries will be returned in id order, smallest id first.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_entries_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_entries_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
            return data

    def list_entries_courses_with_http_info(self, course_id, topic_id, **kwargs):  # noqa: E501
        """List entries  # noqa: E501

        Retrieve a paginated list of discussion entries, given a list of ids.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_entries_courses_with_http_info(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param list[str] ids: A list of entry ids to retrieve. Entries will be returned in id order, smallest id first.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id', 'ids']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_entries_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `list_entries_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `list_entries_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []
        if 'ids' in params:
            query_params.append(('ids', params['ids']))  # noqa: E501
            collection_formats['ids'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/entry_list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_entries_groups(self, group_id, topic_id, **kwargs):  # noqa: E501
        """List entries  # noqa: E501

        Retrieve a paginated list of discussion entries, given a list of ids.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_entries_groups(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param list[str] ids: A list of entry ids to retrieve. Entries will be returned in id order, smallest id first.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_entries_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_entries_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
            return data

    def list_entries_groups_with_http_info(self, group_id, topic_id, **kwargs):  # noqa: E501
        """List entries  # noqa: E501

        Retrieve a paginated list of discussion entries, given a list of ids.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_entries_groups_with_http_info(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param list[str] ids: A list of entry ids to retrieve. Entries will be returned in id order, smallest id first.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id', 'ids']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_entries_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `list_entries_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `list_entries_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []
        if 'ids' in params:
            query_params.append(('ids', params['ids']))  # noqa: E501
            collection_formats['ids'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/entry_list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_entry_replies_courses(self, course_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """List entry replies  # noqa: E501

        Retrieve the (paginated) replies to a top-level entry in a discussion topic.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  Ordering of returned entries is newest-first by creation timestamp.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_entry_replies_courses(course_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_entry_replies_courses_with_http_info(course_id, topic_id, entry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_entry_replies_courses_with_http_info(course_id, topic_id, entry_id, **kwargs)  # noqa: E501
            return data

    def list_entry_replies_courses_with_http_info(self, course_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """List entry replies  # noqa: E501

        Retrieve the (paginated) replies to a top-level entry in a discussion topic.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  Ordering of returned entries is newest-first by creation timestamp.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_entry_replies_courses_with_http_info(course_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id', 'entry_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_entry_replies_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `list_entry_replies_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `list_entry_replies_courses`")  # noqa: E501
        # verify the required parameter 'entry_id' is set
        if self.api_client.client_side_validation and ('entry_id' not in params or
                                                       params['entry_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `entry_id` when calling `list_entry_replies_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501
        if 'entry_id' in params:
            path_params['entry_id'] = params['entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_entry_replies_groups(self, group_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """List entry replies  # noqa: E501

        Retrieve the (paginated) replies to a top-level entry in a discussion topic.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  Ordering of returned entries is newest-first by creation timestamp.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_entry_replies_groups(group_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_entry_replies_groups_with_http_info(group_id, topic_id, entry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_entry_replies_groups_with_http_info(group_id, topic_id, entry_id, **kwargs)  # noqa: E501
            return data

    def list_entry_replies_groups_with_http_info(self, group_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """List entry replies  # noqa: E501

        Retrieve the (paginated) replies to a top-level entry in a discussion topic.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  Ordering of returned entries is newest-first by creation timestamp.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_entry_replies_groups_with_http_info(group_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id', 'entry_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_entry_replies_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `list_entry_replies_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `list_entry_replies_groups`")  # noqa: E501
        # verify the required parameter 'entry_id' is set
        if self.api_client.client_side_validation and ('entry_id' not in params or
                                                       params['entry_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `entry_id` when calling `list_entry_replies_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501
        if 'entry_id' in params:
            path_params['entry_id'] = params['entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_topic_entries_courses(self, course_id, topic_id, **kwargs):  # noqa: E501
        """List topic entries  # noqa: E501

        Retrieve the (paginated) top-level entries in a discussion topic.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  Will include the 10 most recent replies, if any, for each entry returned.  If the topic is a root topic with children corresponding to groups of a group assignment, entries from those subtopics for which the user belongs to the corresponding group will be returned.  Ordering of returned entries is newest-first by posting timestamp (reply activity is ignored).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_topic_entries_courses(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_topic_entries_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_topic_entries_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
            return data

    def list_topic_entries_courses_with_http_info(self, course_id, topic_id, **kwargs):  # noqa: E501
        """List topic entries  # noqa: E501

        Retrieve the (paginated) top-level entries in a discussion topic.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  Will include the 10 most recent replies, if any, for each entry returned.  If the topic is a root topic with children corresponding to groups of a group assignment, entries from those subtopics for which the user belongs to the corresponding group will be returned.  Ordering of returned entries is newest-first by posting timestamp (reply activity is ignored).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_topic_entries_courses_with_http_info(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_topic_entries_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `list_topic_entries_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `list_topic_entries_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_topic_entries_groups(self, group_id, topic_id, **kwargs):  # noqa: E501
        """List topic entries  # noqa: E501

        Retrieve the (paginated) top-level entries in a discussion topic.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  Will include the 10 most recent replies, if any, for each entry returned.  If the topic is a root topic with children corresponding to groups of a group assignment, entries from those subtopics for which the user belongs to the corresponding group will be returned.  Ordering of returned entries is newest-first by posting timestamp (reply activity is ignored).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_topic_entries_groups(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_topic_entries_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_topic_entries_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
            return data

    def list_topic_entries_groups_with_http_info(self, group_id, topic_id, **kwargs):  # noqa: E501
        """List topic entries  # noqa: E501

        Retrieve the (paginated) top-level entries in a discussion topic.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  Will include the 10 most recent replies, if any, for each entry returned.  If the topic is a root topic with children corresponding to groups of a group assignment, entries from those subtopics for which the user belongs to the corresponding group will be returned.  Ordering of returned entries is newest-first by posting timestamp (reply activity is ignored).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_topic_entries_groups_with_http_info(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_topic_entries_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `list_topic_entries_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `list_topic_entries_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mark_all_entries_as_read_courses(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Mark all entries as read  # noqa: E501

        Mark the discussion topic and all its entries as read.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_all_entries_as_read_courses(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param bool forced_read_state: A boolean value to set all of the entries' forced_read_state. No change is made if this argument is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mark_all_entries_as_read_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.mark_all_entries_as_read_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
            return data

    def mark_all_entries_as_read_courses_with_http_info(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Mark all entries as read  # noqa: E501

        Mark the discussion topic and all its entries as read.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_all_entries_as_read_courses_with_http_info(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param bool forced_read_state: A boolean value to set all of the entries' forced_read_state. No change is made if this argument is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id', 'forced_read_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_all_entries_as_read_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `mark_all_entries_as_read_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `mark_all_entries_as_read_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'forced_read_state' in params:
            form_params.append(('forced_read_state', params['forced_read_state']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/read_all', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mark_all_entries_as_read_groups(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Mark all entries as read  # noqa: E501

        Mark the discussion topic and all its entries as read.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_all_entries_as_read_groups(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param bool forced_read_state: A boolean value to set all of the entries' forced_read_state. No change is made if this argument is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mark_all_entries_as_read_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.mark_all_entries_as_read_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
            return data

    def mark_all_entries_as_read_groups_with_http_info(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Mark all entries as read  # noqa: E501

        Mark the discussion topic and all its entries as read.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_all_entries_as_read_groups_with_http_info(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param bool forced_read_state: A boolean value to set all of the entries' forced_read_state. No change is made if this argument is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id', 'forced_read_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_all_entries_as_read_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `mark_all_entries_as_read_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `mark_all_entries_as_read_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'forced_read_state' in params:
            form_params.append(('forced_read_state', params['forced_read_state']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/read_all', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mark_all_entries_as_unread_courses(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Mark all entries as unread  # noqa: E501

        Mark the discussion topic and all its entries as unread.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_all_entries_as_unread_courses(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param bool forced_read_state: A boolean value to set all of the entries' forced_read_state. No change is made if this argument is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mark_all_entries_as_unread_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.mark_all_entries_as_unread_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
            return data

    def mark_all_entries_as_unread_courses_with_http_info(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Mark all entries as unread  # noqa: E501

        Mark the discussion topic and all its entries as unread.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_all_entries_as_unread_courses_with_http_info(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param bool forced_read_state: A boolean value to set all of the entries' forced_read_state. No change is made if this argument is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id', 'forced_read_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_all_entries_as_unread_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `mark_all_entries_as_unread_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `mark_all_entries_as_unread_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []
        if 'forced_read_state' in params:
            query_params.append(('forced_read_state', params['forced_read_state']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/read_all', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mark_all_entries_as_unread_groups(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Mark all entries as unread  # noqa: E501

        Mark the discussion topic and all its entries as unread.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_all_entries_as_unread_groups(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param bool forced_read_state: A boolean value to set all of the entries' forced_read_state. No change is made if this argument is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mark_all_entries_as_unread_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.mark_all_entries_as_unread_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
            return data

    def mark_all_entries_as_unread_groups_with_http_info(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Mark all entries as unread  # noqa: E501

        Mark the discussion topic and all its entries as unread.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_all_entries_as_unread_groups_with_http_info(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param bool forced_read_state: A boolean value to set all of the entries' forced_read_state. No change is made if this argument is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id', 'forced_read_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_all_entries_as_unread_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `mark_all_entries_as_unread_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `mark_all_entries_as_unread_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []
        if 'forced_read_state' in params:
            query_params.append(('forced_read_state', params['forced_read_state']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/read_all', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mark_all_topic_as_read_courses(self, course_id, **kwargs):  # noqa: E501
        """Mark all topic as read  # noqa: E501

        Mark the initial text of all the discussion topics as read in  the context.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_all_topic_as_read_courses(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mark_all_topic_as_read_courses_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.mark_all_topic_as_read_courses_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def mark_all_topic_as_read_courses_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Mark all topic as read  # noqa: E501

        Mark the initial text of all the discussion topics as read in  the context.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_all_topic_as_read_courses_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_all_topic_as_read_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `mark_all_topic_as_read_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/read_all', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mark_all_topic_as_read_groups(self, group_id, **kwargs):  # noqa: E501
        """Mark all topic as read  # noqa: E501

        Mark the initial text of all the discussion topics as read in  the context.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_all_topic_as_read_groups(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mark_all_topic_as_read_groups_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.mark_all_topic_as_read_groups_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def mark_all_topic_as_read_groups_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """Mark all topic as read  # noqa: E501

        Mark the initial text of all the discussion topics as read in  the context.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_all_topic_as_read_groups_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_all_topic_as_read_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `mark_all_topic_as_read_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/read_all', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mark_entry_as_read_courses(self, course_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """Mark entry as read  # noqa: E501

        Mark a discussion entry as read.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_entry_as_read_courses(course_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :param bool forced_read_state: A boolean value to set the entry's forced_read_state. No change is made if this argument is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mark_entry_as_read_courses_with_http_info(course_id, topic_id, entry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.mark_entry_as_read_courses_with_http_info(course_id, topic_id, entry_id, **kwargs)  # noqa: E501
            return data

    def mark_entry_as_read_courses_with_http_info(self, course_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """Mark entry as read  # noqa: E501

        Mark a discussion entry as read.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_entry_as_read_courses_with_http_info(course_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :param bool forced_read_state: A boolean value to set the entry's forced_read_state. No change is made if this argument is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id', 'entry_id', 'forced_read_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_entry_as_read_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `mark_entry_as_read_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `mark_entry_as_read_courses`")  # noqa: E501
        # verify the required parameter 'entry_id' is set
        if self.api_client.client_side_validation and ('entry_id' not in params or
                                                       params['entry_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `entry_id` when calling `mark_entry_as_read_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501
        if 'entry_id' in params:
            path_params['entry_id'] = params['entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'forced_read_state' in params:
            form_params.append(('forced_read_state', params['forced_read_state']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/read', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mark_entry_as_read_groups(self, group_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """Mark entry as read  # noqa: E501

        Mark a discussion entry as read.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_entry_as_read_groups(group_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :param bool forced_read_state: A boolean value to set the entry's forced_read_state. No change is made if this argument is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mark_entry_as_read_groups_with_http_info(group_id, topic_id, entry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.mark_entry_as_read_groups_with_http_info(group_id, topic_id, entry_id, **kwargs)  # noqa: E501
            return data

    def mark_entry_as_read_groups_with_http_info(self, group_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """Mark entry as read  # noqa: E501

        Mark a discussion entry as read.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_entry_as_read_groups_with_http_info(group_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :param bool forced_read_state: A boolean value to set the entry's forced_read_state. No change is made if this argument is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id', 'entry_id', 'forced_read_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_entry_as_read_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `mark_entry_as_read_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `mark_entry_as_read_groups`")  # noqa: E501
        # verify the required parameter 'entry_id' is set
        if self.api_client.client_side_validation and ('entry_id' not in params or
                                                       params['entry_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `entry_id` when calling `mark_entry_as_read_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501
        if 'entry_id' in params:
            path_params['entry_id'] = params['entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'forced_read_state' in params:
            form_params.append(('forced_read_state', params['forced_read_state']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/read', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mark_entry_as_unread_courses(self, course_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """Mark entry as unread  # noqa: E501

        Mark a discussion entry as unread.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_entry_as_unread_courses(course_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :param bool forced_read_state: A boolean value to set the entry's forced_read_state. No change is made if this argument is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mark_entry_as_unread_courses_with_http_info(course_id, topic_id, entry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.mark_entry_as_unread_courses_with_http_info(course_id, topic_id, entry_id, **kwargs)  # noqa: E501
            return data

    def mark_entry_as_unread_courses_with_http_info(self, course_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """Mark entry as unread  # noqa: E501

        Mark a discussion entry as unread.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_entry_as_unread_courses_with_http_info(course_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :param bool forced_read_state: A boolean value to set the entry's forced_read_state. No change is made if this argument is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id', 'entry_id', 'forced_read_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_entry_as_unread_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `mark_entry_as_unread_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `mark_entry_as_unread_courses`")  # noqa: E501
        # verify the required parameter 'entry_id' is set
        if self.api_client.client_side_validation and ('entry_id' not in params or
                                                       params['entry_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `entry_id` when calling `mark_entry_as_unread_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501
        if 'entry_id' in params:
            path_params['entry_id'] = params['entry_id']  # noqa: E501

        query_params = []
        if 'forced_read_state' in params:
            query_params.append(('forced_read_state', params['forced_read_state']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/read', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mark_entry_as_unread_groups(self, group_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """Mark entry as unread  # noqa: E501

        Mark a discussion entry as unread.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_entry_as_unread_groups(group_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :param bool forced_read_state: A boolean value to set the entry's forced_read_state. No change is made if this argument is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mark_entry_as_unread_groups_with_http_info(group_id, topic_id, entry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.mark_entry_as_unread_groups_with_http_info(group_id, topic_id, entry_id, **kwargs)  # noqa: E501
            return data

    def mark_entry_as_unread_groups_with_http_info(self, group_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """Mark entry as unread  # noqa: E501

        Mark a discussion entry as unread.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_entry_as_unread_groups_with_http_info(group_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :param bool forced_read_state: A boolean value to set the entry's forced_read_state. No change is made if this argument is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id', 'entry_id', 'forced_read_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_entry_as_unread_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `mark_entry_as_unread_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `mark_entry_as_unread_groups`")  # noqa: E501
        # verify the required parameter 'entry_id' is set
        if self.api_client.client_side_validation and ('entry_id' not in params or
                                                       params['entry_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `entry_id` when calling `mark_entry_as_unread_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501
        if 'entry_id' in params:
            path_params['entry_id'] = params['entry_id']  # noqa: E501

        query_params = []
        if 'forced_read_state' in params:
            query_params.append(('forced_read_state', params['forced_read_state']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/read', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mark_topic_as_read_courses(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Mark topic as read  # noqa: E501

        Mark the initial text of the discussion topic as read.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_topic_as_read_courses(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mark_topic_as_read_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.mark_topic_as_read_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
            return data

    def mark_topic_as_read_courses_with_http_info(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Mark topic as read  # noqa: E501

        Mark the initial text of the discussion topic as read.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_topic_as_read_courses_with_http_info(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_topic_as_read_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `mark_topic_as_read_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `mark_topic_as_read_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/read', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mark_topic_as_read_groups(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Mark topic as read  # noqa: E501

        Mark the initial text of the discussion topic as read.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_topic_as_read_groups(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mark_topic_as_read_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.mark_topic_as_read_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
            return data

    def mark_topic_as_read_groups_with_http_info(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Mark topic as read  # noqa: E501

        Mark the initial text of the discussion topic as read.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_topic_as_read_groups_with_http_info(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_topic_as_read_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `mark_topic_as_read_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `mark_topic_as_read_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/read', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mark_topic_as_unread_courses(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Mark topic as unread  # noqa: E501

        Mark the initial text of the discussion topic as unread.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_topic_as_unread_courses(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mark_topic_as_unread_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.mark_topic_as_unread_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
            return data

    def mark_topic_as_unread_courses_with_http_info(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Mark topic as unread  # noqa: E501

        Mark the initial text of the discussion topic as unread.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_topic_as_unread_courses_with_http_info(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_topic_as_unread_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `mark_topic_as_unread_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `mark_topic_as_unread_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/read', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mark_topic_as_unread_groups(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Mark topic as unread  # noqa: E501

        Mark the initial text of the discussion topic as unread.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_topic_as_unread_groups(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mark_topic_as_unread_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.mark_topic_as_unread_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
            return data

    def mark_topic_as_unread_groups_with_http_info(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Mark topic as unread  # noqa: E501

        Mark the initial text of the discussion topic as unread.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_topic_as_unread_groups_with_http_info(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_topic_as_unread_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `mark_topic_as_unread_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `mark_topic_as_unread_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/read', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_entry_courses(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Post an entry  # noqa: E501

        Create a new entry in a discussion topic. Returns a json representation of the created entry (see documentation for 'entries' method) on success.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_entry_courses(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str message: The body of the entry.
        :param str attachment: a multipart/form-data form-field-style attachment. Attachments larger than 1 kilobyte are subject to quota restrictions.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_entry_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_entry_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
            return data

    def post_entry_courses_with_http_info(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Post an entry  # noqa: E501

        Create a new entry in a discussion topic. Returns a json representation of the created entry (see documentation for 'entries' method) on success.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_entry_courses_with_http_info(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str message: The body of the entry.
        :param str attachment: a multipart/form-data form-field-style attachment. Attachments larger than 1 kilobyte are subject to quota restrictions.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id', 'message', 'attachment']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_entry_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `post_entry_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `post_entry_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'message' in params:
            form_params.append(('message', params['message']))  # noqa: E501
        if 'attachment' in params:
            form_params.append(('attachment', params['attachment']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_entry_groups(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Post an entry  # noqa: E501

        Create a new entry in a discussion topic. Returns a json representation of the created entry (see documentation for 'entries' method) on success.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_entry_groups(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str message: The body of the entry.
        :param str attachment: a multipart/form-data form-field-style attachment. Attachments larger than 1 kilobyte are subject to quota restrictions.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_entry_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_entry_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
            return data

    def post_entry_groups_with_http_info(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Post an entry  # noqa: E501

        Create a new entry in a discussion topic. Returns a json representation of the created entry (see documentation for 'entries' method) on success.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_entry_groups_with_http_info(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str message: The body of the entry.
        :param str attachment: a multipart/form-data form-field-style attachment. Attachments larger than 1 kilobyte are subject to quota restrictions.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id', 'message', 'attachment']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_entry_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `post_entry_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `post_entry_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'message' in params:
            form_params.append(('message', params['message']))  # noqa: E501
        if 'attachment' in params:
            form_params.append(('attachment', params['attachment']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_reply_courses(self, course_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """Post a reply  # noqa: E501

        Add a reply to an entry in a discussion topic. Returns a json representation of the created reply (see documentation for 'replies' method) on success.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_reply_courses(course_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :param str message: The body of the entry.
        :param str attachment: a multipart/form-data form-field-style attachment. Attachments larger than 1 kilobyte are subject to quota restrictions.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_reply_courses_with_http_info(course_id, topic_id, entry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_reply_courses_with_http_info(course_id, topic_id, entry_id, **kwargs)  # noqa: E501
            return data

    def post_reply_courses_with_http_info(self, course_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """Post a reply  # noqa: E501

        Add a reply to an entry in a discussion topic. Returns a json representation of the created reply (see documentation for 'replies' method) on success.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_reply_courses_with_http_info(course_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :param str message: The body of the entry.
        :param str attachment: a multipart/form-data form-field-style attachment. Attachments larger than 1 kilobyte are subject to quota restrictions.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id', 'entry_id', 'message', 'attachment']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_reply_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `post_reply_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `post_reply_courses`")  # noqa: E501
        # verify the required parameter 'entry_id' is set
        if self.api_client.client_side_validation and ('entry_id' not in params or
                                                       params['entry_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `entry_id` when calling `post_reply_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501
        if 'entry_id' in params:
            path_params['entry_id'] = params['entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'message' in params:
            form_params.append(('message', params['message']))  # noqa: E501
        if 'attachment' in params:
            form_params.append(('attachment', params['attachment']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_reply_groups(self, group_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """Post a reply  # noqa: E501

        Add a reply to an entry in a discussion topic. Returns a json representation of the created reply (see documentation for 'replies' method) on success.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_reply_groups(group_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :param str message: The body of the entry.
        :param str attachment: a multipart/form-data form-field-style attachment. Attachments larger than 1 kilobyte are subject to quota restrictions.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_reply_groups_with_http_info(group_id, topic_id, entry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_reply_groups_with_http_info(group_id, topic_id, entry_id, **kwargs)  # noqa: E501
            return data

    def post_reply_groups_with_http_info(self, group_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """Post a reply  # noqa: E501

        Add a reply to an entry in a discussion topic. Returns a json representation of the created reply (see documentation for 'replies' method) on success.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body 'require_initial_post'.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_reply_groups_with_http_info(group_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :param str message: The body of the entry.
        :param str attachment: a multipart/form-data form-field-style attachment. Attachments larger than 1 kilobyte are subject to quota restrictions.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id', 'entry_id', 'message', 'attachment']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_reply_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `post_reply_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `post_reply_groups`")  # noqa: E501
        # verify the required parameter 'entry_id' is set
        if self.api_client.client_side_validation and ('entry_id' not in params or
                                                       params['entry_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `entry_id` when calling `post_reply_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501
        if 'entry_id' in params:
            path_params['entry_id'] = params['entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'message' in params:
            form_params.append(('message', params['message']))  # noqa: E501
        if 'attachment' in params:
            form_params.append(('attachment', params['attachment']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def rate_entry_courses(self, course_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """Rate entry  # noqa: E501

        Rate a discussion entry.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rate_entry_courses(course_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :param int rating: A rating to set on this entry. Only 0 and 1 are accepted.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.rate_entry_courses_with_http_info(course_id, topic_id, entry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.rate_entry_courses_with_http_info(course_id, topic_id, entry_id, **kwargs)  # noqa: E501
            return data

    def rate_entry_courses_with_http_info(self, course_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """Rate entry  # noqa: E501

        Rate a discussion entry.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rate_entry_courses_with_http_info(course_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :param int rating: A rating to set on this entry. Only 0 and 1 are accepted.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id', 'entry_id', 'rating']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rate_entry_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `rate_entry_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `rate_entry_courses`")  # noqa: E501
        # verify the required parameter 'entry_id' is set
        if self.api_client.client_side_validation and ('entry_id' not in params or
                                                       params['entry_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `entry_id` when calling `rate_entry_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501
        if 'entry_id' in params:
            path_params['entry_id'] = params['entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'rating' in params:
            form_params.append(('rating', params['rating']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/rating', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def rate_entry_groups(self, group_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """Rate entry  # noqa: E501

        Rate a discussion entry.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rate_entry_groups(group_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :param int rating: A rating to set on this entry. Only 0 and 1 are accepted.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.rate_entry_groups_with_http_info(group_id, topic_id, entry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.rate_entry_groups_with_http_info(group_id, topic_id, entry_id, **kwargs)  # noqa: E501
            return data

    def rate_entry_groups_with_http_info(self, group_id, topic_id, entry_id, **kwargs):  # noqa: E501
        """Rate entry  # noqa: E501

        Rate a discussion entry.  On success, the response will be 204 No Content with an empty body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rate_entry_groups_with_http_info(group_id, topic_id, entry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str entry_id: ID (required)
        :param int rating: A rating to set on this entry. Only 0 and 1 are accepted.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id', 'entry_id', 'rating']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rate_entry_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `rate_entry_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `rate_entry_groups`")  # noqa: E501
        # verify the required parameter 'entry_id' is set
        if self.api_client.client_side_validation and ('entry_id' not in params or
                                                       params['entry_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `entry_id` when calling `rate_entry_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501
        if 'entry_id' in params:
            path_params['entry_id'] = params['entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'rating' in params:
            form_params.append(('rating', params['rating']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/rating', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reorder_pinned_topics_courses(self, course_id, order, **kwargs):  # noqa: E501
        """Reorder pinned topics  # noqa: E501

        Puts the pinned discussion topics in the specified order. All pinned topics should be included.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reorder_pinned_topics_courses(course_id, order, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param list[int] order: The ids of the pinned discussion topics in the desired order. (For example, \"order=104,102,103\".) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reorder_pinned_topics_courses_with_http_info(course_id, order, **kwargs)  # noqa: E501
        else:
            (data) = self.reorder_pinned_topics_courses_with_http_info(course_id, order, **kwargs)  # noqa: E501
            return data

    def reorder_pinned_topics_courses_with_http_info(self, course_id, order, **kwargs):  # noqa: E501
        """Reorder pinned topics  # noqa: E501

        Puts the pinned discussion topics in the specified order. All pinned topics should be included.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reorder_pinned_topics_courses_with_http_info(course_id, order, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param list[int] order: The ids of the pinned discussion topics in the desired order. (For example, \"order=104,102,103\".) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reorder_pinned_topics_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `reorder_pinned_topics_courses`")  # noqa: E501
        # verify the required parameter 'order' is set
        if self.api_client.client_side_validation and ('order' not in params or
                                                       params['order'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `order` when calling `reorder_pinned_topics_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'order' in params:
            form_params.append(('order', params['order']))  # noqa: E501
            collection_formats['order'] = 'csv'  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/reorder', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reorder_pinned_topics_groups(self, group_id, order, **kwargs):  # noqa: E501
        """Reorder pinned topics  # noqa: E501

        Puts the pinned discussion topics in the specified order. All pinned topics should be included.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reorder_pinned_topics_groups(group_id, order, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param list[int] order: The ids of the pinned discussion topics in the desired order. (For example, \"order=104,102,103\".) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reorder_pinned_topics_groups_with_http_info(group_id, order, **kwargs)  # noqa: E501
        else:
            (data) = self.reorder_pinned_topics_groups_with_http_info(group_id, order, **kwargs)  # noqa: E501
            return data

    def reorder_pinned_topics_groups_with_http_info(self, group_id, order, **kwargs):  # noqa: E501
        """Reorder pinned topics  # noqa: E501

        Puts the pinned discussion topics in the specified order. All pinned topics should be included.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reorder_pinned_topics_groups_with_http_info(group_id, order, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param list[int] order: The ids of the pinned discussion topics in the desired order. (For example, \"order=104,102,103\".) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reorder_pinned_topics_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `reorder_pinned_topics_groups`")  # noqa: E501
        # verify the required parameter 'order' is set
        if self.api_client.client_side_validation and ('order' not in params or
                                                       params['order'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `order` when calling `reorder_pinned_topics_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'order' in params:
            form_params.append(('order', params['order']))  # noqa: E501
            collection_formats['order'] = 'csv'  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/reorder', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def subscribe_to_topic_courses(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Subscribe to a topic  # noqa: E501

        Subscribe to a topic to receive notifications about new entries  On success, the response will be 204 No Content with an empty body  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscribe_to_topic_courses(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.subscribe_to_topic_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.subscribe_to_topic_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
            return data

    def subscribe_to_topic_courses_with_http_info(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Subscribe to a topic  # noqa: E501

        Subscribe to a topic to receive notifications about new entries  On success, the response will be 204 No Content with an empty body  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscribe_to_topic_courses_with_http_info(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method subscribe_to_topic_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `subscribe_to_topic_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `subscribe_to_topic_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/subscribed', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def subscribe_to_topic_groups(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Subscribe to a topic  # noqa: E501

        Subscribe to a topic to receive notifications about new entries  On success, the response will be 204 No Content with an empty body  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscribe_to_topic_groups(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.subscribe_to_topic_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.subscribe_to_topic_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
            return data

    def subscribe_to_topic_groups_with_http_info(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Subscribe to a topic  # noqa: E501

        Subscribe to a topic to receive notifications about new entries  On success, the response will be 204 No Content with an empty body  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscribe_to_topic_groups_with_http_info(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method subscribe_to_topic_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `subscribe_to_topic_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `subscribe_to_topic_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/subscribed', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def summary_courses(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Summary  # noqa: E501

        Generates a summary for a discussion topic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.summary_courses(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str user_input: Areas or topics for the summary to focus on.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.summary_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.summary_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
            return data

    def summary_courses_with_http_info(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Summary  # noqa: E501

        Generates a summary for a discussion topic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.summary_courses_with_http_info(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str user_input: Areas or topics for the summary to focus on.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id', 'user_input']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method summary_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `summary_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `summary_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []
        if 'user_input' in params:
            query_params.append(('userInput', params['user_input']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/summaries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def summary_feedback_courses(self, course_id, topic_id, summary_id, **kwargs):  # noqa: E501
        """Summary Feedback  # noqa: E501

        Persists feedback on a discussion topic summary.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.summary_feedback_courses(course_id, topic_id, summary_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str summary_id: ID (required)
        :param str action: Required The action to take on the summary. Possible values are: - \"seen\": Marks the summary as seen. This action saves the feedback if it's not already persisted. - \"like\": Marks the summary as liked. - \"dislike\": Marks the summary as disliked. - \"reset_like\": Resets the like status of the summary. - \"regenerate\": Regenerates the summary feedback. - \"disable_summary\": Disables the summary feedback. Any other value will result in an error response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.summary_feedback_courses_with_http_info(course_id, topic_id, summary_id, **kwargs)  # noqa: E501
        else:
            (data) = self.summary_feedback_courses_with_http_info(course_id, topic_id, summary_id, **kwargs)  # noqa: E501
            return data

    def summary_feedback_courses_with_http_info(self, course_id, topic_id, summary_id, **kwargs):  # noqa: E501
        """Summary Feedback  # noqa: E501

        Persists feedback on a discussion topic summary.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.summary_feedback_courses_with_http_info(course_id, topic_id, summary_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str summary_id: ID (required)
        :param str action: Required The action to take on the summary. Possible values are: - \"seen\": Marks the summary as seen. This action saves the feedback if it's not already persisted. - \"like\": Marks the summary as liked. - \"dislike\": Marks the summary as disliked. - \"reset_like\": Resets the like status of the summary. - \"regenerate\": Regenerates the summary feedback. - \"disable_summary\": Disables the summary feedback. Any other value will result in an error response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id', 'summary_id', 'action']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method summary_feedback_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `summary_feedback_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `summary_feedback_courses`")  # noqa: E501
        # verify the required parameter 'summary_id' is set
        if self.api_client.client_side_validation and ('summary_id' not in params or
                                                       params['summary_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `summary_id` when calling `summary_feedback_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501
        if 'summary_id' in params:
            path_params['summary_id'] = params['summary_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'action' in params:
            form_params.append(('_action', params['action']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/summaries/{summary_id}/feedback', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def summary_feedback_groups(self, group_id, topic_id, summary_id, **kwargs):  # noqa: E501
        """Summary Feedback  # noqa: E501

        Persists feedback on a discussion topic summary.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.summary_feedback_groups(group_id, topic_id, summary_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str summary_id: ID (required)
        :param str action: Required The action to take on the summary. Possible values are: - \"seen\": Marks the summary as seen. This action saves the feedback if it's not already persisted. - \"like\": Marks the summary as liked. - \"dislike\": Marks the summary as disliked. - \"reset_like\": Resets the like status of the summary. - \"regenerate\": Regenerates the summary feedback. - \"disable_summary\": Disables the summary feedback. Any other value will result in an error response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.summary_feedback_groups_with_http_info(group_id, topic_id, summary_id, **kwargs)  # noqa: E501
        else:
            (data) = self.summary_feedback_groups_with_http_info(group_id, topic_id, summary_id, **kwargs)  # noqa: E501
            return data

    def summary_feedback_groups_with_http_info(self, group_id, topic_id, summary_id, **kwargs):  # noqa: E501
        """Summary Feedback  # noqa: E501

        Persists feedback on a discussion topic summary.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.summary_feedback_groups_with_http_info(group_id, topic_id, summary_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str summary_id: ID (required)
        :param str action: Required The action to take on the summary. Possible values are: - \"seen\": Marks the summary as seen. This action saves the feedback if it's not already persisted. - \"like\": Marks the summary as liked. - \"dislike\": Marks the summary as disliked. - \"reset_like\": Resets the like status of the summary. - \"regenerate\": Regenerates the summary feedback. - \"disable_summary\": Disables the summary feedback. Any other value will result in an error response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id', 'summary_id', 'action']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method summary_feedback_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `summary_feedback_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `summary_feedback_groups`")  # noqa: E501
        # verify the required parameter 'summary_id' is set
        if self.api_client.client_side_validation and ('summary_id' not in params or
                                                       params['summary_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `summary_id` when calling `summary_feedback_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501
        if 'summary_id' in params:
            path_params['summary_id'] = params['summary_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'action' in params:
            form_params.append(('_action', params['action']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/summaries/{summary_id}/feedback', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def summary_groups(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Summary  # noqa: E501

        Generates a summary for a discussion topic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.summary_groups(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str user_input: Areas or topics for the summary to focus on.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.summary_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.summary_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
            return data

    def summary_groups_with_http_info(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Summary  # noqa: E501

        Generates a summary for a discussion topic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.summary_groups_with_http_info(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str user_input: Areas or topics for the summary to focus on.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id', 'user_input']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method summary_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `summary_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `summary_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []
        if 'user_input' in params:
            query_params.append(('userInput', params['user_input']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/summaries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unsubscribe_from_topic_courses(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Unsubscribe from a topic  # noqa: E501

        Unsubscribe from a topic to stop receiving notifications about new entries  On success, the response will be 204 No Content with an empty body  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unsubscribe_from_topic_courses(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unsubscribe_from_topic_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.unsubscribe_from_topic_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
            return data

    def unsubscribe_from_topic_courses_with_http_info(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Unsubscribe from a topic  # noqa: E501

        Unsubscribe from a topic to stop receiving notifications about new entries  On success, the response will be 204 No Content with an empty body  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unsubscribe_from_topic_courses_with_http_info(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unsubscribe_from_topic_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `unsubscribe_from_topic_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `unsubscribe_from_topic_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/subscribed', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unsubscribe_from_topic_groups(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Unsubscribe from a topic  # noqa: E501

        Unsubscribe from a topic to stop receiving notifications about new entries  On success, the response will be 204 No Content with an empty body  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unsubscribe_from_topic_groups(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unsubscribe_from_topic_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.unsubscribe_from_topic_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
            return data

    def unsubscribe_from_topic_groups_with_http_info(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Unsubscribe from a topic  # noqa: E501

        Unsubscribe from a topic to stop receiving notifications about new entries  On success, the response will be 204 No Content with an empty body  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unsubscribe_from_topic_groups_with_http_info(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unsubscribe_from_topic_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `unsubscribe_from_topic_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `unsubscribe_from_topic_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/subscribed', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_courses(self, course_id, topic_id, id, **kwargs):  # noqa: E501
        """Update an entry  # noqa: E501

        Update an existing discussion entry.  The entry must have been created by the current user, or the current user must have admin rights to the discussion. If the edit is not allowed, a 401 will be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_entry_courses(course_id, topic_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str id: ID (required)
        :param str message: The updated body of the entry.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_entry_courses_with_http_info(course_id, topic_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_courses_with_http_info(course_id, topic_id, id, **kwargs)  # noqa: E501
            return data

    def update_entry_courses_with_http_info(self, course_id, topic_id, id, **kwargs):  # noqa: E501
        """Update an entry  # noqa: E501

        Update an existing discussion entry.  The entry must have been created by the current user, or the current user must have admin rights to the discussion. If the edit is not allowed, a 401 will be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_entry_courses_with_http_info(course_id, topic_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str id: ID (required)
        :param str message: The updated body of the entry.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id', 'id', 'message']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `update_entry_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `update_entry_courses`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_entry_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'message' in params:
            form_params.append(('message', params['message']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_groups(self, group_id, topic_id, id, **kwargs):  # noqa: E501
        """Update an entry  # noqa: E501

        Update an existing discussion entry.  The entry must have been created by the current user, or the current user must have admin rights to the discussion. If the edit is not allowed, a 401 will be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_entry_groups(group_id, topic_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str id: ID (required)
        :param str message: The updated body of the entry.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_entry_groups_with_http_info(group_id, topic_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_groups_with_http_info(group_id, topic_id, id, **kwargs)  # noqa: E501
            return data

    def update_entry_groups_with_http_info(self, group_id, topic_id, id, **kwargs):  # noqa: E501
        """Update an entry  # noqa: E501

        Update an existing discussion entry.  The entry must have been created by the current user, or the current user must have admin rights to the discussion. If the edit is not allowed, a 401 will be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_entry_groups_with_http_info(group_id, topic_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str id: ID (required)
        :param str message: The updated body of the entry.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id', 'id', 'message']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `update_entry_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `update_entry_groups`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_entry_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'message' in params:
            form_params.append(('message', params['message']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_topic_courses(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Update a topic  # noqa: E501

        Update an existing discussion topic for the course or group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_topic_courses(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str title: no description
        :param str message: no description
        :param str discussion_type: The type of discussion. Defaults to side_comment or not_threaded if not value is given. Accepted values are 'side_comment', 'not_threaded' for discussions that only allow one level of nested comments, and 'threaded' for fully threaded discussions.
        :param bool published: Whether this topic is published (true) or draft state (false). Only teachers and TAs have the ability to create draft state topics.
        :param Object delayed_post_at: If a timestamp is given, the topic will not be published until that time.
        :param Object lock_at: If a timestamp is given, the topic will be scheduled to lock at the provided timestamp. If the timestamp is in the past, the topic will be locked.
        :param bool podcast_enabled: If true, the topic will have an associated podcast feed.
        :param bool podcast_has_student_posts: If true, the podcast will include posts from students as well. Implies podcast_enabled.
        :param bool require_initial_post: If true then a user may not respond to other replies until that user has made an initial reply. Defaults to false.
        :param Object assignment: To create an assignment discussion, pass the assignment parameters as a sub-object. See the {api:AssignmentsApiController#create Create an Assignment API} for the available parameters. The name parameter will be ignored, as it's taken from the discussion title. If you want to make a discussion that was an assignment NOT an assignment, pass set_assignment = false as part of the assignment object
        :param bool is_announcement: If true, this topic is an announcement. It will appear in the announcement's section rather than the discussions section. This requires announcment-posting permissions.
        :param bool pinned: If true, this topic will be listed in the \"Pinned Discussion\" section
        :param str position_after: By default, discussions are sorted chronologically by creation date, you can pass the id of another topic to have this one show up after the other when they are listed.
        :param int group_category_id: If present, the topic will become a group discussion assigned to the group.
        :param bool allow_rating: If true, users will be allowed to rate entries.
        :param bool only_graders_can_rate: If true, only graders will be allowed to rate entries.
        :param bool sort_by_rating: If true, entries will be sorted by rating.
        :param str specific_sections: A comma-separated list of sections ids to which the discussion topic should be made specific too.  If it is not desired to make the discussion topic specific to sections, then this parameter may be omitted or set to \"all\".  Can only be present only on announcements and only those that are for a course (as opposed to a group).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_topic_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_topic_courses_with_http_info(course_id, topic_id, **kwargs)  # noqa: E501
            return data

    def update_topic_courses_with_http_info(self, course_id, topic_id, **kwargs):  # noqa: E501
        """Update a topic  # noqa: E501

        Update an existing discussion topic for the course or group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_topic_courses_with_http_info(course_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str topic_id: ID (required)
        :param str title: no description
        :param str message: no description
        :param str discussion_type: The type of discussion. Defaults to side_comment or not_threaded if not value is given. Accepted values are 'side_comment', 'not_threaded' for discussions that only allow one level of nested comments, and 'threaded' for fully threaded discussions.
        :param bool published: Whether this topic is published (true) or draft state (false). Only teachers and TAs have the ability to create draft state topics.
        :param Object delayed_post_at: If a timestamp is given, the topic will not be published until that time.
        :param Object lock_at: If a timestamp is given, the topic will be scheduled to lock at the provided timestamp. If the timestamp is in the past, the topic will be locked.
        :param bool podcast_enabled: If true, the topic will have an associated podcast feed.
        :param bool podcast_has_student_posts: If true, the podcast will include posts from students as well. Implies podcast_enabled.
        :param bool require_initial_post: If true then a user may not respond to other replies until that user has made an initial reply. Defaults to false.
        :param Object assignment: To create an assignment discussion, pass the assignment parameters as a sub-object. See the {api:AssignmentsApiController#create Create an Assignment API} for the available parameters. The name parameter will be ignored, as it's taken from the discussion title. If you want to make a discussion that was an assignment NOT an assignment, pass set_assignment = false as part of the assignment object
        :param bool is_announcement: If true, this topic is an announcement. It will appear in the announcement's section rather than the discussions section. This requires announcment-posting permissions.
        :param bool pinned: If true, this topic will be listed in the \"Pinned Discussion\" section
        :param str position_after: By default, discussions are sorted chronologically by creation date, you can pass the id of another topic to have this one show up after the other when they are listed.
        :param int group_category_id: If present, the topic will become a group discussion assigned to the group.
        :param bool allow_rating: If true, users will be allowed to rate entries.
        :param bool only_graders_can_rate: If true, only graders will be allowed to rate entries.
        :param bool sort_by_rating: If true, entries will be sorted by rating.
        :param str specific_sections: A comma-separated list of sections ids to which the discussion topic should be made specific too.  If it is not desired to make the discussion topic specific to sections, then this parameter may be omitted or set to \"all\".  Can only be present only on announcements and only those that are for a course (as opposed to a group).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'topic_id', 'title', 'message', 'discussion_type', 'published', 'delayed_post_at', 'lock_at', 'podcast_enabled', 'podcast_has_student_posts', 'require_initial_post', 'assignment', 'is_announcement', 'pinned', 'position_after', 'group_category_id', 'allow_rating', 'only_graders_can_rate', 'sort_by_rating', 'specific_sections']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_topic_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `update_topic_courses`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `update_topic_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'message' in params:
            form_params.append(('message', params['message']))  # noqa: E501
        if 'discussion_type' in params:
            form_params.append(('discussion_type', params['discussion_type']))  # noqa: E501
        if 'published' in params:
            form_params.append(('published', params['published']))  # noqa: E501
        if 'delayed_post_at' in params:
            form_params.append(('delayed_post_at', params['delayed_post_at']))  # noqa: E501
        if 'lock_at' in params:
            form_params.append(('lock_at', params['lock_at']))  # noqa: E501
        if 'podcast_enabled' in params:
            form_params.append(('podcast_enabled', params['podcast_enabled']))  # noqa: E501
        if 'podcast_has_student_posts' in params:
            form_params.append(('podcast_has_student_posts', params['podcast_has_student_posts']))  # noqa: E501
        if 'require_initial_post' in params:
            form_params.append(('require_initial_post', params['require_initial_post']))  # noqa: E501
        if 'assignment' in params:
            form_params.append(('assignment', params['assignment']))  # noqa: E501
        if 'is_announcement' in params:
            form_params.append(('is_announcement', params['is_announcement']))  # noqa: E501
        if 'pinned' in params:
            form_params.append(('pinned', params['pinned']))  # noqa: E501
        if 'position_after' in params:
            form_params.append(('position_after', params['position_after']))  # noqa: E501
        if 'group_category_id' in params:
            form_params.append(('group_category_id', params['group_category_id']))  # noqa: E501
        if 'allow_rating' in params:
            form_params.append(('allow_rating', params['allow_rating']))  # noqa: E501
        if 'only_graders_can_rate' in params:
            form_params.append(('only_graders_can_rate', params['only_graders_can_rate']))  # noqa: E501
        if 'sort_by_rating' in params:
            form_params.append(('sort_by_rating', params['sort_by_rating']))  # noqa: E501
        if 'specific_sections' in params:
            form_params.append(('specific_sections', params['specific_sections']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/discussion_topics/{topic_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_topic_groups(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Update a topic  # noqa: E501

        Update an existing discussion topic for the course or group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_topic_groups(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str title: no description
        :param str message: no description
        :param str discussion_type: The type of discussion. Defaults to side_comment or not_threaded if not value is given. Accepted values are 'side_comment', 'not_threaded' for discussions that only allow one level of nested comments, and 'threaded' for fully threaded discussions.
        :param bool published: Whether this topic is published (true) or draft state (false). Only teachers and TAs have the ability to create draft state topics.
        :param Object delayed_post_at: If a timestamp is given, the topic will not be published until that time.
        :param Object lock_at: If a timestamp is given, the topic will be scheduled to lock at the provided timestamp. If the timestamp is in the past, the topic will be locked.
        :param bool podcast_enabled: If true, the topic will have an associated podcast feed.
        :param bool podcast_has_student_posts: If true, the podcast will include posts from students as well. Implies podcast_enabled.
        :param bool require_initial_post: If true then a user may not respond to other replies until that user has made an initial reply. Defaults to false.
        :param Object assignment: To create an assignment discussion, pass the assignment parameters as a sub-object. See the {api:AssignmentsApiController#create Create an Assignment API} for the available parameters. The name parameter will be ignored, as it's taken from the discussion title. If you want to make a discussion that was an assignment NOT an assignment, pass set_assignment = false as part of the assignment object
        :param bool is_announcement: If true, this topic is an announcement. It will appear in the announcement's section rather than the discussions section. This requires announcment-posting permissions.
        :param bool pinned: If true, this topic will be listed in the \"Pinned Discussion\" section
        :param str position_after: By default, discussions are sorted chronologically by creation date, you can pass the id of another topic to have this one show up after the other when they are listed.
        :param int group_category_id: If present, the topic will become a group discussion assigned to the group.
        :param bool allow_rating: If true, users will be allowed to rate entries.
        :param bool only_graders_can_rate: If true, only graders will be allowed to rate entries.
        :param bool sort_by_rating: If true, entries will be sorted by rating.
        :param str specific_sections: A comma-separated list of sections ids to which the discussion topic should be made specific too.  If it is not desired to make the discussion topic specific to sections, then this parameter may be omitted or set to \"all\".  Can only be present only on announcements and only those that are for a course (as opposed to a group).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_topic_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_topic_groups_with_http_info(group_id, topic_id, **kwargs)  # noqa: E501
            return data

    def update_topic_groups_with_http_info(self, group_id, topic_id, **kwargs):  # noqa: E501
        """Update a topic  # noqa: E501

        Update an existing discussion topic for the course or group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_topic_groups_with_http_info(group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str topic_id: ID (required)
        :param str title: no description
        :param str message: no description
        :param str discussion_type: The type of discussion. Defaults to side_comment or not_threaded if not value is given. Accepted values are 'side_comment', 'not_threaded' for discussions that only allow one level of nested comments, and 'threaded' for fully threaded discussions.
        :param bool published: Whether this topic is published (true) or draft state (false). Only teachers and TAs have the ability to create draft state topics.
        :param Object delayed_post_at: If a timestamp is given, the topic will not be published until that time.
        :param Object lock_at: If a timestamp is given, the topic will be scheduled to lock at the provided timestamp. If the timestamp is in the past, the topic will be locked.
        :param bool podcast_enabled: If true, the topic will have an associated podcast feed.
        :param bool podcast_has_student_posts: If true, the podcast will include posts from students as well. Implies podcast_enabled.
        :param bool require_initial_post: If true then a user may not respond to other replies until that user has made an initial reply. Defaults to false.
        :param Object assignment: To create an assignment discussion, pass the assignment parameters as a sub-object. See the {api:AssignmentsApiController#create Create an Assignment API} for the available parameters. The name parameter will be ignored, as it's taken from the discussion title. If you want to make a discussion that was an assignment NOT an assignment, pass set_assignment = false as part of the assignment object
        :param bool is_announcement: If true, this topic is an announcement. It will appear in the announcement's section rather than the discussions section. This requires announcment-posting permissions.
        :param bool pinned: If true, this topic will be listed in the \"Pinned Discussion\" section
        :param str position_after: By default, discussions are sorted chronologically by creation date, you can pass the id of another topic to have this one show up after the other when they are listed.
        :param int group_category_id: If present, the topic will become a group discussion assigned to the group.
        :param bool allow_rating: If true, users will be allowed to rate entries.
        :param bool only_graders_can_rate: If true, only graders will be allowed to rate entries.
        :param bool sort_by_rating: If true, entries will be sorted by rating.
        :param str specific_sections: A comma-separated list of sections ids to which the discussion topic should be made specific too.  If it is not desired to make the discussion topic specific to sections, then this parameter may be omitted or set to \"all\".  Can only be present only on announcements and only those that are for a course (as opposed to a group).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'topic_id', 'title', 'message', 'discussion_type', 'published', 'delayed_post_at', 'lock_at', 'podcast_enabled', 'podcast_has_student_posts', 'require_initial_post', 'assignment', 'is_announcement', 'pinned', 'position_after', 'group_category_id', 'allow_rating', 'only_graders_can_rate', 'sort_by_rating', 'specific_sections']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_topic_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `update_topic_groups`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in params or
                                                       params['topic_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `topic_id` when calling `update_topic_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'topic_id' in params:
            path_params['topic_id'] = params['topic_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'message' in params:
            form_params.append(('message', params['message']))  # noqa: E501
        if 'discussion_type' in params:
            form_params.append(('discussion_type', params['discussion_type']))  # noqa: E501
        if 'published' in params:
            form_params.append(('published', params['published']))  # noqa: E501
        if 'delayed_post_at' in params:
            form_params.append(('delayed_post_at', params['delayed_post_at']))  # noqa: E501
        if 'lock_at' in params:
            form_params.append(('lock_at', params['lock_at']))  # noqa: E501
        if 'podcast_enabled' in params:
            form_params.append(('podcast_enabled', params['podcast_enabled']))  # noqa: E501
        if 'podcast_has_student_posts' in params:
            form_params.append(('podcast_has_student_posts', params['podcast_has_student_posts']))  # noqa: E501
        if 'require_initial_post' in params:
            form_params.append(('require_initial_post', params['require_initial_post']))  # noqa: E501
        if 'assignment' in params:
            form_params.append(('assignment', params['assignment']))  # noqa: E501
        if 'is_announcement' in params:
            form_params.append(('is_announcement', params['is_announcement']))  # noqa: E501
        if 'pinned' in params:
            form_params.append(('pinned', params['pinned']))  # noqa: E501
        if 'position_after' in params:
            form_params.append(('position_after', params['position_after']))  # noqa: E501
        if 'group_category_id' in params:
            form_params.append(('group_category_id', params['group_category_id']))  # noqa: E501
        if 'allow_rating' in params:
            form_params.append(('allow_rating', params['allow_rating']))  # noqa: E501
        if 'only_graders_can_rate' in params:
            form_params.append(('only_graders_can_rate', params['only_graders_can_rate']))  # noqa: E501
        if 'sort_by_rating' in params:
            form_params.append(('sort_by_rating', params['sort_by_rating']))  # noqa: E501
        if 'specific_sections' in params:
            form_params.append(('specific_sections', params['specific_sections']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/discussion_topics/{topic_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
