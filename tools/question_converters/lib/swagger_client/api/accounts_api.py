# coding: utf-8

"""

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class AccountsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_new_sub_account(self, account_id, account_name, **kwargs):  # noqa: E501
        """Create a new sub-account  # noqa: E501

        Add a new sub-account to a given account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_new_sub_account(account_id, account_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str account_name: The name of the new sub-account. (required)
        :param str account_sis_account_id: The account's identifier in the Student Information System.
        :param int account_default_storage_quota_mb: The default course storage quota to be used, if not otherwise specified.
        :param int account_default_user_storage_quota_mb: The default user storage quota to be used, if not otherwise specified.
        :param int account_default_group_storage_quota_mb: The default group storage quota to be used, if not otherwise specified.
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_new_sub_account_with_http_info(account_id, account_name, **kwargs)  # noqa: E501
        else:
            (data) = self.create_new_sub_account_with_http_info(account_id, account_name, **kwargs)  # noqa: E501
            return data

    def create_new_sub_account_with_http_info(self, account_id, account_name, **kwargs):  # noqa: E501
        """Create a new sub-account  # noqa: E501

        Add a new sub-account to a given account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_new_sub_account_with_http_info(account_id, account_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str account_name: The name of the new sub-account. (required)
        :param str account_sis_account_id: The account's identifier in the Student Information System.
        :param int account_default_storage_quota_mb: The default course storage quota to be used, if not otherwise specified.
        :param int account_default_user_storage_quota_mb: The default user storage quota to be used, if not otherwise specified.
        :param int account_default_group_storage_quota_mb: The default group storage quota to be used, if not otherwise specified.
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'account_name', 'account_sis_account_id', 'account_default_storage_quota_mb', 'account_default_user_storage_quota_mb', 'account_default_group_storage_quota_mb']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_new_sub_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `create_new_sub_account`")  # noqa: E501
        # verify the required parameter 'account_name' is set
        if self.api_client.client_side_validation and ('account_name' not in params or
                                                       params['account_name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_name` when calling `create_new_sub_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'account_name' in params:
            form_params.append(('account[name]', params['account_name']))  # noqa: E501
        if 'account_sis_account_id' in params:
            form_params.append(('account[sis_account_id]', params['account_sis_account_id']))  # noqa: E501
        if 'account_default_storage_quota_mb' in params:
            form_params.append(('account[default_storage_quota_mb]', params['account_default_storage_quota_mb']))  # noqa: E501
        if 'account_default_user_storage_quota_mb' in params:
            form_params.append(('account[default_user_storage_quota_mb]', params['account_default_user_storage_quota_mb']))  # noqa: E501
        if 'account_default_group_storage_quota_mb' in params:
            form_params.append(('account[default_group_storage_quota_mb]', params['account_default_group_storage_quota_mb']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/sub_accounts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Account',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_sub_account(self, account_id, id, **kwargs):  # noqa: E501
        """Delete a sub-account  # noqa: E501

        Cannot delete an account with active courses or active sub_accounts. Cannot delete a root_account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_sub_account(account_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str id: ID (required)
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_sub_account_with_http_info(account_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_sub_account_with_http_info(account_id, id, **kwargs)  # noqa: E501
            return data

    def delete_sub_account_with_http_info(self, account_id, id, **kwargs):  # noqa: E501
        """Delete a sub-account  # noqa: E501

        Cannot delete an account with active courses or active sub_accounts. Cannot delete a root_account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_sub_account_with_http_info(account_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str id: ID (required)
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_sub_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `delete_sub_account`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_sub_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/sub_accounts/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Account',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_from_root_account(self, account_id, user_id, **kwargs):  # noqa: E501
        """Delete a user from the root account  # noqa: E501

        Delete a user record from a Canvas root account. If a user is associated with multiple root accounts (in a multi-tenant instance of Canvas), this action will NOT remove them from the other accounts.  WARNING: This API will allow a user to remove themselves from the account. If they do this, they won't be able to make API calls or log into Canvas at that account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user_from_root_account(account_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str user_id: ID (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_user_from_root_account_with_http_info(account_id, user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_from_root_account_with_http_info(account_id, user_id, **kwargs)  # noqa: E501
            return data

    def delete_user_from_root_account_with_http_info(self, account_id, user_id, **kwargs):  # noqa: E501
        """Delete a user from the root account  # noqa: E501

        Delete a user record from a Canvas root account. If a user is associated with multiple root accounts (in a multi-tenant instance of Canvas), this action will NOT remove them from the other accounts.  WARNING: This API will allow a user to remove themselves from the account. If they do this, they won't be able to make API calls or log into Canvas at that account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user_from_root_account_with_http_info(account_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str user_id: ID (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_from_root_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `delete_user_from_root_account`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `delete_user_from_root_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/users/{user_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_accounts_that_admins_can_manage(self, **kwargs):  # noqa: E501
        """Get accounts that admins can manage  # noqa: E501

        A paginated list of accounts where the current user has permission to create or manage courses. List will be empty for students and teachers as only admins can view which accounts they are in.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_accounts_that_admins_can_manage(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Account]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_accounts_that_admins_can_manage_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_accounts_that_admins_can_manage_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_accounts_that_admins_can_manage_with_http_info(self, **kwargs):  # noqa: E501
        """Get accounts that admins can manage  # noqa: E501

        A paginated list of accounts where the current user has permission to create or manage courses. List will be empty for students and teachers as only admins can view which accounts they are in.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_accounts_that_admins_can_manage_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Account]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_accounts_that_admins_can_manage" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/manageable_accounts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Account]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_accounts_that_users_can_create_courses_in(self, **kwargs):  # noqa: E501
        """Get accounts that users can create courses in  # noqa: E501

        A paginated list of accounts where the current user has permission to create courses.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_accounts_that_users_can_create_courses_in(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Account]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_accounts_that_users_can_create_courses_in_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_accounts_that_users_can_create_courses_in_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_accounts_that_users_can_create_courses_in_with_http_info(self, **kwargs):  # noqa: E501
        """Get accounts that users can create courses in  # noqa: E501

        A paginated list of accounts where the current user has permission to create courses.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_accounts_that_users_can_create_courses_in_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Account]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_accounts_that_users_can_create_courses_in" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/course_creation_accounts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Account]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_help_links(self, account_id, **kwargs):  # noqa: E501
        """Get help links  # noqa: E501

        Returns the help links for that account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_help_links(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :return: HelpLinks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_help_links_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_help_links_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def get_help_links_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Get help links  # noqa: E501

        Returns the help links for that account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_help_links_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :return: HelpLinks
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_help_links" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `get_help_links`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/help_links', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HelpLinks',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_manually_created_courses_sub_account_for_domain_root_account(self, **kwargs):  # noqa: E501
        """Get the manually-created courses sub-account for the domain root account  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manually_created_courses_sub_account_for_domain_root_account(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_manually_created_courses_sub_account_for_domain_root_account_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_manually_created_courses_sub_account_for_domain_root_account_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_manually_created_courses_sub_account_for_domain_root_account_with_http_info(self, **kwargs):  # noqa: E501
        """Get the manually-created courses sub-account for the domain root account  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manually_created_courses_sub_account_for_domain_root_account_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manually_created_courses_sub_account_for_domain_root_account" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/manually_created_courses_account', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Account',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_single_account(self, id, **kwargs):  # noqa: E501
        """Get a single account  # noqa: E501

        Retrieve information on an individual account, given by id or sis sis_account_id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_single_account(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_single_account_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_single_account_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_single_account_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a single account  # noqa: E501

        Retrieve information on an individual account, given by id or sis sis_account_id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_single_account_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_single_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_single_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Account',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sub_accounts_of_account(self, account_id, **kwargs):  # noqa: E501
        """Get the sub-accounts of an account  # noqa: E501

        List accounts that are sub-accounts of the given account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sub_accounts_of_account(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param bool recursive: If true, the entire account tree underneath this account will be returned (though still paginated). If false, only direct sub-accounts of this account will be returned. Defaults to false.
        :param list[str] include: Array of additional information to include.  \"course_count\":: returns the number of courses directly under each account \"sub_account_count\":: returns the number of sub-accounts directly under each account
        :return: list[Account]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sub_accounts_of_account_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_sub_accounts_of_account_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def get_sub_accounts_of_account_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Get the sub-accounts of an account  # noqa: E501

        List accounts that are sub-accounts of the given account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sub_accounts_of_account_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param bool recursive: If true, the entire account tree underneath this account will be returned (though still paginated). If false, only direct sub-accounts of this account will be returned. Defaults to false.
        :param list[str] include: Array of additional information to include.  \"course_count\":: returns the number of courses directly under each account \"sub_account_count\":: returns the number of sub-accounts directly under each account
        :return: list[Account]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'recursive', 'include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sub_accounts_of_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `get_sub_accounts_of_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/sub_accounts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Account]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_terms_of_service(self, account_id, **kwargs):  # noqa: E501
        """Get the Terms of Service  # noqa: E501

        Returns the terms of service for that account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_terms_of_service(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :return: TermsOfService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_terms_of_service_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_terms_of_service_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def get_terms_of_service_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Get the Terms of Service  # noqa: E501

        Returns the terms of service for that account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_terms_of_service_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :return: TermsOfService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_terms_of_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `get_terms_of_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/terms_of_service', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TermsOfService',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_accounts(self, **kwargs):  # noqa: E501
        """List accounts  # noqa: E501

        A paginated list of accounts that the current user can view or manage. Typically, students and even teachers will get an empty list in response, only account admins can view the accounts that they are in.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_accounts(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] include: Array of additional information to include.  \"lti_guid\":: the 'tool_consumer_instance_guid' that will be sent for this account on LTI launches \"registration_settings\":: returns info about the privacy policy and terms of use \"services\":: returns services and whether they are enabled (requires account management permissions) \"course_count\":: returns the number of courses directly under each account \"sub_account_count\":: returns the number of sub-accounts directly under each account
        :return: list[Account]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_accounts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_accounts_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_accounts_with_http_info(self, **kwargs):  # noqa: E501
        """List accounts  # noqa: E501

        A paginated list of accounts that the current user can view or manage. Typically, students and even teachers will get an empty list in response, only account admins can view the accounts that they are in.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_accounts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] include: Array of additional information to include.  \"lti_guid\":: the 'tool_consumer_instance_guid' that will be sent for this account on LTI launches \"registration_settings\":: returns info about the privacy policy and terms of use \"services\":: returns services and whether they are enabled (requires account management permissions) \"course_count\":: returns the number of courses directly under each account \"sub_account_count\":: returns the number of sub-accounts directly under each account
        :return: list[Account]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_accounts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Account]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_accounts_for_course_admins(self, **kwargs):  # noqa: E501
        """List accounts for course admins  # noqa: E501

        A paginated list of accounts that the current user can view through their admin course enrollments. (Teacher, TA, or designer enrollments). Only returns \"id\", \"name\", \"workflow_state\", \"root_account_id\" and \"parent_account_id\"  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_accounts_for_course_admins(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Account]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_accounts_for_course_admins_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_accounts_for_course_admins_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_accounts_for_course_admins_with_http_info(self, **kwargs):  # noqa: E501
        """List accounts for course admins  # noqa: E501

        A paginated list of accounts that the current user can view through their admin course enrollments. (Teacher, TA, or designer enrollments). Only returns \"id\", \"name\", \"workflow_state\", \"root_account_id\" and \"parent_account_id\"  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_accounts_for_course_admins_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Account]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_accounts_for_course_admins" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/course_accounts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Account]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_active_courses_in_account(self, account_id, **kwargs):  # noqa: E501
        """List active courses in an account  # noqa: E501

        Retrieve a paginated list of courses in this account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_active_courses_in_account(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param bool with_enrollments: If true, include only courses with at least one enrollment.  If false, include only courses with no enrollments.  If not present, do not filter on course enrollment status.
        :param list[str] enrollment_type: If set, only return courses that have at least one user enrolled in in the course with one of the specified enrollment types.
        :param bool published: If true, include only published courses.  If false, exclude published courses.  If not present, do not filter on published status.
        :param bool completed: If true, include only completed courses (these may be in state 'completed', or their enrollment term may have ended).  If false, exclude completed courses.  If not present, do not filter on completed status.
        :param bool blueprint: If true, include only blueprint courses. If false, exclude them. If not present, do not filter on this basis.
        :param bool blueprint_associated: If true, include only courses that inherit content from a blueprint course. If false, exclude them. If not present, do not filter on this basis.
        :param bool public: If true, include only public courses. If false, exclude them. If not present, do not filter on this basis.
        :param list[int] by_teachers: List of User IDs of teachers; if supplied, include only courses taught by one of the referenced users.
        :param list[int] by_subaccounts: List of Account IDs; if supplied, include only courses associated with one of the referenced subaccounts.
        :param bool hide_enrollmentless_courses: If present, only return courses that have at least one enrollment. Equivalent to 'with_enrollments=true'; retained for compatibility.
        :param list[str] state: If set, only return courses that are in the given state(s). By default, all states but \"deleted\" are returned.
        :param int enrollment_term_id: If set, only includes courses from the specified term.
        :param str search_term: The partial course name, code, or full ID to match and return in the results list. Must be at least 3 characters.
        :param list[str] include: - All explanations can be seen in the {api:CoursesController#index Course API index documentation} - \"sections\", \"needs_grading_count\" and \"total_scores\" are not valid options at the account level
        :param str sort: The column to sort results by.
        :param str order: The order to sort the given column by.
        :param str search_by: The filter to search by. \"course\" searches for course names, course codes, and SIS IDs. \"teacher\" searches for teacher names
        :param Object starts_before: If set, only return courses that start before the value (inclusive) or their enrollment term starts before the value (inclusive) or both the course's start_at and the enrollment term's start_at are set to null. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
        :param Object ends_after: If set, only return courses that end after the value (inclusive) or their enrollment term ends after the value (inclusive) or both the course's end_at and the enrollment term's end_at are set to null. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
        :param bool homeroom: If set, only return homeroom courses.
        :return: list[Course]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_active_courses_in_account_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_active_courses_in_account_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def list_active_courses_in_account_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """List active courses in an account  # noqa: E501

        Retrieve a paginated list of courses in this account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_active_courses_in_account_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param bool with_enrollments: If true, include only courses with at least one enrollment.  If false, include only courses with no enrollments.  If not present, do not filter on course enrollment status.
        :param list[str] enrollment_type: If set, only return courses that have at least one user enrolled in in the course with one of the specified enrollment types.
        :param bool published: If true, include only published courses.  If false, exclude published courses.  If not present, do not filter on published status.
        :param bool completed: If true, include only completed courses (these may be in state 'completed', or their enrollment term may have ended).  If false, exclude completed courses.  If not present, do not filter on completed status.
        :param bool blueprint: If true, include only blueprint courses. If false, exclude them. If not present, do not filter on this basis.
        :param bool blueprint_associated: If true, include only courses that inherit content from a blueprint course. If false, exclude them. If not present, do not filter on this basis.
        :param bool public: If true, include only public courses. If false, exclude them. If not present, do not filter on this basis.
        :param list[int] by_teachers: List of User IDs of teachers; if supplied, include only courses taught by one of the referenced users.
        :param list[int] by_subaccounts: List of Account IDs; if supplied, include only courses associated with one of the referenced subaccounts.
        :param bool hide_enrollmentless_courses: If present, only return courses that have at least one enrollment. Equivalent to 'with_enrollments=true'; retained for compatibility.
        :param list[str] state: If set, only return courses that are in the given state(s). By default, all states but \"deleted\" are returned.
        :param int enrollment_term_id: If set, only includes courses from the specified term.
        :param str search_term: The partial course name, code, or full ID to match and return in the results list. Must be at least 3 characters.
        :param list[str] include: - All explanations can be seen in the {api:CoursesController#index Course API index documentation} - \"sections\", \"needs_grading_count\" and \"total_scores\" are not valid options at the account level
        :param str sort: The column to sort results by.
        :param str order: The order to sort the given column by.
        :param str search_by: The filter to search by. \"course\" searches for course names, course codes, and SIS IDs. \"teacher\" searches for teacher names
        :param Object starts_before: If set, only return courses that start before the value (inclusive) or their enrollment term starts before the value (inclusive) or both the course's start_at and the enrollment term's start_at are set to null. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
        :param Object ends_after: If set, only return courses that end after the value (inclusive) or their enrollment term ends after the value (inclusive) or both the course's end_at and the enrollment term's end_at are set to null. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
        :param bool homeroom: If set, only return homeroom courses.
        :return: list[Course]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'with_enrollments', 'enrollment_type', 'published', 'completed', 'blueprint', 'blueprint_associated', 'public', 'by_teachers', 'by_subaccounts', 'hide_enrollmentless_courses', 'state', 'enrollment_term_id', 'search_term', 'include', 'sort', 'order', 'search_by', 'starts_before', 'ends_after', 'homeroom']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_active_courses_in_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `list_active_courses_in_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'with_enrollments' in params:
            query_params.append(('with_enrollments', params['with_enrollments']))  # noqa: E501
        if 'enrollment_type' in params:
            query_params.append(('enrollment_type', params['enrollment_type']))  # noqa: E501
            collection_formats['enrollment_type'] = 'csv'  # noqa: E501
        if 'published' in params:
            query_params.append(('published', params['published']))  # noqa: E501
        if 'completed' in params:
            query_params.append(('completed', params['completed']))  # noqa: E501
        if 'blueprint' in params:
            query_params.append(('blueprint', params['blueprint']))  # noqa: E501
        if 'blueprint_associated' in params:
            query_params.append(('blueprint_associated', params['blueprint_associated']))  # noqa: E501
        if 'public' in params:
            query_params.append(('public', params['public']))  # noqa: E501
        if 'by_teachers' in params:
            query_params.append(('by_teachers', params['by_teachers']))  # noqa: E501
            collection_formats['by_teachers'] = 'csv'  # noqa: E501
        if 'by_subaccounts' in params:
            query_params.append(('by_subaccounts', params['by_subaccounts']))  # noqa: E501
            collection_formats['by_subaccounts'] = 'csv'  # noqa: E501
        if 'hide_enrollmentless_courses' in params:
            query_params.append(('hide_enrollmentless_courses', params['hide_enrollmentless_courses']))  # noqa: E501
        if 'state' in params:
            query_params.append(('state', params['state']))  # noqa: E501
            collection_formats['state'] = 'csv'  # noqa: E501
        if 'enrollment_term_id' in params:
            query_params.append(('enrollment_term_id', params['enrollment_term_id']))  # noqa: E501
        if 'search_term' in params:
            query_params.append(('search_term', params['search_term']))  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'order' in params:
            query_params.append(('order', params['order']))  # noqa: E501
        if 'search_by' in params:
            query_params.append(('search_by', params['search_by']))  # noqa: E501
        if 'starts_before' in params:
            query_params.append(('starts_before', params['starts_before']))  # noqa: E501
        if 'ends_after' in params:
            query_params.append(('ends_after', params['ends_after']))  # noqa: E501
        if 'homeroom' in params:
            query_params.append(('homeroom', params['homeroom']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/courses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Course]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_environment_settings(self, **kwargs):  # noqa: E501
        """List environment settings  # noqa: E501

        Return a hash of global settings for the root account This is the same information supplied to the web interface as +ENV.SETTINGS+.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_environment_settings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_environment_settings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_environment_settings_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_environment_settings_with_http_info(self, **kwargs):  # noqa: E501
        """List environment settings  # noqa: E501

        Return a hash of global settings for the root account This is the same information supplied to the web interface as +ENV.SETTINGS+.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_environment_settings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_environment_settings" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/settings/environment', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def permissions(self, account_id, **kwargs):  # noqa: E501
        """Permissions  # noqa: E501

        Returns permission information for the calling user and the given account. You may use `self` as the account id to check permissions against the domain root account. The caller must have an account role or admin (teacher/TA/designer) enrollment in a course in the account.  See also the {api:CoursesController#permissions Course} and {api:GroupsController#permissions Group} counterparts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.permissions(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param list[str] permissions: List of permissions to check against the authenticated user. Permission names are documented in the {api:RoleOverridesController#add_role Create a role} endpoint.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.permissions_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.permissions_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def permissions_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Permissions  # noqa: E501

        Returns permission information for the calling user and the given account. You may use `self` as the account id to check permissions against the domain root account. The caller must have an account role or admin (teacher/TA/designer) enrollment in a course in the account.  See also the {api:CoursesController#permissions Course} and {api:GroupsController#permissions Group} counterparts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.permissions_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param list[str] permissions: List of permissions to check against the authenticated user. Permission names are documented in the {api:RoleOverridesController#add_role Create a role} endpoint.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'permissions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method permissions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `permissions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'permissions' in params:
            query_params.append(('permissions', params['permissions']))  # noqa: E501
            collection_formats['permissions'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/permissions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def restore_deleted_user_from_root_account(self, account_id, user_id, **kwargs):  # noqa: E501
        """Restore a deleted user from a root account  # noqa: E501

        Restore a user record along with the most recently deleted pseudonym from a Canvas root account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restore_deleted_user_from_root_account(account_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str user_id: ID (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.restore_deleted_user_from_root_account_with_http_info(account_id, user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.restore_deleted_user_from_root_account_with_http_info(account_id, user_id, **kwargs)  # noqa: E501
            return data

    def restore_deleted_user_from_root_account_with_http_info(self, account_id, user_id, **kwargs):  # noqa: E501
        """Restore a deleted user from a root account  # noqa: E501

        Restore a user record along with the most recently deleted pseudonym from a Canvas root account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restore_deleted_user_from_root_account_with_http_info(account_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str user_id: ID (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restore_deleted_user_from_root_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `restore_deleted_user_from_root_account`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `restore_deleted_user_from_root_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/users/{user_id}/restore', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def settings(self, account_id, **kwargs):  # noqa: E501
        """Settings  # noqa: E501

        Returns a JSON object containing a subset of settings for the specified account. It's possible an empty set will be returned if no settings are applicable. The caller must be an Account admin with the manage_account_settings permission.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.settings(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.settings_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.settings_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def settings_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Settings  # noqa: E501

        Returns a JSON object containing a subset of settings for the specified account. It's possible an empty set will be returned if no settings are applicable. The caller must be an Account admin with the manage_account_settings permission.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.settings_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/settings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_account(self, id, **kwargs):  # noqa: E501
        """Update an account  # noqa: E501

        Update an existing account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_account(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str account_name: Updates the account name
        :param str account_sis_account_id: Updates the account sis_account_id Must have manage_sis permission and must not be a root_account.
        :param str account_default_time_zone: The default time zone of the account. Allowed time zones are {http://www.iana.org/time-zones IANA time zones} or friendlier {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
        :param int account_default_storage_quota_mb: The default course storage quota to be used, if not otherwise specified.
        :param int account_default_user_storage_quota_mb: The default user storage quota to be used, if not otherwise specified.
        :param int account_default_group_storage_quota_mb: The default group storage quota to be used, if not otherwise specified.
        :param int account_course_template_id: The ID of a course to be used as a template for all newly created courses. Empty means to inherit the setting from parent account, 0 means to not use a template even if a parent account has one set. The course must be marked as a template.
        :param bool account_settings_restrict_student_past_view_value: Restrict students from viewing courses after end date
        :param bool account_settings_restrict_student_past_view_locked: Lock this setting for sub-accounts and courses
        :param bool account_settings_restrict_student_future_view_value: Restrict students from viewing courses before start date
        :param bool account_settings_microsoft_sync_enabled: Determines whether this account has Microsoft Teams Sync enabled or not.  Note that if you are altering Microsoft Teams sync settings you must enable the Microsoft Group enrollment syncing feature flag. In addition, if you are enabling Microsoft Teams sync, you must also specify a tenant, login attribute, and a remote attribute. Specifying a suffix to use is optional.
        :param str account_settings_microsoft_sync_tenant: The tenant this account should use when using Microsoft Teams Sync. This should be an Azure Active Directory domain name.
        :param str account_settings_microsoft_sync_login_attribute: The attribute this account should use to lookup users when using Microsoft Teams Sync. Must be one of \"sub\", \"email\", \"oid\", \"preferred_username\", or \"integration_id\".
        :param str account_settings_microsoft_sync_login_attribute_suffix: A suffix that will be appended to the result of the login attribute when associating Canvas users with Microsoft users. Must be under 255 characters and contain no whitespace. This field is optional.
        :param str account_settings_microsoft_sync_remote_attribute: The Active Directory attribute to use when associating Canvas users with Microsoft users. Must be one of \"mail\", \"mailNickname\", or \"userPrincipalName\".
        :param bool account_settings_restrict_student_future_view_locked: Lock this setting for sub-accounts and courses
        :param bool account_settings_lock_all_announcements_value: Disable comments on announcements
        :param bool account_settings_lock_all_announcements_locked: Lock this setting for sub-accounts and courses
        :param bool account_settings_usage_rights_required_value: Copyright and license information must be provided for files before they are published.
        :param bool account_settings_usage_rights_required_locked: Lock this setting for sub-accounts and courses
        :param bool account_settings_restrict_student_future_listing_value: Restrict students from viewing future enrollments in course list
        :param bool account_settings_restrict_student_future_listing_locked: Lock this setting for sub-accounts and courses
        :param bool account_settings_conditional_release_value: Enable or disable individual learning paths for students based on assessment
        :param bool account_settings_conditional_release_locked: Lock this setting for sub-accounts and courses
        :param Object account_settings_password_policy: Hash of optional password policy configuration parameters for a root account  +allow_login_suspension+ boolean:: Allow suspension of user logins upon reaching maximum_login_attempts  +require_number_characters+ boolean:: Require the use of number characters when setting up a new password  +require_symbol_characters+ boolean:: Require the use of symbol characters when setting up a new password  +minimum_character_length+ integer:: Minimum number of characters required for a new password  +maximum_login_attempts+ integer:: Maximum number of login attempts before a user is locked out  _Required_ feature option:   Enhance password options
        :param bool override_sis_stickiness: Default is true. If false, any fields containing “sticky” changes will not be updated. See SIS CSV Format documentation for information on which fields can have SIS stickiness
        :param bool account_settings_lock_outcome_proficiency_value: [DEPRECATED] Restrict instructors from changing mastery scale
        :param bool account_lock_outcome_proficiency_locked: [DEPRECATED] Lock this setting for sub-accounts and courses
        :param bool account_settings_lock_proficiency_calculation_value: [DEPRECATED] Restrict instructors from changing proficiency calculation method
        :param bool account_lock_proficiency_calculation_locked: [DEPRECATED] Lock this setting for sub-accounts and courses
        :param Object account_services: Give this a set of keys and boolean values to enable or disable services matching the keys
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_account_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_account_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_account_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update an account  # noqa: E501

        Update an existing account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_account_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str account_name: Updates the account name
        :param str account_sis_account_id: Updates the account sis_account_id Must have manage_sis permission and must not be a root_account.
        :param str account_default_time_zone: The default time zone of the account. Allowed time zones are {http://www.iana.org/time-zones IANA time zones} or friendlier {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
        :param int account_default_storage_quota_mb: The default course storage quota to be used, if not otherwise specified.
        :param int account_default_user_storage_quota_mb: The default user storage quota to be used, if not otherwise specified.
        :param int account_default_group_storage_quota_mb: The default group storage quota to be used, if not otherwise specified.
        :param int account_course_template_id: The ID of a course to be used as a template for all newly created courses. Empty means to inherit the setting from parent account, 0 means to not use a template even if a parent account has one set. The course must be marked as a template.
        :param bool account_settings_restrict_student_past_view_value: Restrict students from viewing courses after end date
        :param bool account_settings_restrict_student_past_view_locked: Lock this setting for sub-accounts and courses
        :param bool account_settings_restrict_student_future_view_value: Restrict students from viewing courses before start date
        :param bool account_settings_microsoft_sync_enabled: Determines whether this account has Microsoft Teams Sync enabled or not.  Note that if you are altering Microsoft Teams sync settings you must enable the Microsoft Group enrollment syncing feature flag. In addition, if you are enabling Microsoft Teams sync, you must also specify a tenant, login attribute, and a remote attribute. Specifying a suffix to use is optional.
        :param str account_settings_microsoft_sync_tenant: The tenant this account should use when using Microsoft Teams Sync. This should be an Azure Active Directory domain name.
        :param str account_settings_microsoft_sync_login_attribute: The attribute this account should use to lookup users when using Microsoft Teams Sync. Must be one of \"sub\", \"email\", \"oid\", \"preferred_username\", or \"integration_id\".
        :param str account_settings_microsoft_sync_login_attribute_suffix: A suffix that will be appended to the result of the login attribute when associating Canvas users with Microsoft users. Must be under 255 characters and contain no whitespace. This field is optional.
        :param str account_settings_microsoft_sync_remote_attribute: The Active Directory attribute to use when associating Canvas users with Microsoft users. Must be one of \"mail\", \"mailNickname\", or \"userPrincipalName\".
        :param bool account_settings_restrict_student_future_view_locked: Lock this setting for sub-accounts and courses
        :param bool account_settings_lock_all_announcements_value: Disable comments on announcements
        :param bool account_settings_lock_all_announcements_locked: Lock this setting for sub-accounts and courses
        :param bool account_settings_usage_rights_required_value: Copyright and license information must be provided for files before they are published.
        :param bool account_settings_usage_rights_required_locked: Lock this setting for sub-accounts and courses
        :param bool account_settings_restrict_student_future_listing_value: Restrict students from viewing future enrollments in course list
        :param bool account_settings_restrict_student_future_listing_locked: Lock this setting for sub-accounts and courses
        :param bool account_settings_conditional_release_value: Enable or disable individual learning paths for students based on assessment
        :param bool account_settings_conditional_release_locked: Lock this setting for sub-accounts and courses
        :param Object account_settings_password_policy: Hash of optional password policy configuration parameters for a root account  +allow_login_suspension+ boolean:: Allow suspension of user logins upon reaching maximum_login_attempts  +require_number_characters+ boolean:: Require the use of number characters when setting up a new password  +require_symbol_characters+ boolean:: Require the use of symbol characters when setting up a new password  +minimum_character_length+ integer:: Minimum number of characters required for a new password  +maximum_login_attempts+ integer:: Maximum number of login attempts before a user is locked out  _Required_ feature option:   Enhance password options
        :param bool override_sis_stickiness: Default is true. If false, any fields containing “sticky” changes will not be updated. See SIS CSV Format documentation for information on which fields can have SIS stickiness
        :param bool account_settings_lock_outcome_proficiency_value: [DEPRECATED] Restrict instructors from changing mastery scale
        :param bool account_lock_outcome_proficiency_locked: [DEPRECATED] Lock this setting for sub-accounts and courses
        :param bool account_settings_lock_proficiency_calculation_value: [DEPRECATED] Restrict instructors from changing proficiency calculation method
        :param bool account_lock_proficiency_calculation_locked: [DEPRECATED] Lock this setting for sub-accounts and courses
        :param Object account_services: Give this a set of keys and boolean values to enable or disable services matching the keys
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'account_name', 'account_sis_account_id', 'account_default_time_zone', 'account_default_storage_quota_mb', 'account_default_user_storage_quota_mb', 'account_default_group_storage_quota_mb', 'account_course_template_id', 'account_settings_restrict_student_past_view_value', 'account_settings_restrict_student_past_view_locked', 'account_settings_restrict_student_future_view_value', 'account_settings_microsoft_sync_enabled', 'account_settings_microsoft_sync_tenant', 'account_settings_microsoft_sync_login_attribute', 'account_settings_microsoft_sync_login_attribute_suffix', 'account_settings_microsoft_sync_remote_attribute', 'account_settings_restrict_student_future_view_locked', 'account_settings_lock_all_announcements_value', 'account_settings_lock_all_announcements_locked', 'account_settings_usage_rights_required_value', 'account_settings_usage_rights_required_locked', 'account_settings_restrict_student_future_listing_value', 'account_settings_restrict_student_future_listing_locked', 'account_settings_conditional_release_value', 'account_settings_conditional_release_locked', 'account_settings_password_policy', 'override_sis_stickiness', 'account_settings_lock_outcome_proficiency_value', 'account_lock_outcome_proficiency_locked', 'account_settings_lock_proficiency_calculation_value', 'account_lock_proficiency_calculation_locked', 'account_services']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'account_name' in params:
            form_params.append(('account[name]', params['account_name']))  # noqa: E501
        if 'account_sis_account_id' in params:
            form_params.append(('account[sis_account_id]', params['account_sis_account_id']))  # noqa: E501
        if 'account_default_time_zone' in params:
            form_params.append(('account[default_time_zone]', params['account_default_time_zone']))  # noqa: E501
        if 'account_default_storage_quota_mb' in params:
            form_params.append(('account[default_storage_quota_mb]', params['account_default_storage_quota_mb']))  # noqa: E501
        if 'account_default_user_storage_quota_mb' in params:
            form_params.append(('account[default_user_storage_quota_mb]', params['account_default_user_storage_quota_mb']))  # noqa: E501
        if 'account_default_group_storage_quota_mb' in params:
            form_params.append(('account[default_group_storage_quota_mb]', params['account_default_group_storage_quota_mb']))  # noqa: E501
        if 'account_course_template_id' in params:
            form_params.append(('account[course_template_id]', params['account_course_template_id']))  # noqa: E501
        if 'account_settings_restrict_student_past_view_value' in params:
            form_params.append(('account[settings][restrict_student_past_view][value]', params['account_settings_restrict_student_past_view_value']))  # noqa: E501
        if 'account_settings_restrict_student_past_view_locked' in params:
            form_params.append(('account[settings][restrict_student_past_view][locked]', params['account_settings_restrict_student_past_view_locked']))  # noqa: E501
        if 'account_settings_restrict_student_future_view_value' in params:
            form_params.append(('account[settings][restrict_student_future_view][value]', params['account_settings_restrict_student_future_view_value']))  # noqa: E501
        if 'account_settings_microsoft_sync_enabled' in params:
            form_params.append(('account[settings][microsoft_sync_enabled]', params['account_settings_microsoft_sync_enabled']))  # noqa: E501
        if 'account_settings_microsoft_sync_tenant' in params:
            form_params.append(('account[settings][microsoft_sync_tenant]', params['account_settings_microsoft_sync_tenant']))  # noqa: E501
        if 'account_settings_microsoft_sync_login_attribute' in params:
            form_params.append(('account[settings][microsoft_sync_login_attribute]', params['account_settings_microsoft_sync_login_attribute']))  # noqa: E501
        if 'account_settings_microsoft_sync_login_attribute_suffix' in params:
            form_params.append(('account[settings][microsoft_sync_login_attribute_suffix]', params['account_settings_microsoft_sync_login_attribute_suffix']))  # noqa: E501
        if 'account_settings_microsoft_sync_remote_attribute' in params:
            form_params.append(('account[settings][microsoft_sync_remote_attribute]', params['account_settings_microsoft_sync_remote_attribute']))  # noqa: E501
        if 'account_settings_restrict_student_future_view_locked' in params:
            form_params.append(('account[settings][restrict_student_future_view][locked]', params['account_settings_restrict_student_future_view_locked']))  # noqa: E501
        if 'account_settings_lock_all_announcements_value' in params:
            form_params.append(('account[settings][lock_all_announcements][value]', params['account_settings_lock_all_announcements_value']))  # noqa: E501
        if 'account_settings_lock_all_announcements_locked' in params:
            form_params.append(('account[settings][lock_all_announcements][locked]', params['account_settings_lock_all_announcements_locked']))  # noqa: E501
        if 'account_settings_usage_rights_required_value' in params:
            form_params.append(('account[settings][usage_rights_required][value]', params['account_settings_usage_rights_required_value']))  # noqa: E501
        if 'account_settings_usage_rights_required_locked' in params:
            form_params.append(('account[settings][usage_rights_required][locked]', params['account_settings_usage_rights_required_locked']))  # noqa: E501
        if 'account_settings_restrict_student_future_listing_value' in params:
            form_params.append(('account[settings][restrict_student_future_listing][value]', params['account_settings_restrict_student_future_listing_value']))  # noqa: E501
        if 'account_settings_restrict_student_future_listing_locked' in params:
            form_params.append(('account[settings][restrict_student_future_listing][locked]', params['account_settings_restrict_student_future_listing_locked']))  # noqa: E501
        if 'account_settings_conditional_release_value' in params:
            form_params.append(('account[settings][conditional_release][value]', params['account_settings_conditional_release_value']))  # noqa: E501
        if 'account_settings_conditional_release_locked' in params:
            form_params.append(('account[settings][conditional_release][locked]', params['account_settings_conditional_release_locked']))  # noqa: E501
        if 'account_settings_password_policy' in params:
            form_params.append(('account[settings][password_policy]', params['account_settings_password_policy']))  # noqa: E501
        if 'override_sis_stickiness' in params:
            form_params.append(('override_sis_stickiness', params['override_sis_stickiness']))  # noqa: E501
        if 'account_settings_lock_outcome_proficiency_value' in params:
            form_params.append(('account[settings][lock_outcome_proficiency][value]', params['account_settings_lock_outcome_proficiency_value']))  # noqa: E501
        if 'account_lock_outcome_proficiency_locked' in params:
            form_params.append(('account[lock_outcome_proficiency][locked]', params['account_lock_outcome_proficiency_locked']))  # noqa: E501
        if 'account_settings_lock_proficiency_calculation_value' in params:
            form_params.append(('account[settings][lock_proficiency_calculation][value]', params['account_settings_lock_proficiency_calculation_value']))  # noqa: E501
        if 'account_lock_proficiency_calculation_locked' in params:
            form_params.append(('account[lock_proficiency_calculation][locked]', params['account_lock_proficiency_calculation_locked']))  # noqa: E501
        if 'account_services' in params:
            form_params.append(('account[services]', params['account_services']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Account',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
