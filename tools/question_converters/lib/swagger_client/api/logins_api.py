# coding: utf-8

"""

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class LoginsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_user_login(self, account_id, user_id, login_unique_id, **kwargs):  # noqa: E501
        """Create a user login  # noqa: E501

        Create a new login for an existing user in the given account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_user_login(account_id, user_id, login_unique_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str user_id: The ID of the user to create the login for. (required)
        :param str login_unique_id: The unique ID for the new login. (required)
        :param str login_password: The new login's password.
        :param str login_sis_user_id: SIS ID for the login. To set this parameter, the caller must be able to manage SIS permissions on the account.
        :param str login_integration_id: Integration ID for the login. To set this parameter, the caller must be able to manage SIS permissions on the account. The Integration ID is a secondary identifier useful for more complex SIS integrations.
        :param str login_authentication_provider_id: The authentication provider this login is associated with. Logins associated with a specific provider can only be used with that provider. Legacy providers (LDAP, CAS, SAML) will search for logins associated with them, or unassociated logins. New providers will only search for logins explicitly associated with them. This can be the integer ID of the provider, or the type of the provider (in which case, it will find the first matching provider).
        :param str login_declared_user_type: The declared intention of the user type. This can be set, but does not change any Canvas functionality with respect to their access. A user can still be a teacher, admin, student, etc. in any particular context without regard to this setting. This can be used for administrative purposes for integrations to be able to more easily identify why the user was created. Valid values are:   * administrative   * observer   * staff   * student   * student_other   * teacher
        :param str user_existing_user_id: A Canvas User ID to identify a user in a trusted account (alternative to `id`, `existing_sis_user_id`, or `existing_integration_id`). This parameter is not available in OSS Canvas.
        :param str user_existing_integration_id: An Integration ID to identify a user in a trusted account (alternative to `id`, `existing_user_id`, or `existing_sis_user_id`). This parameter is not available in OSS Canvas.
        :param str user_existing_sis_user_id: An SIS User ID to identify a user in a trusted account (alternative to `id`, `existing_integration_id`, or `existing_user_id`). This parameter is not available in OSS Canvas.
        :param str user_trusted_account: The domain of the account to search for the user. This field is required when identifying a user in a trusted account. This parameter is not available in OSS Canvas.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_user_login_with_http_info(account_id, user_id, login_unique_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_user_login_with_http_info(account_id, user_id, login_unique_id, **kwargs)  # noqa: E501
            return data

    def create_user_login_with_http_info(self, account_id, user_id, login_unique_id, **kwargs):  # noqa: E501
        """Create a user login  # noqa: E501

        Create a new login for an existing user in the given account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_user_login_with_http_info(account_id, user_id, login_unique_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str user_id: The ID of the user to create the login for. (required)
        :param str login_unique_id: The unique ID for the new login. (required)
        :param str login_password: The new login's password.
        :param str login_sis_user_id: SIS ID for the login. To set this parameter, the caller must be able to manage SIS permissions on the account.
        :param str login_integration_id: Integration ID for the login. To set this parameter, the caller must be able to manage SIS permissions on the account. The Integration ID is a secondary identifier useful for more complex SIS integrations.
        :param str login_authentication_provider_id: The authentication provider this login is associated with. Logins associated with a specific provider can only be used with that provider. Legacy providers (LDAP, CAS, SAML) will search for logins associated with them, or unassociated logins. New providers will only search for logins explicitly associated with them. This can be the integer ID of the provider, or the type of the provider (in which case, it will find the first matching provider).
        :param str login_declared_user_type: The declared intention of the user type. This can be set, but does not change any Canvas functionality with respect to their access. A user can still be a teacher, admin, student, etc. in any particular context without regard to this setting. This can be used for administrative purposes for integrations to be able to more easily identify why the user was created. Valid values are:   * administrative   * observer   * staff   * student   * student_other   * teacher
        :param str user_existing_user_id: A Canvas User ID to identify a user in a trusted account (alternative to `id`, `existing_sis_user_id`, or `existing_integration_id`). This parameter is not available in OSS Canvas.
        :param str user_existing_integration_id: An Integration ID to identify a user in a trusted account (alternative to `id`, `existing_user_id`, or `existing_sis_user_id`). This parameter is not available in OSS Canvas.
        :param str user_existing_sis_user_id: An SIS User ID to identify a user in a trusted account (alternative to `id`, `existing_integration_id`, or `existing_user_id`). This parameter is not available in OSS Canvas.
        :param str user_trusted_account: The domain of the account to search for the user. This field is required when identifying a user in a trusted account. This parameter is not available in OSS Canvas.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'user_id', 'login_unique_id', 'login_password', 'login_sis_user_id', 'login_integration_id', 'login_authentication_provider_id', 'login_declared_user_type', 'user_existing_user_id', 'user_existing_integration_id', 'user_existing_sis_user_id', 'user_trusted_account']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_user_login" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `create_user_login`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `create_user_login`")  # noqa: E501
        # verify the required parameter 'login_unique_id' is set
        if self.api_client.client_side_validation and ('login_unique_id' not in params or
                                                       params['login_unique_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `login_unique_id` when calling `create_user_login`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'user_id' in params:
            form_params.append(('user[id]', params['user_id']))  # noqa: E501
        if 'login_unique_id' in params:
            form_params.append(('login[unique_id]', params['login_unique_id']))  # noqa: E501
        if 'login_password' in params:
            form_params.append(('login[password]', params['login_password']))  # noqa: E501
        if 'login_sis_user_id' in params:
            form_params.append(('login[sis_user_id]', params['login_sis_user_id']))  # noqa: E501
        if 'login_integration_id' in params:
            form_params.append(('login[integration_id]', params['login_integration_id']))  # noqa: E501
        if 'login_authentication_provider_id' in params:
            form_params.append(('login[authentication_provider_id]', params['login_authentication_provider_id']))  # noqa: E501
        if 'login_declared_user_type' in params:
            form_params.append(('login[declared_user_type]', params['login_declared_user_type']))  # noqa: E501
        if 'user_existing_user_id' in params:
            form_params.append(('user[existing_user_id]', params['user_existing_user_id']))  # noqa: E501
        if 'user_existing_integration_id' in params:
            form_params.append(('user[existing_integration_id]', params['user_existing_integration_id']))  # noqa: E501
        if 'user_existing_sis_user_id' in params:
            form_params.append(('user[existing_sis_user_id]', params['user_existing_sis_user_id']))  # noqa: E501
        if 'user_trusted_account' in params:
            form_params.append(('user[trusted_account]', params['user_trusted_account']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/logins', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_login(self, user_id, id, **kwargs):  # noqa: E501
        """Delete a user login  # noqa: E501

        Delete an existing login.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user_login(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_user_login_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_login_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def delete_user_login_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Delete a user login  # noqa: E501

        Delete an existing login.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user_login_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_login" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `delete_user_login`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_user_login`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/logins/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_user_login(self, account_id, id, **kwargs):  # noqa: E501
        """Edit a user login  # noqa: E501

        Update an existing login for a user in the given account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_user_login(account_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str id: ID (required)
        :param str login_unique_id: The new unique ID for the login.
        :param str login_password: The new password for the login. Can only be set by an admin user if admins are allowed to change passwords for the account.
        :param str login_sis_user_id: SIS ID for the login. To set this parameter, the caller must be able to manage SIS permissions on the account.
        :param str login_integration_id: Integration ID for the login. To set this parameter, the caller must be able to manage SIS permissions on the account. The Integration ID is a secondary identifier useful for more complex SIS integrations.
        :param str login_authentication_provider_id: The authentication provider this login is associated with. Logins associated with a specific provider can only be used with that provider. Legacy providers (LDAP, CAS, SAML) will search for logins associated with them, or unassociated logins. New providers will only search for logins explicitly associated with them. This can be the integer ID of the provider, or the type of the provider (in which case, it will find the first matching provider).
        :param str login_workflow_state: Used to suspend or re-activate a login.
        :param str login_declared_user_type: The declared intention of the user type. This can be set, but does not change any Canvas functionality with respect to their access. A user can still be a teacher, admin, student, etc. in any particular context without regard to this setting. This can be used for administrative purposes for integrations to be able to more easily identify why the user was created. Valid values are:   * administrative   * observer   * staff   * student   * student_other   * teacher
        :param bool override_sis_stickiness: Default is true. If false, any fields containing “sticky” changes will not be updated. See SIS CSV Format documentation for information on which fields can have SIS stickiness
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_user_login_with_http_info(account_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_user_login_with_http_info(account_id, id, **kwargs)  # noqa: E501
            return data

    def edit_user_login_with_http_info(self, account_id, id, **kwargs):  # noqa: E501
        """Edit a user login  # noqa: E501

        Update an existing login for a user in the given account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_user_login_with_http_info(account_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str id: ID (required)
        :param str login_unique_id: The new unique ID for the login.
        :param str login_password: The new password for the login. Can only be set by an admin user if admins are allowed to change passwords for the account.
        :param str login_sis_user_id: SIS ID for the login. To set this parameter, the caller must be able to manage SIS permissions on the account.
        :param str login_integration_id: Integration ID for the login. To set this parameter, the caller must be able to manage SIS permissions on the account. The Integration ID is a secondary identifier useful for more complex SIS integrations.
        :param str login_authentication_provider_id: The authentication provider this login is associated with. Logins associated with a specific provider can only be used with that provider. Legacy providers (LDAP, CAS, SAML) will search for logins associated with them, or unassociated logins. New providers will only search for logins explicitly associated with them. This can be the integer ID of the provider, or the type of the provider (in which case, it will find the first matching provider).
        :param str login_workflow_state: Used to suspend or re-activate a login.
        :param str login_declared_user_type: The declared intention of the user type. This can be set, but does not change any Canvas functionality with respect to their access. A user can still be a teacher, admin, student, etc. in any particular context without regard to this setting. This can be used for administrative purposes for integrations to be able to more easily identify why the user was created. Valid values are:   * administrative   * observer   * staff   * student   * student_other   * teacher
        :param bool override_sis_stickiness: Default is true. If false, any fields containing “sticky” changes will not be updated. See SIS CSV Format documentation for information on which fields can have SIS stickiness
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'id', 'login_unique_id', 'login_password', 'login_sis_user_id', 'login_integration_id', 'login_authentication_provider_id', 'login_workflow_state', 'login_declared_user_type', 'override_sis_stickiness']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_user_login" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `edit_user_login`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `edit_user_login`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'login_unique_id' in params:
            form_params.append(('login[unique_id]', params['login_unique_id']))  # noqa: E501
        if 'login_password' in params:
            form_params.append(('login[password]', params['login_password']))  # noqa: E501
        if 'login_sis_user_id' in params:
            form_params.append(('login[sis_user_id]', params['login_sis_user_id']))  # noqa: E501
        if 'login_integration_id' in params:
            form_params.append(('login[integration_id]', params['login_integration_id']))  # noqa: E501
        if 'login_authentication_provider_id' in params:
            form_params.append(('login[authentication_provider_id]', params['login_authentication_provider_id']))  # noqa: E501
        if 'login_workflow_state' in params:
            form_params.append(('login[workflow_state]', params['login_workflow_state']))  # noqa: E501
        if 'login_declared_user_type' in params:
            form_params.append(('login[declared_user_type]', params['login_declared_user_type']))  # noqa: E501
        if 'override_sis_stickiness' in params:
            form_params.append(('override_sis_stickiness', params['override_sis_stickiness']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/logins/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def kickoff_password_recovery_flow(self, **kwargs):  # noqa: E501
        """Kickoff password recovery flow  # noqa: E501

        Given a user email, generate a nonce and email it to the user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.kickoff_password_recovery_flow(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.kickoff_password_recovery_flow_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.kickoff_password_recovery_flow_with_http_info(**kwargs)  # noqa: E501
            return data

    def kickoff_password_recovery_flow_with_http_info(self, **kwargs):  # noqa: E501
        """Kickoff password recovery flow  # noqa: E501

        Given a user email, generate a nonce and email it to the user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.kickoff_password_recovery_flow_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method kickoff_password_recovery_flow" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/reset_password', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_user_logins_accounts(self, account_id, **kwargs):  # noqa: E501
        """List user logins  # noqa: E501

        Given a user ID, return a paginated list of that user's logins for the given account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_user_logins_accounts(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_user_logins_accounts_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_user_logins_accounts_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def list_user_logins_accounts_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """List user logins  # noqa: E501

        Given a user ID, return a paginated list of that user's logins for the given account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_user_logins_accounts_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_user_logins_accounts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `list_user_logins_accounts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/logins', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_user_logins_users(self, user_id, **kwargs):  # noqa: E501
        """List user logins  # noqa: E501

        Given a user ID, return a paginated list of that user's logins for the given account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_user_logins_users(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_user_logins_users_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_user_logins_users_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def list_user_logins_users_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List user logins  # noqa: E501

        Given a user ID, return a paginated list of that user's logins for the given account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_user_logins_users_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_user_logins_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `list_user_logins_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/logins', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
