# coding: utf-8

"""

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class SisImportsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def abort_all_pending_sis_imports(self, account_id, **kwargs):  # noqa: E501
        """Abort all pending SIS imports  # noqa: E501

        Abort already created but not processed or processing SIS imports.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.abort_all_pending_sis_imports(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.abort_all_pending_sis_imports_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.abort_all_pending_sis_imports_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def abort_all_pending_sis_imports_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Abort all pending SIS imports  # noqa: E501

        Abort already created but not processed or processing SIS imports.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.abort_all_pending_sis_imports_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method abort_all_pending_sis_imports" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `abort_all_pending_sis_imports`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/sis_imports/abort_all_pending', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def abort_sis_import(self, account_id, id, **kwargs):  # noqa: E501
        """Abort SIS import  # noqa: E501

        Abort a SIS import that has not completed.  Aborting a sis batch that is running can take some time for every process to see the abort event. Subsequent sis batches begin to process 10 minutes after the abort to allow each process to clean up properly.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.abort_sis_import(account_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str id: ID (required)
        :return: SisImport
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.abort_sis_import_with_http_info(account_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.abort_sis_import_with_http_info(account_id, id, **kwargs)  # noqa: E501
            return data

    def abort_sis_import_with_http_info(self, account_id, id, **kwargs):  # noqa: E501
        """Abort SIS import  # noqa: E501

        Abort a SIS import that has not completed.  Aborting a sis batch that is running can take some time for every process to see the abort event. Subsequent sis batches begin to process 10 minutes after the abort to allow each process to clean up properly.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.abort_sis_import_with_http_info(account_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str id: ID (required)
        :return: SisImport
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method abort_sis_import" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `abort_sis_import`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `abort_sis_import`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/sis_imports/{id}/abort', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SisImport',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_current_importing_sis_import(self, account_id, **kwargs):  # noqa: E501
        """Get the current importing SIS import  # noqa: E501

        Returns the SIS imports that are currently processing for an account. If no imports are running, will return an empty array.  Example:   curl https://<canvas>/api/v1/accounts/<account_id>/sis_imports/importing \\     -H 'Authorization: Bearer <token>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_current_importing_sis_import(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :return: SisImport
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_current_importing_sis_import_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_current_importing_sis_import_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def get_current_importing_sis_import_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Get the current importing SIS import  # noqa: E501

        Returns the SIS imports that are currently processing for an account. If no imports are running, will return an empty array.  Example:   curl https://<canvas>/api/v1/accounts/<account_id>/sis_imports/importing \\     -H 'Authorization: Bearer <token>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_current_importing_sis_import_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :return: SisImport
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_current_importing_sis_import" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `get_current_importing_sis_import`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/sis_imports/importing', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SisImport',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sis_import_list(self, account_id, **kwargs):  # noqa: E501
        """Get SIS import list  # noqa: E501

        Returns the list of SIS imports for an account  Example:   curl https://<canvas>/api/v1/accounts/<account_id>/sis_imports \\     -H 'Authorization: Bearer <token>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sis_import_list(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param Object created_since: If set, only shows imports created after the specified date (use ISO8601 format)
        :param Object created_before: If set, only shows imports created before the specified date (use ISO8601 format)
        :param list[str] workflow_state: If set, only returns imports that are in the given state.
        :return: list[SisImport]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sis_import_list_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_sis_import_list_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def get_sis_import_list_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Get SIS import list  # noqa: E501

        Returns the list of SIS imports for an account  Example:   curl https://<canvas>/api/v1/accounts/<account_id>/sis_imports \\     -H 'Authorization: Bearer <token>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sis_import_list_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param Object created_since: If set, only shows imports created after the specified date (use ISO8601 format)
        :param Object created_before: If set, only shows imports created before the specified date (use ISO8601 format)
        :param list[str] workflow_state: If set, only returns imports that are in the given state.
        :return: list[SisImport]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'created_since', 'created_before', 'workflow_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sis_import_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `get_sis_import_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'created_since' in params:
            query_params.append(('created_since', params['created_since']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('created_before', params['created_before']))  # noqa: E501
        if 'workflow_state' in params:
            query_params.append(('workflow_state', params['workflow_state']))  # noqa: E501
            collection_formats['workflow_state'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/sis_imports', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SisImport]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sis_import_status(self, account_id, id, **kwargs):  # noqa: E501
        """Get SIS import status  # noqa: E501

        Get the status of an already created SIS import.    Examples:     curl https://<canvas>/api/v1/accounts/<account_id>/sis_imports/<sis_import_id> \\         -H 'Authorization: Bearer <token>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sis_import_status(account_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str id: ID (required)
        :return: SisImport
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sis_import_status_with_http_info(account_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_sis_import_status_with_http_info(account_id, id, **kwargs)  # noqa: E501
            return data

    def get_sis_import_status_with_http_info(self, account_id, id, **kwargs):  # noqa: E501
        """Get SIS import status  # noqa: E501

        Get the status of an already created SIS import.    Examples:     curl https://<canvas>/api/v1/accounts/<account_id>/sis_imports/<sis_import_id> \\         -H 'Authorization: Bearer <token>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sis_import_status_with_http_info(account_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str id: ID (required)
        :return: SisImport
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sis_import_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `get_sis_import_status`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_sis_import_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/sis_imports/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SisImport',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_sis_data(self, account_id, **kwargs):  # noqa: E501
        """Import SIS data  # noqa: E501

        Import SIS data into Canvas. Must be on a root account with SIS imports enabled.  For more information on the format that's expected here, please see the \"SIS CSV\" section in the API docs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_sis_data(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str import_type: Choose the data format for reading SIS data. With a standard Canvas install, this option can only be 'instructure_csv', and if unprovided, will be assumed to be so. Can be part of the query string.
        :param str attachment: There are two ways to post SIS import data - either via a multipart/form-data form-field-style attachment, or via a non-multipart raw post request.  'attachment' is required for multipart/form-data style posts. Assumed to be SIS data from a file upload form field named 'attachment'.  Examples:   curl -F attachment=@<filename> -H \"Authorization: Bearer <token>\" \\       https://<canvas>/api/v1/accounts/<account_id>/sis_imports.json?import_type=instructure_csv  If you decide to do a raw post, you can skip the 'attachment' argument, but you will then be required to provide a suitable Content-Type header. You are encouraged to also provide the 'extension' argument.  Examples:   curl -H 'Content-Type: application/octet-stream' --data-binary @<filename>.zip \\       -H \"Authorization: Bearer <token>\" \\       https://<canvas>/api/v1/accounts/<account_id>/sis_imports.json?import_type=instructure_csv&extension=zip    curl -H 'Content-Type: application/zip' --data-binary @<filename>.zip \\       -H \"Authorization: Bearer <token>\" \\       https://<canvas>/api/v1/accounts/<account_id>/sis_imports.json?import_type=instructure_csv    curl -H 'Content-Type: text/csv' --data-binary @<filename>.csv \\       -H \"Authorization: Bearer <token>\" \\       https://<canvas>/api/v1/accounts/<account_id>/sis_imports.json?import_type=instructure_csv    curl -H 'Content-Type: text/csv' --data-binary @<filename>.csv \\       -H \"Authorization: Bearer <token>\" \\       https://<canvas>/api/v1/accounts/<account_id>/sis_imports.json?import_type=instructure_csv&batch_mode=1&batch_mode_term_id=15  If the attachment is a zip file, the uncompressed file(s) cannot be 100x larger than the zip, or the import will fail. For example, if the zip file is 1KB but the total size of the uncompressed file(s) is 100KB or greater the import will fail. There is a hard cap of 50 GB.
        :param str extension: Recommended for raw post request style imports. This field will be used to distinguish between zip, xml, csv, and other file format extensions that would usually be provided with the filename in the multipart post request scenario. If not provided, this value will be inferred from the Content-Type, falling back to zip-file format if all else fails.
        :param bool batch_mode: If set, this SIS import will be run in batch mode, deleting any data previously imported via SIS that is not present in this latest import. See the SIS CSV Format page for details. Batch mode cannot be used with diffing.
        :param str batch_mode_term_id: Limit deletions to only this term. Required if batch mode is enabled.
        :param bool multi_term_batch_mode: Runs batch mode against all terms in terms file. Requires change_threshold.
        :param bool skip_deletes: When set the import will skip any deletes. This does not account for objects that are deleted during the batch mode cleanup process.
        :param bool override_sis_stickiness: Default is false. If true, any fields containing “sticky” or UI changes will be overridden. See SIS CSV Format documentation for information on which fields can have SIS stickiness
        :param bool add_sis_stickiness: This option, if present, will process all changes as if they were UI changes. This means that \"stickiness\" will be added to changed fields. This option is only processed if 'override_sis_stickiness' is also provided.
        :param bool clear_sis_stickiness: This option, if present, will clear \"stickiness\" from all fields touched by this import. Requires that 'override_sis_stickiness' is also provided. If 'add_sis_stickiness' is also provided, 'clear_sis_stickiness' will overrule the behavior of 'add_sis_stickiness'
        :param bool update_sis_id_if_login_claimed: This option, if present, will override the old (or non-existent) non-matching SIS ID with the new SIS ID in the upload, if a pseudonym is found from the login field and the SIS ID doesn't match.
        :param str diffing_data_set_identifier: If set on a CSV import, Canvas will attempt to optimize the SIS import by comparing this set of CSVs to the previous set that has the same data set identifier, and only applying the difference between the two. See the SIS CSV Format documentation for more details. Diffing cannot be used with batch_mode
        :param bool diffing_remaster_data_set: If true, and diffing_data_set_identifier is sent, this SIS import will be part of the data set, but diffing will not be performed. See the SIS CSV Format documentation for details.
        :param str diffing_drop_status: If diffing_drop_status is passed, this SIS import will use this status for enrollments that are not included in the sis_batch. Defaults to 'deleted'
        :param str diffing_user_remove_status: For users removed from one batch to the next one using the same diffing_data_set_identifier, set their status to the value of this argument. Defaults to 'deleted'.
        :param str batch_mode_enrollment_drop_status: If batch_mode_enrollment_drop_status is passed, this SIS import will use this status for enrollments that are not included in the sis_batch. This will have an effect if multi_term_batch_mode is set. Defaults to 'deleted' This will still mark courses and sections that are not included in the sis_batch as deleted, and subsequently enrollments in the deleted courses and sections as deleted.
        :param int change_threshold: If set with batch_mode, the batch cleanup process will not run if the number of items deleted is higher than the percentage set. If set to 10 and a term has 200 enrollments, and batch would delete more than 20 of the enrollments the batch will abort before the enrollments are deleted. The change_threshold will be evaluated for course, sections, and enrollments independently. If set with diffing, diffing will not be performed if the files are greater than the threshold as a percent. If set to 5 and the file is more than 5% smaller or more than 5% larger than the file that is being compared to, diffing will not be performed. If the files are less than 5%, diffing will be performed. The way the percent is calculated is by taking the size of the current import and dividing it by the size of the previous import. The formula used is: |(1 - current_file_size / previous_file_size)| * 100 See the SIS CSV Format documentation for more details. Required for multi_term_batch_mode.
        :param int diff_row_count_threshold: If set with diffing, diffing will not be performed if the number of rows to be run in the fully calculated diff import exceeds the threshold.
        :return: SisImport
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_sis_data_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.import_sis_data_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def import_sis_data_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Import SIS data  # noqa: E501

        Import SIS data into Canvas. Must be on a root account with SIS imports enabled.  For more information on the format that's expected here, please see the \"SIS CSV\" section in the API docs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_sis_data_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str import_type: Choose the data format for reading SIS data. With a standard Canvas install, this option can only be 'instructure_csv', and if unprovided, will be assumed to be so. Can be part of the query string.
        :param str attachment: There are two ways to post SIS import data - either via a multipart/form-data form-field-style attachment, or via a non-multipart raw post request.  'attachment' is required for multipart/form-data style posts. Assumed to be SIS data from a file upload form field named 'attachment'.  Examples:   curl -F attachment=@<filename> -H \"Authorization: Bearer <token>\" \\       https://<canvas>/api/v1/accounts/<account_id>/sis_imports.json?import_type=instructure_csv  If you decide to do a raw post, you can skip the 'attachment' argument, but you will then be required to provide a suitable Content-Type header. You are encouraged to also provide the 'extension' argument.  Examples:   curl -H 'Content-Type: application/octet-stream' --data-binary @<filename>.zip \\       -H \"Authorization: Bearer <token>\" \\       https://<canvas>/api/v1/accounts/<account_id>/sis_imports.json?import_type=instructure_csv&extension=zip    curl -H 'Content-Type: application/zip' --data-binary @<filename>.zip \\       -H \"Authorization: Bearer <token>\" \\       https://<canvas>/api/v1/accounts/<account_id>/sis_imports.json?import_type=instructure_csv    curl -H 'Content-Type: text/csv' --data-binary @<filename>.csv \\       -H \"Authorization: Bearer <token>\" \\       https://<canvas>/api/v1/accounts/<account_id>/sis_imports.json?import_type=instructure_csv    curl -H 'Content-Type: text/csv' --data-binary @<filename>.csv \\       -H \"Authorization: Bearer <token>\" \\       https://<canvas>/api/v1/accounts/<account_id>/sis_imports.json?import_type=instructure_csv&batch_mode=1&batch_mode_term_id=15  If the attachment is a zip file, the uncompressed file(s) cannot be 100x larger than the zip, or the import will fail. For example, if the zip file is 1KB but the total size of the uncompressed file(s) is 100KB or greater the import will fail. There is a hard cap of 50 GB.
        :param str extension: Recommended for raw post request style imports. This field will be used to distinguish between zip, xml, csv, and other file format extensions that would usually be provided with the filename in the multipart post request scenario. If not provided, this value will be inferred from the Content-Type, falling back to zip-file format if all else fails.
        :param bool batch_mode: If set, this SIS import will be run in batch mode, deleting any data previously imported via SIS that is not present in this latest import. See the SIS CSV Format page for details. Batch mode cannot be used with diffing.
        :param str batch_mode_term_id: Limit deletions to only this term. Required if batch mode is enabled.
        :param bool multi_term_batch_mode: Runs batch mode against all terms in terms file. Requires change_threshold.
        :param bool skip_deletes: When set the import will skip any deletes. This does not account for objects that are deleted during the batch mode cleanup process.
        :param bool override_sis_stickiness: Default is false. If true, any fields containing “sticky” or UI changes will be overridden. See SIS CSV Format documentation for information on which fields can have SIS stickiness
        :param bool add_sis_stickiness: This option, if present, will process all changes as if they were UI changes. This means that \"stickiness\" will be added to changed fields. This option is only processed if 'override_sis_stickiness' is also provided.
        :param bool clear_sis_stickiness: This option, if present, will clear \"stickiness\" from all fields touched by this import. Requires that 'override_sis_stickiness' is also provided. If 'add_sis_stickiness' is also provided, 'clear_sis_stickiness' will overrule the behavior of 'add_sis_stickiness'
        :param bool update_sis_id_if_login_claimed: This option, if present, will override the old (or non-existent) non-matching SIS ID with the new SIS ID in the upload, if a pseudonym is found from the login field and the SIS ID doesn't match.
        :param str diffing_data_set_identifier: If set on a CSV import, Canvas will attempt to optimize the SIS import by comparing this set of CSVs to the previous set that has the same data set identifier, and only applying the difference between the two. See the SIS CSV Format documentation for more details. Diffing cannot be used with batch_mode
        :param bool diffing_remaster_data_set: If true, and diffing_data_set_identifier is sent, this SIS import will be part of the data set, but diffing will not be performed. See the SIS CSV Format documentation for details.
        :param str diffing_drop_status: If diffing_drop_status is passed, this SIS import will use this status for enrollments that are not included in the sis_batch. Defaults to 'deleted'
        :param str diffing_user_remove_status: For users removed from one batch to the next one using the same diffing_data_set_identifier, set their status to the value of this argument. Defaults to 'deleted'.
        :param str batch_mode_enrollment_drop_status: If batch_mode_enrollment_drop_status is passed, this SIS import will use this status for enrollments that are not included in the sis_batch. This will have an effect if multi_term_batch_mode is set. Defaults to 'deleted' This will still mark courses and sections that are not included in the sis_batch as deleted, and subsequently enrollments in the deleted courses and sections as deleted.
        :param int change_threshold: If set with batch_mode, the batch cleanup process will not run if the number of items deleted is higher than the percentage set. If set to 10 and a term has 200 enrollments, and batch would delete more than 20 of the enrollments the batch will abort before the enrollments are deleted. The change_threshold will be evaluated for course, sections, and enrollments independently. If set with diffing, diffing will not be performed if the files are greater than the threshold as a percent. If set to 5 and the file is more than 5% smaller or more than 5% larger than the file that is being compared to, diffing will not be performed. If the files are less than 5%, diffing will be performed. The way the percent is calculated is by taking the size of the current import and dividing it by the size of the previous import. The formula used is: |(1 - current_file_size / previous_file_size)| * 100 See the SIS CSV Format documentation for more details. Required for multi_term_batch_mode.
        :param int diff_row_count_threshold: If set with diffing, diffing will not be performed if the number of rows to be run in the fully calculated diff import exceeds the threshold.
        :return: SisImport
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'import_type', 'attachment', 'extension', 'batch_mode', 'batch_mode_term_id', 'multi_term_batch_mode', 'skip_deletes', 'override_sis_stickiness', 'add_sis_stickiness', 'clear_sis_stickiness', 'update_sis_id_if_login_claimed', 'diffing_data_set_identifier', 'diffing_remaster_data_set', 'diffing_drop_status', 'diffing_user_remove_status', 'batch_mode_enrollment_drop_status', 'change_threshold', 'diff_row_count_threshold']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_sis_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `import_sis_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'import_type' in params:
            form_params.append(('import_type', params['import_type']))  # noqa: E501
        if 'attachment' in params:
            form_params.append(('attachment', params['attachment']))  # noqa: E501
        if 'extension' in params:
            form_params.append(('extension', params['extension']))  # noqa: E501
        if 'batch_mode' in params:
            form_params.append(('batch_mode', params['batch_mode']))  # noqa: E501
        if 'batch_mode_term_id' in params:
            form_params.append(('batch_mode_term_id', params['batch_mode_term_id']))  # noqa: E501
        if 'multi_term_batch_mode' in params:
            form_params.append(('multi_term_batch_mode', params['multi_term_batch_mode']))  # noqa: E501
        if 'skip_deletes' in params:
            form_params.append(('skip_deletes', params['skip_deletes']))  # noqa: E501
        if 'override_sis_stickiness' in params:
            form_params.append(('override_sis_stickiness', params['override_sis_stickiness']))  # noqa: E501
        if 'add_sis_stickiness' in params:
            form_params.append(('add_sis_stickiness', params['add_sis_stickiness']))  # noqa: E501
        if 'clear_sis_stickiness' in params:
            form_params.append(('clear_sis_stickiness', params['clear_sis_stickiness']))  # noqa: E501
        if 'update_sis_id_if_login_claimed' in params:
            form_params.append(('update_sis_id_if_login_claimed', params['update_sis_id_if_login_claimed']))  # noqa: E501
        if 'diffing_data_set_identifier' in params:
            form_params.append(('diffing_data_set_identifier', params['diffing_data_set_identifier']))  # noqa: E501
        if 'diffing_remaster_data_set' in params:
            form_params.append(('diffing_remaster_data_set', params['diffing_remaster_data_set']))  # noqa: E501
        if 'diffing_drop_status' in params:
            form_params.append(('diffing_drop_status', params['diffing_drop_status']))  # noqa: E501
        if 'diffing_user_remove_status' in params:
            form_params.append(('diffing_user_remove_status', params['diffing_user_remove_status']))  # noqa: E501
        if 'batch_mode_enrollment_drop_status' in params:
            form_params.append(('batch_mode_enrollment_drop_status', params['batch_mode_enrollment_drop_status']))  # noqa: E501
        if 'change_threshold' in params:
            form_params.append(('change_threshold', params['change_threshold']))  # noqa: E501
        if 'diff_row_count_threshold' in params:
            form_params.append(('diff_row_count_threshold', params['diff_row_count_threshold']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/sis_imports', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SisImport',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def restore_workflow_states_of_sis_imported_items(self, account_id, id, **kwargs):  # noqa: E501
        """Restore workflow_states of SIS imported items  # noqa: E501

        This will restore the the workflow_state for all the items that changed their workflow_state during the import being restored. This will restore states for items imported with the following importers: accounts.csv terms.csv courses.csv sections.csv group_categories.csv groups.csv users.csv admins.csv This also restores states for other items that changed during the import. An example would be if an enrollment was deleted from a sis import and the group_membership was also deleted as a result of the enrollment deletion, both items would be restored when the sis batch is restored.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restore_workflow_states_of_sis_imported_items(account_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str id: ID (required)
        :param bool batch_mode: If set, will only restore items that were deleted from batch_mode.
        :param bool undelete_only: If set, will only restore items that were deleted. This will ignore any items that were created or modified.
        :param bool unconclude_only: If set, will only restore enrollments that were concluded. This will ignore any items that were created or deleted.
        :return: Progress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.restore_workflow_states_of_sis_imported_items_with_http_info(account_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.restore_workflow_states_of_sis_imported_items_with_http_info(account_id, id, **kwargs)  # noqa: E501
            return data

    def restore_workflow_states_of_sis_imported_items_with_http_info(self, account_id, id, **kwargs):  # noqa: E501
        """Restore workflow_states of SIS imported items  # noqa: E501

        This will restore the the workflow_state for all the items that changed their workflow_state during the import being restored. This will restore states for items imported with the following importers: accounts.csv terms.csv courses.csv sections.csv group_categories.csv groups.csv users.csv admins.csv This also restores states for other items that changed during the import. An example would be if an enrollment was deleted from a sis import and the group_membership was also deleted as a result of the enrollment deletion, both items would be restored when the sis batch is restored.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restore_workflow_states_of_sis_imported_items_with_http_info(account_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str id: ID (required)
        :param bool batch_mode: If set, will only restore items that were deleted from batch_mode.
        :param bool undelete_only: If set, will only restore items that were deleted. This will ignore any items that were created or modified.
        :param bool unconclude_only: If set, will only restore enrollments that were concluded. This will ignore any items that were created or deleted.
        :return: Progress
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'id', 'batch_mode', 'undelete_only', 'unconclude_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restore_workflow_states_of_sis_imported_items" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `restore_workflow_states_of_sis_imported_items`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `restore_workflow_states_of_sis_imported_items`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'batch_mode' in params:
            form_params.append(('batch_mode', params['batch_mode']))  # noqa: E501
        if 'undelete_only' in params:
            form_params.append(('undelete_only', params['undelete_only']))  # noqa: E501
        if 'unconclude_only' in params:
            form_params.append(('unconclude_only', params['unconclude_only']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/sis_imports/{id}/restore_states', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Progress',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
