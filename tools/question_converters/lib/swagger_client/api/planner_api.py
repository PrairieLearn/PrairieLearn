# coding: utf-8

"""

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class PlannerApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_planner_note(self, **kwargs):  # noqa: E501
        """Create a planner note  # noqa: E501

        Create a planner note for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_planner_note(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str title: The title of the planner note.
        :param str details: Text of the planner note.
        :param Object todo_date: The date where this planner note should appear in the planner. The value should be formatted as: yyyy-mm-dd.
        :param int course_id: The ID of the course to associate with the planner note. The caller must be able to view the course in order to associate it with a planner note.
        :param str linked_object_type: The type of a learning object to link to this planner note. Must be used in conjunction wtih linked_object_id and course_id. Valid linked_object_type values are: 'announcement', 'assignment', 'discussion_topic', 'wiki_page', 'quiz'
        :param int linked_object_id: The id of a learning object to link to this planner note. Must be used in conjunction with linked_object_type and course_id. The object must be in the same course as specified by course_id. If the title argument is not provided, the planner note will use the learning object's title as its title. Only one planner note may be linked to a specific learning object.
        :return: PlannerNote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_planner_note_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_planner_note_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_planner_note_with_http_info(self, **kwargs):  # noqa: E501
        """Create a planner note  # noqa: E501

        Create a planner note for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_planner_note_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str title: The title of the planner note.
        :param str details: Text of the planner note.
        :param Object todo_date: The date where this planner note should appear in the planner. The value should be formatted as: yyyy-mm-dd.
        :param int course_id: The ID of the course to associate with the planner note. The caller must be able to view the course in order to associate it with a planner note.
        :param str linked_object_type: The type of a learning object to link to this planner note. Must be used in conjunction wtih linked_object_id and course_id. Valid linked_object_type values are: 'announcement', 'assignment', 'discussion_topic', 'wiki_page', 'quiz'
        :param int linked_object_id: The id of a learning object to link to this planner note. Must be used in conjunction with linked_object_type and course_id. The object must be in the same course as specified by course_id. If the title argument is not provided, the planner note will use the learning object's title as its title. Only one planner note may be linked to a specific learning object.
        :return: PlannerNote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['title', 'details', 'todo_date', 'course_id', 'linked_object_type', 'linked_object_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_planner_note" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'details' in params:
            form_params.append(('details', params['details']))  # noqa: E501
        if 'todo_date' in params:
            form_params.append(('todo_date', params['todo_date']))  # noqa: E501
        if 'course_id' in params:
            form_params.append(('course_id', params['course_id']))  # noqa: E501
        if 'linked_object_type' in params:
            form_params.append(('linked_object_type', params['linked_object_type']))  # noqa: E501
        if 'linked_object_id' in params:
            form_params.append(('linked_object_id', params['linked_object_id']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/planner_notes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PlannerNote',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_planner_override(self, plannable_type, plannable_id, **kwargs):  # noqa: E501
        """Create a planner override  # noqa: E501

        Create a planner override for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_planner_override(plannable_type, plannable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str plannable_type: Type of the item that you are overriding in the planner (required)
        :param int plannable_id: ID of the item that you are overriding in the planner (required)
        :param bool marked_complete: If this is true, the item will show in the planner as completed
        :param bool dismissed: If this is true, the item will not show in the opportunities list
        :return: PlannerOverride
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_planner_override_with_http_info(plannable_type, plannable_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_planner_override_with_http_info(plannable_type, plannable_id, **kwargs)  # noqa: E501
            return data

    def create_planner_override_with_http_info(self, plannable_type, plannable_id, **kwargs):  # noqa: E501
        """Create a planner override  # noqa: E501

        Create a planner override for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_planner_override_with_http_info(plannable_type, plannable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str plannable_type: Type of the item that you are overriding in the planner (required)
        :param int plannable_id: ID of the item that you are overriding in the planner (required)
        :param bool marked_complete: If this is true, the item will show in the planner as completed
        :param bool dismissed: If this is true, the item will not show in the opportunities list
        :return: PlannerOverride
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plannable_type', 'plannable_id', 'marked_complete', 'dismissed']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_planner_override" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plannable_type' is set
        if self.api_client.client_side_validation and ('plannable_type' not in params or
                                                       params['plannable_type'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `plannable_type` when calling `create_planner_override`")  # noqa: E501
        # verify the required parameter 'plannable_id' is set
        if self.api_client.client_side_validation and ('plannable_id' not in params or
                                                       params['plannable_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `plannable_id` when calling `create_planner_override`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'plannable_type' in params:
            form_params.append(('plannable_type', params['plannable_type']))  # noqa: E501
        if 'plannable_id' in params:
            form_params.append(('plannable_id', params['plannable_id']))  # noqa: E501
        if 'marked_complete' in params:
            form_params.append(('marked_complete', params['marked_complete']))  # noqa: E501
        if 'dismissed' in params:
            form_params.append(('dismissed', params['dismissed']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/planner/overrides', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PlannerOverride',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_planner_note(self, id, **kwargs):  # noqa: E501
        """Delete a planner note  # noqa: E501

        Delete a planner note for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_planner_note(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: PlannerNote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_planner_note_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_planner_note_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_planner_note_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a planner note  # noqa: E501

        Delete a planner note for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_planner_note_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: PlannerNote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_planner_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_planner_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/planner_notes/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PlannerNote',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_planner_override(self, id, **kwargs):  # noqa: E501
        """Delete a planner override  # noqa: E501

        Delete a planner override for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_planner_override(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: PlannerOverride
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_planner_override_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_planner_override_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_planner_override_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a planner override  # noqa: E501

        Delete a planner override for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_planner_override_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: PlannerOverride
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_planner_override" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_planner_override`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/planner/overrides/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PlannerOverride',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_planner_items_planner(self, **kwargs):  # noqa: E501
        """List planner items  # noqa: E501

        Retrieve the paginated list of objects to be shown on the planner for the current user with the associated planner override to override an item's visibility if set.  Planner items for a student may also be retrieved by a linked observer. Use the path that accepts a user_id and supply the student's id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_planner_items_planner(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Object start_date: Only return items starting from the given date. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
        :param Object end_date: Only return items up to the given date. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
        :param list[str] context_codes: List of context codes of courses and/or groups whose items you want to see. If not specified, defaults to all contexts associated to the current user. Note that concluded courses will be ignored unless specified in the includes[] parameter. The format of this field is the context type, followed by an underscore, followed by the context id. For example: course_42, group_123
        :param str observed_user_id: Return planner items for the given observed user. Must be accompanied by context_codes[]. The user making the request must be observing the observed user in all the courses specified by context_codes[].
        :param str filter: Only return items that have new or unread activity
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_planner_items_planner_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_planner_items_planner_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_planner_items_planner_with_http_info(self, **kwargs):  # noqa: E501
        """List planner items  # noqa: E501

        Retrieve the paginated list of objects to be shown on the planner for the current user with the associated planner override to override an item's visibility if set.  Planner items for a student may also be retrieved by a linked observer. Use the path that accepts a user_id and supply the student's id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_planner_items_planner_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Object start_date: Only return items starting from the given date. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
        :param Object end_date: Only return items up to the given date. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
        :param list[str] context_codes: List of context codes of courses and/or groups whose items you want to see. If not specified, defaults to all contexts associated to the current user. Note that concluded courses will be ignored unless specified in the includes[] parameter. The format of this field is the context type, followed by an underscore, followed by the context id. For example: course_42, group_123
        :param str observed_user_id: Return planner items for the given observed user. Must be accompanied by context_codes[]. The user making the request must be observing the observed user in all the courses specified by context_codes[].
        :param str filter: Only return items that have new or unread activity
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start_date', 'end_date', 'context_codes', 'observed_user_id', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_planner_items_planner" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'context_codes' in params:
            query_params.append(('context_codes', params['context_codes']))  # noqa: E501
            collection_formats['context_codes'] = 'csv'  # noqa: E501
        if 'observed_user_id' in params:
            query_params.append(('observed_user_id', params['observed_user_id']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/planner/items', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_planner_items_users(self, user_id, **kwargs):  # noqa: E501
        """List planner items  # noqa: E501

        Retrieve the paginated list of objects to be shown on the planner for the current user with the associated planner override to override an item's visibility if set.  Planner items for a student may also be retrieved by a linked observer. Use the path that accepts a user_id and supply the student's id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_planner_items_users(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param Object start_date: Only return items starting from the given date. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
        :param Object end_date: Only return items up to the given date. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
        :param list[str] context_codes: List of context codes of courses and/or groups whose items you want to see. If not specified, defaults to all contexts associated to the current user. Note that concluded courses will be ignored unless specified in the includes[] parameter. The format of this field is the context type, followed by an underscore, followed by the context id. For example: course_42, group_123
        :param str observed_user_id: Return planner items for the given observed user. Must be accompanied by context_codes[]. The user making the request must be observing the observed user in all the courses specified by context_codes[].
        :param str filter: Only return items that have new or unread activity
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_planner_items_users_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_planner_items_users_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def list_planner_items_users_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List planner items  # noqa: E501

        Retrieve the paginated list of objects to be shown on the planner for the current user with the associated planner override to override an item's visibility if set.  Planner items for a student may also be retrieved by a linked observer. Use the path that accepts a user_id and supply the student's id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_planner_items_users_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param Object start_date: Only return items starting from the given date. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
        :param Object end_date: Only return items up to the given date. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
        :param list[str] context_codes: List of context codes of courses and/or groups whose items you want to see. If not specified, defaults to all contexts associated to the current user. Note that concluded courses will be ignored unless specified in the includes[] parameter. The format of this field is the context type, followed by an underscore, followed by the context id. For example: course_42, group_123
        :param str observed_user_id: Return planner items for the given observed user. Must be accompanied by context_codes[]. The user making the request must be observing the observed user in all the courses specified by context_codes[].
        :param str filter: Only return items that have new or unread activity
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'start_date', 'end_date', 'context_codes', 'observed_user_id', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_planner_items_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `list_planner_items_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'context_codes' in params:
            query_params.append(('context_codes', params['context_codes']))  # noqa: E501
            collection_formats['context_codes'] = 'csv'  # noqa: E501
        if 'observed_user_id' in params:
            query_params.append(('observed_user_id', params['observed_user_id']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/planner/items', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_planner_notes(self, **kwargs):  # noqa: E501
        """List planner notes  # noqa: E501

        Retrieve the paginated list of planner notes  Retrieve planner note for a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_planner_notes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Object start_date: Only return notes with todo dates since the start_date (inclusive). No default. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
        :param Object end_date: Only return notes with todo dates before the end_date (inclusive). No default. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ. If end_date and start_date are both specified and equivalent, then only notes with todo dates on that day are returned.
        :param list[str] context_codes: List of context codes of courses whose notes you want to see. If not specified, defaults to all contexts that the user belongs to. The format of this field is the context type, followed by an underscore, followed by the context id. For example: course_42 Including a code matching the user's own context code (e.g. user_1) will include notes that are not associated with any particular course.
        :return: list[PlannerNote]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_planner_notes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_planner_notes_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_planner_notes_with_http_info(self, **kwargs):  # noqa: E501
        """List planner notes  # noqa: E501

        Retrieve the paginated list of planner notes  Retrieve planner note for a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_planner_notes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Object start_date: Only return notes with todo dates since the start_date (inclusive). No default. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
        :param Object end_date: Only return notes with todo dates before the end_date (inclusive). No default. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ. If end_date and start_date are both specified and equivalent, then only notes with todo dates on that day are returned.
        :param list[str] context_codes: List of context codes of courses whose notes you want to see. If not specified, defaults to all contexts that the user belongs to. The format of this field is the context type, followed by an underscore, followed by the context id. For example: course_42 Including a code matching the user's own context code (e.g. user_1) will include notes that are not associated with any particular course.
        :return: list[PlannerNote]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start_date', 'end_date', 'context_codes']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_planner_notes" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'context_codes' in params:
            query_params.append(('context_codes', params['context_codes']))  # noqa: E501
            collection_formats['context_codes'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/planner_notes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PlannerNote]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_planner_overrides(self, **kwargs):  # noqa: E501
        """List planner overrides  # noqa: E501

        Retrieve a planner override for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_planner_overrides(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PlannerOverride]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_planner_overrides_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_planner_overrides_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_planner_overrides_with_http_info(self, **kwargs):  # noqa: E501
        """List planner overrides  # noqa: E501

        Retrieve a planner override for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_planner_overrides_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PlannerOverride]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_planner_overrides" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/planner/overrides', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PlannerOverride]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_planner_note(self, id, **kwargs):  # noqa: E501
        """Show a planner note  # noqa: E501

        Retrieve a planner note for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_planner_note(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: PlannerNote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_planner_note_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.show_planner_note_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def show_planner_note_with_http_info(self, id, **kwargs):  # noqa: E501
        """Show a planner note  # noqa: E501

        Retrieve a planner note for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_planner_note_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: PlannerNote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_planner_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `show_planner_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/planner_notes/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PlannerNote',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_planner_override(self, id, **kwargs):  # noqa: E501
        """Show a planner override  # noqa: E501

        Retrieve a planner override for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_planner_override(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: PlannerOverride
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_planner_override_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.show_planner_override_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def show_planner_override_with_http_info(self, id, **kwargs):  # noqa: E501
        """Show a planner override  # noqa: E501

        Retrieve a planner override for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_planner_override_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: PlannerOverride
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_planner_override" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `show_planner_override`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/planner/overrides/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PlannerOverride',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_planner_note(self, id, **kwargs):  # noqa: E501
        """Update a planner note  # noqa: E501

        Update a planner note for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_planner_note(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str title: The title of the planner note.
        :param str details: Text of the planner note.
        :param Object todo_date: The date where this planner note should appear in the planner. The value should be formatted as: yyyy-mm-dd.
        :param int course_id: The ID of the course to associate with the planner note. The caller must be able to view the course in order to associate it with a planner note. Use a null or empty value to remove a planner note from a course. Note that if the planner note is linked to a learning object, its course_id cannot be changed.
        :return: PlannerNote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_planner_note_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_planner_note_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_planner_note_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update a planner note  # noqa: E501

        Update a planner note for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_planner_note_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str title: The title of the planner note.
        :param str details: Text of the planner note.
        :param Object todo_date: The date where this planner note should appear in the planner. The value should be formatted as: yyyy-mm-dd.
        :param int course_id: The ID of the course to associate with the planner note. The caller must be able to view the course in order to associate it with a planner note. Use a null or empty value to remove a planner note from a course. Note that if the planner note is linked to a learning object, its course_id cannot be changed.
        :return: PlannerNote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'title', 'details', 'todo_date', 'course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_planner_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_planner_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'details' in params:
            form_params.append(('details', params['details']))  # noqa: E501
        if 'todo_date' in params:
            form_params.append(('todo_date', params['todo_date']))  # noqa: E501
        if 'course_id' in params:
            form_params.append(('course_id', params['course_id']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/planner_notes/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PlannerNote',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_planner_override(self, id, **kwargs):  # noqa: E501
        """Update a planner override  # noqa: E501

        Update a planner override's visibilty for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_planner_override(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str marked_complete: determines whether the planner item is marked as completed
        :param str dismissed: determines whether the planner item shows in the opportunities list
        :return: PlannerOverride
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_planner_override_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_planner_override_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_planner_override_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update a planner override  # noqa: E501

        Update a planner override's visibilty for the current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_planner_override_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str marked_complete: determines whether the planner item is marked as completed
        :param str dismissed: determines whether the planner item shows in the opportunities list
        :return: PlannerOverride
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'marked_complete', 'dismissed']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_planner_override" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_planner_override`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'marked_complete' in params:
            form_params.append(('marked_complete', params['marked_complete']))  # noqa: E501
        if 'dismissed' in params:
            form_params.append(('dismissed', params['dismissed']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/planner/overrides/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PlannerOverride',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
