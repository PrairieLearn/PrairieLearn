# coding: utf-8

"""

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class PagesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_page_courses(self, course_id, wiki_page_title, **kwargs):  # noqa: E501
        """Create page  # noqa: E501

        Create a new wiki page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_page_courses(course_id, wiki_page_title, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str wiki_page_title: The title for the new page. (required)
        :param str wiki_page_body: The content for the new page.
        :param str wiki_page_editing_roles: Which user roles are allowed to edit this page. Any combination of these roles is allowed (separated by commas).  \"teachers\":: Allows editing by teachers in the course. \"students\":: Allows editing by students in the course. \"members\":: For group wikis, allows editing by members of the group. \"public\":: Allows editing by any user.
        :param bool wiki_page_notify_of_update: Whether participants should be notified when this page changes.
        :param bool wiki_page_published: Whether the page is published (true) or draft state (false).
        :param bool wiki_page_front_page: Set an unhidden page as the front page (if true)
        :param Object wiki_page_publish_at: Schedule a future date/time to publish the page. This will have no effect unless the \"Scheduled Page Publication\" feature is enabled in the account. If a future date is supplied, the page will be unpublished and wiki_page[published] will be ignored.
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_page_courses_with_http_info(course_id, wiki_page_title, **kwargs)  # noqa: E501
        else:
            (data) = self.create_page_courses_with_http_info(course_id, wiki_page_title, **kwargs)  # noqa: E501
            return data

    def create_page_courses_with_http_info(self, course_id, wiki_page_title, **kwargs):  # noqa: E501
        """Create page  # noqa: E501

        Create a new wiki page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_page_courses_with_http_info(course_id, wiki_page_title, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str wiki_page_title: The title for the new page. (required)
        :param str wiki_page_body: The content for the new page.
        :param str wiki_page_editing_roles: Which user roles are allowed to edit this page. Any combination of these roles is allowed (separated by commas).  \"teachers\":: Allows editing by teachers in the course. \"students\":: Allows editing by students in the course. \"members\":: For group wikis, allows editing by members of the group. \"public\":: Allows editing by any user.
        :param bool wiki_page_notify_of_update: Whether participants should be notified when this page changes.
        :param bool wiki_page_published: Whether the page is published (true) or draft state (false).
        :param bool wiki_page_front_page: Set an unhidden page as the front page (if true)
        :param Object wiki_page_publish_at: Schedule a future date/time to publish the page. This will have no effect unless the \"Scheduled Page Publication\" feature is enabled in the account. If a future date is supplied, the page will be unpublished and wiki_page[published] will be ignored.
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'wiki_page_title', 'wiki_page_body', 'wiki_page_editing_roles', 'wiki_page_notify_of_update', 'wiki_page_published', 'wiki_page_front_page', 'wiki_page_publish_at']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_page_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `create_page_courses`")  # noqa: E501
        # verify the required parameter 'wiki_page_title' is set
        if self.api_client.client_side_validation and ('wiki_page_title' not in params or
                                                       params['wiki_page_title'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `wiki_page_title` when calling `create_page_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'wiki_page_title' in params:
            form_params.append(('wiki_page[title]', params['wiki_page_title']))  # noqa: E501
        if 'wiki_page_body' in params:
            form_params.append(('wiki_page[body]', params['wiki_page_body']))  # noqa: E501
        if 'wiki_page_editing_roles' in params:
            form_params.append(('wiki_page[editing_roles]', params['wiki_page_editing_roles']))  # noqa: E501
        if 'wiki_page_notify_of_update' in params:
            form_params.append(('wiki_page[notify_of_update]', params['wiki_page_notify_of_update']))  # noqa: E501
        if 'wiki_page_published' in params:
            form_params.append(('wiki_page[published]', params['wiki_page_published']))  # noqa: E501
        if 'wiki_page_front_page' in params:
            form_params.append(('wiki_page[front_page]', params['wiki_page_front_page']))  # noqa: E501
        if 'wiki_page_publish_at' in params:
            form_params.append(('wiki_page[publish_at]', params['wiki_page_publish_at']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/pages', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Page',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_page_groups(self, group_id, wiki_page_title, **kwargs):  # noqa: E501
        """Create page  # noqa: E501

        Create a new wiki page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_page_groups(group_id, wiki_page_title, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str wiki_page_title: The title for the new page. (required)
        :param str wiki_page_body: The content for the new page.
        :param str wiki_page_editing_roles: Which user roles are allowed to edit this page. Any combination of these roles is allowed (separated by commas).  \"teachers\":: Allows editing by teachers in the course. \"students\":: Allows editing by students in the course. \"members\":: For group wikis, allows editing by members of the group. \"public\":: Allows editing by any user.
        :param bool wiki_page_notify_of_update: Whether participants should be notified when this page changes.
        :param bool wiki_page_published: Whether the page is published (true) or draft state (false).
        :param bool wiki_page_front_page: Set an unhidden page as the front page (if true)
        :param Object wiki_page_publish_at: Schedule a future date/time to publish the page. This will have no effect unless the \"Scheduled Page Publication\" feature is enabled in the account. If a future date is supplied, the page will be unpublished and wiki_page[published] will be ignored.
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_page_groups_with_http_info(group_id, wiki_page_title, **kwargs)  # noqa: E501
        else:
            (data) = self.create_page_groups_with_http_info(group_id, wiki_page_title, **kwargs)  # noqa: E501
            return data

    def create_page_groups_with_http_info(self, group_id, wiki_page_title, **kwargs):  # noqa: E501
        """Create page  # noqa: E501

        Create a new wiki page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_page_groups_with_http_info(group_id, wiki_page_title, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str wiki_page_title: The title for the new page. (required)
        :param str wiki_page_body: The content for the new page.
        :param str wiki_page_editing_roles: Which user roles are allowed to edit this page. Any combination of these roles is allowed (separated by commas).  \"teachers\":: Allows editing by teachers in the course. \"students\":: Allows editing by students in the course. \"members\":: For group wikis, allows editing by members of the group. \"public\":: Allows editing by any user.
        :param bool wiki_page_notify_of_update: Whether participants should be notified when this page changes.
        :param bool wiki_page_published: Whether the page is published (true) or draft state (false).
        :param bool wiki_page_front_page: Set an unhidden page as the front page (if true)
        :param Object wiki_page_publish_at: Schedule a future date/time to publish the page. This will have no effect unless the \"Scheduled Page Publication\" feature is enabled in the account. If a future date is supplied, the page will be unpublished and wiki_page[published] will be ignored.
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'wiki_page_title', 'wiki_page_body', 'wiki_page_editing_roles', 'wiki_page_notify_of_update', 'wiki_page_published', 'wiki_page_front_page', 'wiki_page_publish_at']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_page_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `create_page_groups`")  # noqa: E501
        # verify the required parameter 'wiki_page_title' is set
        if self.api_client.client_side_validation and ('wiki_page_title' not in params or
                                                       params['wiki_page_title'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `wiki_page_title` when calling `create_page_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'wiki_page_title' in params:
            form_params.append(('wiki_page[title]', params['wiki_page_title']))  # noqa: E501
        if 'wiki_page_body' in params:
            form_params.append(('wiki_page[body]', params['wiki_page_body']))  # noqa: E501
        if 'wiki_page_editing_roles' in params:
            form_params.append(('wiki_page[editing_roles]', params['wiki_page_editing_roles']))  # noqa: E501
        if 'wiki_page_notify_of_update' in params:
            form_params.append(('wiki_page[notify_of_update]', params['wiki_page_notify_of_update']))  # noqa: E501
        if 'wiki_page_published' in params:
            form_params.append(('wiki_page[published]', params['wiki_page_published']))  # noqa: E501
        if 'wiki_page_front_page' in params:
            form_params.append(('wiki_page[front_page]', params['wiki_page_front_page']))  # noqa: E501
        if 'wiki_page_publish_at' in params:
            form_params.append(('wiki_page[publish_at]', params['wiki_page_publish_at']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/pages', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Page',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_page_courses(self, course_id, url_or_id, **kwargs):  # noqa: E501
        """Delete page  # noqa: E501

        Delete a wiki page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_page_courses(course_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str url_or_id: ID (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_page_courses_with_http_info(course_id, url_or_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_page_courses_with_http_info(course_id, url_or_id, **kwargs)  # noqa: E501
            return data

    def delete_page_courses_with_http_info(self, course_id, url_or_id, **kwargs):  # noqa: E501
        """Delete page  # noqa: E501

        Delete a wiki page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_page_courses_with_http_info(course_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str url_or_id: ID (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'url_or_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_page_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `delete_page_courses`")  # noqa: E501
        # verify the required parameter 'url_or_id' is set
        if self.api_client.client_side_validation and ('url_or_id' not in params or
                                                       params['url_or_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `url_or_id` when calling `delete_page_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'url_or_id' in params:
            path_params['url_or_id'] = params['url_or_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/pages/{url_or_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Page',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_page_groups(self, group_id, url_or_id, **kwargs):  # noqa: E501
        """Delete page  # noqa: E501

        Delete a wiki page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_page_groups(group_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str url_or_id: ID (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_page_groups_with_http_info(group_id, url_or_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_page_groups_with_http_info(group_id, url_or_id, **kwargs)  # noqa: E501
            return data

    def delete_page_groups_with_http_info(self, group_id, url_or_id, **kwargs):  # noqa: E501
        """Delete page  # noqa: E501

        Delete a wiki page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_page_groups_with_http_info(group_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str url_or_id: ID (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'url_or_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_page_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `delete_page_groups`")  # noqa: E501
        # verify the required parameter 'url_or_id' is set
        if self.api_client.client_side_validation and ('url_or_id' not in params or
                                                       params['url_or_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `url_or_id` when calling `delete_page_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'url_or_id' in params:
            path_params['url_or_id'] = params['url_or_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/pages/{url_or_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Page',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def duplicate_page(self, course_id, url_or_id, **kwargs):  # noqa: E501
        """Duplicate page  # noqa: E501

        Duplicate a wiki page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.duplicate_page(course_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str url_or_id: ID (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.duplicate_page_with_http_info(course_id, url_or_id, **kwargs)  # noqa: E501
        else:
            (data) = self.duplicate_page_with_http_info(course_id, url_or_id, **kwargs)  # noqa: E501
            return data

    def duplicate_page_with_http_info(self, course_id, url_or_id, **kwargs):  # noqa: E501
        """Duplicate page  # noqa: E501

        Duplicate a wiki page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.duplicate_page_with_http_info(course_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str url_or_id: ID (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'url_or_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method duplicate_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `duplicate_page`")  # noqa: E501
        # verify the required parameter 'url_or_id' is set
        if self.api_client.client_side_validation and ('url_or_id' not in params or
                                                       params['url_or_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `url_or_id` when calling `duplicate_page`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'url_or_id' in params:
            path_params['url_or_id'] = params['url_or_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/pages/{url_or_id}/duplicate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Page',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_pages_courses(self, course_id, **kwargs):  # noqa: E501
        """List pages  # noqa: E501

        A paginated list of the wiki pages associated with a course or group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_pages_courses(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str sort: Sort results by this field.
        :param str order: The sorting order. Defaults to 'asc'.
        :param str search_term: The partial title of the pages to match and return.
        :param bool published: If true, include only published paqes. If false, exclude published pages. If not present, do not filter on published status.
        :param list[str] include: - \"enrollments\": Optionally include the page body with each Page.
        :return: list[Page]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_pages_courses_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_pages_courses_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def list_pages_courses_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """List pages  # noqa: E501

        A paginated list of the wiki pages associated with a course or group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_pages_courses_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str sort: Sort results by this field.
        :param str order: The sorting order. Defaults to 'asc'.
        :param str search_term: The partial title of the pages to match and return.
        :param bool published: If true, include only published paqes. If false, exclude published pages. If not present, do not filter on published status.
        :param list[str] include: - \"enrollments\": Optionally include the page body with each Page.
        :return: list[Page]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'sort', 'order', 'search_term', 'published', 'include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_pages_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `list_pages_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'order' in params:
            query_params.append(('order', params['order']))  # noqa: E501
        if 'search_term' in params:
            query_params.append(('search_term', params['search_term']))  # noqa: E501
        if 'published' in params:
            query_params.append(('published', params['published']))  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/pages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Page]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_pages_groups(self, group_id, **kwargs):  # noqa: E501
        """List pages  # noqa: E501

        A paginated list of the wiki pages associated with a course or group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_pages_groups(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str sort: Sort results by this field.
        :param str order: The sorting order. Defaults to 'asc'.
        :param str search_term: The partial title of the pages to match and return.
        :param bool published: If true, include only published paqes. If false, exclude published pages. If not present, do not filter on published status.
        :param list[str] include: - \"enrollments\": Optionally include the page body with each Page.
        :return: list[Page]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_pages_groups_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_pages_groups_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def list_pages_groups_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """List pages  # noqa: E501

        A paginated list of the wiki pages associated with a course or group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_pages_groups_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str sort: Sort results by this field.
        :param str order: The sorting order. Defaults to 'asc'.
        :param str search_term: The partial title of the pages to match and return.
        :param bool published: If true, include only published paqes. If false, exclude published pages. If not present, do not filter on published status.
        :param list[str] include: - \"enrollments\": Optionally include the page body with each Page.
        :return: list[Page]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'sort', 'order', 'search_term', 'published', 'include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_pages_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `list_pages_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'order' in params:
            query_params.append(('order', params['order']))  # noqa: E501
        if 'search_term' in params:
            query_params.append(('search_term', params['search_term']))  # noqa: E501
        if 'published' in params:
            query_params.append(('published', params['published']))  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/pages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Page]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_revisions_courses(self, course_id, url_or_id, **kwargs):  # noqa: E501
        """List revisions  # noqa: E501

        A paginated list of the revisions of a page. Callers must have update rights on the page in order to see page history.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_revisions_courses(course_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str url_or_id: ID (required)
        :return: list[PageRevision]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_revisions_courses_with_http_info(course_id, url_or_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_revisions_courses_with_http_info(course_id, url_or_id, **kwargs)  # noqa: E501
            return data

    def list_revisions_courses_with_http_info(self, course_id, url_or_id, **kwargs):  # noqa: E501
        """List revisions  # noqa: E501

        A paginated list of the revisions of a page. Callers must have update rights on the page in order to see page history.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_revisions_courses_with_http_info(course_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str url_or_id: ID (required)
        :return: list[PageRevision]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'url_or_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_revisions_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `list_revisions_courses`")  # noqa: E501
        # verify the required parameter 'url_or_id' is set
        if self.api_client.client_side_validation and ('url_or_id' not in params or
                                                       params['url_or_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `url_or_id` when calling `list_revisions_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'url_or_id' in params:
            path_params['url_or_id'] = params['url_or_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/pages/{url_or_id}/revisions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PageRevision]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_revisions_groups(self, group_id, url_or_id, **kwargs):  # noqa: E501
        """List revisions  # noqa: E501

        A paginated list of the revisions of a page. Callers must have update rights on the page in order to see page history.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_revisions_groups(group_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str url_or_id: ID (required)
        :return: list[PageRevision]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_revisions_groups_with_http_info(group_id, url_or_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_revisions_groups_with_http_info(group_id, url_or_id, **kwargs)  # noqa: E501
            return data

    def list_revisions_groups_with_http_info(self, group_id, url_or_id, **kwargs):  # noqa: E501
        """List revisions  # noqa: E501

        A paginated list of the revisions of a page. Callers must have update rights on the page in order to see page history.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_revisions_groups_with_http_info(group_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str url_or_id: ID (required)
        :return: list[PageRevision]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'url_or_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_revisions_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `list_revisions_groups`")  # noqa: E501
        # verify the required parameter 'url_or_id' is set
        if self.api_client.client_side_validation and ('url_or_id' not in params or
                                                       params['url_or_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `url_or_id` when calling `list_revisions_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'url_or_id' in params:
            path_params['url_or_id'] = params['url_or_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/pages/{url_or_id}/revisions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PageRevision]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revert_to_revision_courses(self, course_id, url_or_id, revision_id, **kwargs):  # noqa: E501
        """Revert to revision  # noqa: E501

        Revert a page to a prior revision.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revert_to_revision_courses(course_id, url_or_id, revision_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str url_or_id: ID (required)
        :param int revision_id: The revision to revert to (use the {api:WikiPagesApiController#revisions List Revisions API} to see available revisions) (required)
        :return: PageRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.revert_to_revision_courses_with_http_info(course_id, url_or_id, revision_id, **kwargs)  # noqa: E501
        else:
            (data) = self.revert_to_revision_courses_with_http_info(course_id, url_or_id, revision_id, **kwargs)  # noqa: E501
            return data

    def revert_to_revision_courses_with_http_info(self, course_id, url_or_id, revision_id, **kwargs):  # noqa: E501
        """Revert to revision  # noqa: E501

        Revert a page to a prior revision.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revert_to_revision_courses_with_http_info(course_id, url_or_id, revision_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str url_or_id: ID (required)
        :param int revision_id: The revision to revert to (use the {api:WikiPagesApiController#revisions List Revisions API} to see available revisions) (required)
        :return: PageRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'url_or_id', 'revision_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revert_to_revision_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `revert_to_revision_courses`")  # noqa: E501
        # verify the required parameter 'url_or_id' is set
        if self.api_client.client_side_validation and ('url_or_id' not in params or
                                                       params['url_or_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `url_or_id` when calling `revert_to_revision_courses`")  # noqa: E501
        # verify the required parameter 'revision_id' is set
        if self.api_client.client_side_validation and ('revision_id' not in params or
                                                       params['revision_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `revision_id` when calling `revert_to_revision_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'url_or_id' in params:
            path_params['url_or_id'] = params['url_or_id']  # noqa: E501
        if 'revision_id' in params:
            path_params['revision_id'] = params['revision_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/pages/{url_or_id}/revisions/{revision_id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PageRevision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revert_to_revision_groups(self, group_id, url_or_id, revision_id, **kwargs):  # noqa: E501
        """Revert to revision  # noqa: E501

        Revert a page to a prior revision.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revert_to_revision_groups(group_id, url_or_id, revision_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str url_or_id: ID (required)
        :param int revision_id: The revision to revert to (use the {api:WikiPagesApiController#revisions List Revisions API} to see available revisions) (required)
        :return: PageRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.revert_to_revision_groups_with_http_info(group_id, url_or_id, revision_id, **kwargs)  # noqa: E501
        else:
            (data) = self.revert_to_revision_groups_with_http_info(group_id, url_or_id, revision_id, **kwargs)  # noqa: E501
            return data

    def revert_to_revision_groups_with_http_info(self, group_id, url_or_id, revision_id, **kwargs):  # noqa: E501
        """Revert to revision  # noqa: E501

        Revert a page to a prior revision.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revert_to_revision_groups_with_http_info(group_id, url_or_id, revision_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str url_or_id: ID (required)
        :param int revision_id: The revision to revert to (use the {api:WikiPagesApiController#revisions List Revisions API} to see available revisions) (required)
        :return: PageRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'url_or_id', 'revision_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revert_to_revision_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `revert_to_revision_groups`")  # noqa: E501
        # verify the required parameter 'url_or_id' is set
        if self.api_client.client_side_validation and ('url_or_id' not in params or
                                                       params['url_or_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `url_or_id` when calling `revert_to_revision_groups`")  # noqa: E501
        # verify the required parameter 'revision_id' is set
        if self.api_client.client_side_validation and ('revision_id' not in params or
                                                       params['revision_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `revision_id` when calling `revert_to_revision_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'url_or_id' in params:
            path_params['url_or_id'] = params['url_or_id']  # noqa: E501
        if 'revision_id' in params:
            path_params['revision_id'] = params['revision_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/pages/{url_or_id}/revisions/{revision_id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PageRevision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_front_page_courses(self, course_id, **kwargs):  # noqa: E501
        """Show front page  # noqa: E501

        Retrieve the content of the front page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_front_page_courses(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_front_page_courses_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.show_front_page_courses_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def show_front_page_courses_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Show front page  # noqa: E501

        Retrieve the content of the front page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_front_page_courses_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_front_page_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `show_front_page_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/front_page', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Page',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_front_page_groups(self, group_id, **kwargs):  # noqa: E501
        """Show front page  # noqa: E501

        Retrieve the content of the front page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_front_page_groups(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_front_page_groups_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.show_front_page_groups_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def show_front_page_groups_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """Show front page  # noqa: E501

        Retrieve the content of the front page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_front_page_groups_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_front_page_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `show_front_page_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/front_page', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Page',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_page_courses(self, course_id, url_or_id, **kwargs):  # noqa: E501
        """Show page  # noqa: E501

        Retrieve the content of a wiki page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_page_courses(course_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str url_or_id: ID (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_page_courses_with_http_info(course_id, url_or_id, **kwargs)  # noqa: E501
        else:
            (data) = self.show_page_courses_with_http_info(course_id, url_or_id, **kwargs)  # noqa: E501
            return data

    def show_page_courses_with_http_info(self, course_id, url_or_id, **kwargs):  # noqa: E501
        """Show page  # noqa: E501

        Retrieve the content of a wiki page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_page_courses_with_http_info(course_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str url_or_id: ID (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'url_or_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_page_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `show_page_courses`")  # noqa: E501
        # verify the required parameter 'url_or_id' is set
        if self.api_client.client_side_validation and ('url_or_id' not in params or
                                                       params['url_or_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `url_or_id` when calling `show_page_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'url_or_id' in params:
            path_params['url_or_id'] = params['url_or_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/pages/{url_or_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Page',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_page_groups(self, group_id, url_or_id, **kwargs):  # noqa: E501
        """Show page  # noqa: E501

        Retrieve the content of a wiki page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_page_groups(group_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str url_or_id: ID (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_page_groups_with_http_info(group_id, url_or_id, **kwargs)  # noqa: E501
        else:
            (data) = self.show_page_groups_with_http_info(group_id, url_or_id, **kwargs)  # noqa: E501
            return data

    def show_page_groups_with_http_info(self, group_id, url_or_id, **kwargs):  # noqa: E501
        """Show page  # noqa: E501

        Retrieve the content of a wiki page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_page_groups_with_http_info(group_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str url_or_id: ID (required)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'url_or_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_page_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `show_page_groups`")  # noqa: E501
        # verify the required parameter 'url_or_id' is set
        if self.api_client.client_side_validation and ('url_or_id' not in params or
                                                       params['url_or_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `url_or_id` when calling `show_page_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'url_or_id' in params:
            path_params['url_or_id'] = params['url_or_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/pages/{url_or_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Page',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_revision_courses_latest(self, course_id, url_or_id, **kwargs):  # noqa: E501
        """Show revision  # noqa: E501

        Retrieve the metadata and optionally content of a revision of the page. Note that retrieving historic versions of pages requires edit rights.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_revision_courses_latest(course_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str url_or_id: ID (required)
        :param bool summary: If set, exclude page content from results
        :return: PageRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_revision_courses_latest_with_http_info(course_id, url_or_id, **kwargs)  # noqa: E501
        else:
            (data) = self.show_revision_courses_latest_with_http_info(course_id, url_or_id, **kwargs)  # noqa: E501
            return data

    def show_revision_courses_latest_with_http_info(self, course_id, url_or_id, **kwargs):  # noqa: E501
        """Show revision  # noqa: E501

        Retrieve the metadata and optionally content of a revision of the page. Note that retrieving historic versions of pages requires edit rights.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_revision_courses_latest_with_http_info(course_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str url_or_id: ID (required)
        :param bool summary: If set, exclude page content from results
        :return: PageRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'url_or_id', 'summary']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_revision_courses_latest" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `show_revision_courses_latest`")  # noqa: E501
        # verify the required parameter 'url_or_id' is set
        if self.api_client.client_side_validation and ('url_or_id' not in params or
                                                       params['url_or_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `url_or_id` when calling `show_revision_courses_latest`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'url_or_id' in params:
            path_params['url_or_id'] = params['url_or_id']  # noqa: E501

        query_params = []
        if 'summary' in params:
            query_params.append(('summary', params['summary']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/pages/{url_or_id}/revisions/latest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PageRevision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_revision_courses_revision_id(self, course_id, url_or_id, revision_id, **kwargs):  # noqa: E501
        """Show revision  # noqa: E501

        Retrieve the metadata and optionally content of a revision of the page. Note that retrieving historic versions of pages requires edit rights.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_revision_courses_revision_id(course_id, url_or_id, revision_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str url_or_id: ID (required)
        :param str revision_id: ID (required)
        :param bool summary: If set, exclude page content from results
        :return: PageRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_revision_courses_revision_id_with_http_info(course_id, url_or_id, revision_id, **kwargs)  # noqa: E501
        else:
            (data) = self.show_revision_courses_revision_id_with_http_info(course_id, url_or_id, revision_id, **kwargs)  # noqa: E501
            return data

    def show_revision_courses_revision_id_with_http_info(self, course_id, url_or_id, revision_id, **kwargs):  # noqa: E501
        """Show revision  # noqa: E501

        Retrieve the metadata and optionally content of a revision of the page. Note that retrieving historic versions of pages requires edit rights.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_revision_courses_revision_id_with_http_info(course_id, url_or_id, revision_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str url_or_id: ID (required)
        :param str revision_id: ID (required)
        :param bool summary: If set, exclude page content from results
        :return: PageRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'url_or_id', 'revision_id', 'summary']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_revision_courses_revision_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `show_revision_courses_revision_id`")  # noqa: E501
        # verify the required parameter 'url_or_id' is set
        if self.api_client.client_side_validation and ('url_or_id' not in params or
                                                       params['url_or_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `url_or_id` when calling `show_revision_courses_revision_id`")  # noqa: E501
        # verify the required parameter 'revision_id' is set
        if self.api_client.client_side_validation and ('revision_id' not in params or
                                                       params['revision_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `revision_id` when calling `show_revision_courses_revision_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'url_or_id' in params:
            path_params['url_or_id'] = params['url_or_id']  # noqa: E501
        if 'revision_id' in params:
            path_params['revision_id'] = params['revision_id']  # noqa: E501

        query_params = []
        if 'summary' in params:
            query_params.append(('summary', params['summary']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/pages/{url_or_id}/revisions/{revision_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PageRevision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_revision_groups_latest(self, group_id, url_or_id, **kwargs):  # noqa: E501
        """Show revision  # noqa: E501

        Retrieve the metadata and optionally content of a revision of the page. Note that retrieving historic versions of pages requires edit rights.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_revision_groups_latest(group_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str url_or_id: ID (required)
        :param bool summary: If set, exclude page content from results
        :return: PageRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_revision_groups_latest_with_http_info(group_id, url_or_id, **kwargs)  # noqa: E501
        else:
            (data) = self.show_revision_groups_latest_with_http_info(group_id, url_or_id, **kwargs)  # noqa: E501
            return data

    def show_revision_groups_latest_with_http_info(self, group_id, url_or_id, **kwargs):  # noqa: E501
        """Show revision  # noqa: E501

        Retrieve the metadata and optionally content of a revision of the page. Note that retrieving historic versions of pages requires edit rights.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_revision_groups_latest_with_http_info(group_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str url_or_id: ID (required)
        :param bool summary: If set, exclude page content from results
        :return: PageRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'url_or_id', 'summary']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_revision_groups_latest" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `show_revision_groups_latest`")  # noqa: E501
        # verify the required parameter 'url_or_id' is set
        if self.api_client.client_side_validation and ('url_or_id' not in params or
                                                       params['url_or_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `url_or_id` when calling `show_revision_groups_latest`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'url_or_id' in params:
            path_params['url_or_id'] = params['url_or_id']  # noqa: E501

        query_params = []
        if 'summary' in params:
            query_params.append(('summary', params['summary']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/pages/{url_or_id}/revisions/latest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PageRevision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_revision_groups_revision_id(self, group_id, url_or_id, revision_id, **kwargs):  # noqa: E501
        """Show revision  # noqa: E501

        Retrieve the metadata and optionally content of a revision of the page. Note that retrieving historic versions of pages requires edit rights.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_revision_groups_revision_id(group_id, url_or_id, revision_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str url_or_id: ID (required)
        :param str revision_id: ID (required)
        :param bool summary: If set, exclude page content from results
        :return: PageRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_revision_groups_revision_id_with_http_info(group_id, url_or_id, revision_id, **kwargs)  # noqa: E501
        else:
            (data) = self.show_revision_groups_revision_id_with_http_info(group_id, url_or_id, revision_id, **kwargs)  # noqa: E501
            return data

    def show_revision_groups_revision_id_with_http_info(self, group_id, url_or_id, revision_id, **kwargs):  # noqa: E501
        """Show revision  # noqa: E501

        Retrieve the metadata and optionally content of a revision of the page. Note that retrieving historic versions of pages requires edit rights.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_revision_groups_revision_id_with_http_info(group_id, url_or_id, revision_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str url_or_id: ID (required)
        :param str revision_id: ID (required)
        :param bool summary: If set, exclude page content from results
        :return: PageRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'url_or_id', 'revision_id', 'summary']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_revision_groups_revision_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `show_revision_groups_revision_id`")  # noqa: E501
        # verify the required parameter 'url_or_id' is set
        if self.api_client.client_side_validation and ('url_or_id' not in params or
                                                       params['url_or_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `url_or_id` when calling `show_revision_groups_revision_id`")  # noqa: E501
        # verify the required parameter 'revision_id' is set
        if self.api_client.client_side_validation and ('revision_id' not in params or
                                                       params['revision_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `revision_id` when calling `show_revision_groups_revision_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'url_or_id' in params:
            path_params['url_or_id'] = params['url_or_id']  # noqa: E501
        if 'revision_id' in params:
            path_params['revision_id'] = params['revision_id']  # noqa: E501

        query_params = []
        if 'summary' in params:
            query_params.append(('summary', params['summary']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/pages/{url_or_id}/revisions/{revision_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PageRevision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_create_front_page_courses(self, course_id, **kwargs):  # noqa: E501
        """Update/create front page  # noqa: E501

        Update the title or contents of the front page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_create_front_page_courses(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str wiki_page_title: The title for the new page. NOTE: changing a page's title will change its url. The updated url will be returned in the result.
        :param str wiki_page_body: The content for the new page.
        :param str wiki_page_editing_roles: Which user roles are allowed to edit this page. Any combination of these roles is allowed (separated by commas).  \"teachers\":: Allows editing by teachers in the course. \"students\":: Allows editing by students in the course. \"members\":: For group wikis, allows editing by members of the group. \"public\":: Allows editing by any user.
        :param bool wiki_page_notify_of_update: Whether participants should be notified when this page changes.
        :param bool wiki_page_published: Whether the page is published (true) or draft state (false).
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_create_front_page_courses_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_create_front_page_courses_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def update_create_front_page_courses_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Update/create front page  # noqa: E501

        Update the title or contents of the front page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_create_front_page_courses_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str wiki_page_title: The title for the new page. NOTE: changing a page's title will change its url. The updated url will be returned in the result.
        :param str wiki_page_body: The content for the new page.
        :param str wiki_page_editing_roles: Which user roles are allowed to edit this page. Any combination of these roles is allowed (separated by commas).  \"teachers\":: Allows editing by teachers in the course. \"students\":: Allows editing by students in the course. \"members\":: For group wikis, allows editing by members of the group. \"public\":: Allows editing by any user.
        :param bool wiki_page_notify_of_update: Whether participants should be notified when this page changes.
        :param bool wiki_page_published: Whether the page is published (true) or draft state (false).
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'wiki_page_title', 'wiki_page_body', 'wiki_page_editing_roles', 'wiki_page_notify_of_update', 'wiki_page_published']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_create_front_page_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `update_create_front_page_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'wiki_page_title' in params:
            form_params.append(('wiki_page[title]', params['wiki_page_title']))  # noqa: E501
        if 'wiki_page_body' in params:
            form_params.append(('wiki_page[body]', params['wiki_page_body']))  # noqa: E501
        if 'wiki_page_editing_roles' in params:
            form_params.append(('wiki_page[editing_roles]', params['wiki_page_editing_roles']))  # noqa: E501
        if 'wiki_page_notify_of_update' in params:
            form_params.append(('wiki_page[notify_of_update]', params['wiki_page_notify_of_update']))  # noqa: E501
        if 'wiki_page_published' in params:
            form_params.append(('wiki_page[published]', params['wiki_page_published']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/front_page', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Page',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_create_front_page_groups(self, group_id, **kwargs):  # noqa: E501
        """Update/create front page  # noqa: E501

        Update the title or contents of the front page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_create_front_page_groups(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str wiki_page_title: The title for the new page. NOTE: changing a page's title will change its url. The updated url will be returned in the result.
        :param str wiki_page_body: The content for the new page.
        :param str wiki_page_editing_roles: Which user roles are allowed to edit this page. Any combination of these roles is allowed (separated by commas).  \"teachers\":: Allows editing by teachers in the course. \"students\":: Allows editing by students in the course. \"members\":: For group wikis, allows editing by members of the group. \"public\":: Allows editing by any user.
        :param bool wiki_page_notify_of_update: Whether participants should be notified when this page changes.
        :param bool wiki_page_published: Whether the page is published (true) or draft state (false).
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_create_front_page_groups_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_create_front_page_groups_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def update_create_front_page_groups_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """Update/create front page  # noqa: E501

        Update the title or contents of the front page  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_create_front_page_groups_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str wiki_page_title: The title for the new page. NOTE: changing a page's title will change its url. The updated url will be returned in the result.
        :param str wiki_page_body: The content for the new page.
        :param str wiki_page_editing_roles: Which user roles are allowed to edit this page. Any combination of these roles is allowed (separated by commas).  \"teachers\":: Allows editing by teachers in the course. \"students\":: Allows editing by students in the course. \"members\":: For group wikis, allows editing by members of the group. \"public\":: Allows editing by any user.
        :param bool wiki_page_notify_of_update: Whether participants should be notified when this page changes.
        :param bool wiki_page_published: Whether the page is published (true) or draft state (false).
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'wiki_page_title', 'wiki_page_body', 'wiki_page_editing_roles', 'wiki_page_notify_of_update', 'wiki_page_published']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_create_front_page_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `update_create_front_page_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'wiki_page_title' in params:
            form_params.append(('wiki_page[title]', params['wiki_page_title']))  # noqa: E501
        if 'wiki_page_body' in params:
            form_params.append(('wiki_page[body]', params['wiki_page_body']))  # noqa: E501
        if 'wiki_page_editing_roles' in params:
            form_params.append(('wiki_page[editing_roles]', params['wiki_page_editing_roles']))  # noqa: E501
        if 'wiki_page_notify_of_update' in params:
            form_params.append(('wiki_page[notify_of_update]', params['wiki_page_notify_of_update']))  # noqa: E501
        if 'wiki_page_published' in params:
            form_params.append(('wiki_page[published]', params['wiki_page_published']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/front_page', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Page',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_create_page_courses(self, course_id, url_or_id, **kwargs):  # noqa: E501
        """Update/create page  # noqa: E501

        Update the title or contents of a wiki page  NOTE: You cannot specify the ID when creating a page. If you pass a numeric value as the page identifier and that does not represent a page ID that already exists, it will be interpreted as a URL.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_create_page_courses(course_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str url_or_id: ID (required)
        :param str wiki_page_title: The title for the new page. NOTE: changing a page's title will change its url. The updated url will be returned in the result.
        :param str wiki_page_body: The content for the new page.
        :param str wiki_page_editing_roles: Which user roles are allowed to edit this page. Any combination of these roles is allowed (separated by commas).  \"teachers\":: Allows editing by teachers in the course. \"students\":: Allows editing by students in the course. \"members\":: For group wikis, allows editing by members of the group. \"public\":: Allows editing by any user.
        :param bool wiki_page_notify_of_update: Whether participants should be notified when this page changes.
        :param bool wiki_page_published: Whether the page is published (true) or draft state (false).
        :param Object wiki_page_publish_at: Schedule a future date/time to publish the page. This will have no effect unless the \"Scheduled Page Publication\" feature is enabled in the account. If a future date is set and the page is already published, it will be unpublished.
        :param bool wiki_page_front_page: Set an unhidden page as the front page (if true)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_create_page_courses_with_http_info(course_id, url_or_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_create_page_courses_with_http_info(course_id, url_or_id, **kwargs)  # noqa: E501
            return data

    def update_create_page_courses_with_http_info(self, course_id, url_or_id, **kwargs):  # noqa: E501
        """Update/create page  # noqa: E501

        Update the title or contents of a wiki page  NOTE: You cannot specify the ID when creating a page. If you pass a numeric value as the page identifier and that does not represent a page ID that already exists, it will be interpreted as a URL.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_create_page_courses_with_http_info(course_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str url_or_id: ID (required)
        :param str wiki_page_title: The title for the new page. NOTE: changing a page's title will change its url. The updated url will be returned in the result.
        :param str wiki_page_body: The content for the new page.
        :param str wiki_page_editing_roles: Which user roles are allowed to edit this page. Any combination of these roles is allowed (separated by commas).  \"teachers\":: Allows editing by teachers in the course. \"students\":: Allows editing by students in the course. \"members\":: For group wikis, allows editing by members of the group. \"public\":: Allows editing by any user.
        :param bool wiki_page_notify_of_update: Whether participants should be notified when this page changes.
        :param bool wiki_page_published: Whether the page is published (true) or draft state (false).
        :param Object wiki_page_publish_at: Schedule a future date/time to publish the page. This will have no effect unless the \"Scheduled Page Publication\" feature is enabled in the account. If a future date is set and the page is already published, it will be unpublished.
        :param bool wiki_page_front_page: Set an unhidden page as the front page (if true)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'url_or_id', 'wiki_page_title', 'wiki_page_body', 'wiki_page_editing_roles', 'wiki_page_notify_of_update', 'wiki_page_published', 'wiki_page_publish_at', 'wiki_page_front_page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_create_page_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `update_create_page_courses`")  # noqa: E501
        # verify the required parameter 'url_or_id' is set
        if self.api_client.client_side_validation and ('url_or_id' not in params or
                                                       params['url_or_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `url_or_id` when calling `update_create_page_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501
        if 'url_or_id' in params:
            path_params['url_or_id'] = params['url_or_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'wiki_page_title' in params:
            form_params.append(('wiki_page[title]', params['wiki_page_title']))  # noqa: E501
        if 'wiki_page_body' in params:
            form_params.append(('wiki_page[body]', params['wiki_page_body']))  # noqa: E501
        if 'wiki_page_editing_roles' in params:
            form_params.append(('wiki_page[editing_roles]', params['wiki_page_editing_roles']))  # noqa: E501
        if 'wiki_page_notify_of_update' in params:
            form_params.append(('wiki_page[notify_of_update]', params['wiki_page_notify_of_update']))  # noqa: E501
        if 'wiki_page_published' in params:
            form_params.append(('wiki_page[published]', params['wiki_page_published']))  # noqa: E501
        if 'wiki_page_publish_at' in params:
            form_params.append(('wiki_page[publish_at]', params['wiki_page_publish_at']))  # noqa: E501
        if 'wiki_page_front_page' in params:
            form_params.append(('wiki_page[front_page]', params['wiki_page_front_page']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/courses/{course_id}/pages/{url_or_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Page',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_create_page_groups(self, group_id, url_or_id, **kwargs):  # noqa: E501
        """Update/create page  # noqa: E501

        Update the title or contents of a wiki page  NOTE: You cannot specify the ID when creating a page. If you pass a numeric value as the page identifier and that does not represent a page ID that already exists, it will be interpreted as a URL.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_create_page_groups(group_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str url_or_id: ID (required)
        :param str wiki_page_title: The title for the new page. NOTE: changing a page's title will change its url. The updated url will be returned in the result.
        :param str wiki_page_body: The content for the new page.
        :param str wiki_page_editing_roles: Which user roles are allowed to edit this page. Any combination of these roles is allowed (separated by commas).  \"teachers\":: Allows editing by teachers in the course. \"students\":: Allows editing by students in the course. \"members\":: For group wikis, allows editing by members of the group. \"public\":: Allows editing by any user.
        :param bool wiki_page_notify_of_update: Whether participants should be notified when this page changes.
        :param bool wiki_page_published: Whether the page is published (true) or draft state (false).
        :param Object wiki_page_publish_at: Schedule a future date/time to publish the page. This will have no effect unless the \"Scheduled Page Publication\" feature is enabled in the account. If a future date is set and the page is already published, it will be unpublished.
        :param bool wiki_page_front_page: Set an unhidden page as the front page (if true)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_create_page_groups_with_http_info(group_id, url_or_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_create_page_groups_with_http_info(group_id, url_or_id, **kwargs)  # noqa: E501
            return data

    def update_create_page_groups_with_http_info(self, group_id, url_or_id, **kwargs):  # noqa: E501
        """Update/create page  # noqa: E501

        Update the title or contents of a wiki page  NOTE: You cannot specify the ID when creating a page. If you pass a numeric value as the page identifier and that does not represent a page ID that already exists, it will be interpreted as a URL.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_create_page_groups_with_http_info(group_id, url_or_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: ID (required)
        :param str url_or_id: ID (required)
        :param str wiki_page_title: The title for the new page. NOTE: changing a page's title will change its url. The updated url will be returned in the result.
        :param str wiki_page_body: The content for the new page.
        :param str wiki_page_editing_roles: Which user roles are allowed to edit this page. Any combination of these roles is allowed (separated by commas).  \"teachers\":: Allows editing by teachers in the course. \"students\":: Allows editing by students in the course. \"members\":: For group wikis, allows editing by members of the group. \"public\":: Allows editing by any user.
        :param bool wiki_page_notify_of_update: Whether participants should be notified when this page changes.
        :param bool wiki_page_published: Whether the page is published (true) or draft state (false).
        :param Object wiki_page_publish_at: Schedule a future date/time to publish the page. This will have no effect unless the \"Scheduled Page Publication\" feature is enabled in the account. If a future date is set and the page is already published, it will be unpublished.
        :param bool wiki_page_front_page: Set an unhidden page as the front page (if true)
        :return: Page
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'url_or_id', 'wiki_page_title', 'wiki_page_body', 'wiki_page_editing_roles', 'wiki_page_notify_of_update', 'wiki_page_published', 'wiki_page_publish_at', 'wiki_page_front_page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_create_page_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `update_create_page_groups`")  # noqa: E501
        # verify the required parameter 'url_or_id' is set
        if self.api_client.client_side_validation and ('url_or_id' not in params or
                                                       params['url_or_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `url_or_id` when calling `update_create_page_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'url_or_id' in params:
            path_params['url_or_id'] = params['url_or_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'wiki_page_title' in params:
            form_params.append(('wiki_page[title]', params['wiki_page_title']))  # noqa: E501
        if 'wiki_page_body' in params:
            form_params.append(('wiki_page[body]', params['wiki_page_body']))  # noqa: E501
        if 'wiki_page_editing_roles' in params:
            form_params.append(('wiki_page[editing_roles]', params['wiki_page_editing_roles']))  # noqa: E501
        if 'wiki_page_notify_of_update' in params:
            form_params.append(('wiki_page[notify_of_update]', params['wiki_page_notify_of_update']))  # noqa: E501
        if 'wiki_page_published' in params:
            form_params.append(('wiki_page[published]', params['wiki_page_published']))  # noqa: E501
        if 'wiki_page_publish_at' in params:
            form_params.append(('wiki_page[publish_at]', params['wiki_page_publish_at']))  # noqa: E501
        if 'wiki_page_front_page' in params:
            form_params.append(('wiki_page[front_page]', params['wiki_page_front_page']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/groups/{group_id}/pages/{url_or_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Page',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
