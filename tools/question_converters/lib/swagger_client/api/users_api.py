# coding: utf-8

"""

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class UsersApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def activity_stream_summary(self, **kwargs):  # noqa: E501
        """Activity stream summary  # noqa: E501

        Returns a summary of the current user's global activity stream.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.activity_stream_summary(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool only_active_courses: If true, will only return objects for courses the user is actively participating in
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.activity_stream_summary_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.activity_stream_summary_with_http_info(**kwargs)  # noqa: E501
            return data

    def activity_stream_summary_with_http_info(self, **kwargs):  # noqa: E501
        """Activity stream summary  # noqa: E501

        Returns a summary of the current user's global activity stream.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.activity_stream_summary_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool only_active_courses: If true, will only return objects for courses the user is actively participating in
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['only_active_courses']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method activity_stream_summary" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'only_active_courses' in params:
            query_params.append(('only_active_courses', params['only_active_courses']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/self/activity_stream/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def clear_course_nicknames(self, **kwargs):  # noqa: E501
        """Clear course nicknames  # noqa: E501

        Remove all stored course nicknames.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clear_course_nicknames(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.clear_course_nicknames_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.clear_course_nicknames_with_http_info(**kwargs)  # noqa: E501
            return data

    def clear_course_nicknames_with_http_info(self, **kwargs):  # noqa: E501
        """Clear course nicknames  # noqa: E501

        Remove all stored course nicknames.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clear_course_nicknames_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clear_course_nicknames" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/self/course_nicknames', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_user(self, account_id, pseudonym_unique_id, **kwargs):  # noqa: E501
        """Create a user  # noqa: E501

        Create and return a new user and pseudonym for an account.  [DEPRECATED (for self-registration only)] If you don't have the \"Modify login details for users\" permission, but self-registration is enabled on the account, you can still use this endpoint to register new users. Certain fields will be required, and others will be ignored (see below).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_user(account_id, pseudonym_unique_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str pseudonym_unique_id: User's login ID. If this is a self-registration, it must be a valid email address. (required)
        :param str user_name: The full name of the user. This name will be used by teacher for grading. Required if this is a self-registration.
        :param str user_short_name: User's name as it will be displayed in discussions, messages, and comments.
        :param str user_sortable_name: User's name as used to sort alphabetically in lists.
        :param str user_time_zone: The time zone for the user. Allowed time zones are {http://www.iana.org/time-zones IANA time zones} or friendlier {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
        :param str user_locale: The user's preferred language, from the list of languages Canvas supports. This is in RFC-5646 format.
        :param bool user_terms_of_use: Whether the user accepts the terms of use. Required if this is a self-registration and this canvas instance requires users to accept the terms (on by default).  If this is true, it will mark the user as having accepted the terms of use.
        :param bool user_skip_registration: Automatically mark the user as registered.  If this is true, it is recommended to set <tt>\"pseudonym[send_confirmation]\"</tt> to true as well. Otherwise, the user will not receive any messages about their account creation.  The users communication channel confirmation can be skipped by setting <tt>\"communication_channel[skip_confirmation]\"</tt> to true as well.
        :param str pseudonym_password: User's password. Cannot be set during self-registration.
        :param str pseudonym_sis_user_id: SIS ID for the user's account. To set this parameter, the caller must be able to manage SIS permissions.
        :param str pseudonym_integration_id: Integration ID for the login. To set this parameter, the caller must be able to manage SIS permissions. The Integration ID is a secondary identifier useful for more complex SIS integrations.
        :param bool pseudonym_send_confirmation: Send user notification of account creation if true. Automatically set to true during self-registration.
        :param bool pseudonym_force_self_registration: Send user a self-registration style email if true. Setting it means the users will get a notification asking them to \"complete the registration process\" by clicking it, setting a password, and letting them in.  Will only be executed on if the user does not need admin approval. Defaults to false unless explicitly provided.
        :param str pseudonym_authentication_provider_id: The authentication provider this login is associated with. Logins associated with a specific provider can only be used with that provider. Legacy providers (LDAP, CAS, SAML) will search for logins associated with them, or unassociated logins. New providers will only search for logins explicitly associated with them. This can be the integer ID of the provider, or the type of the provider (in which case, it will find the first matching provider).
        :param str communication_channel_type: The communication channel type, e.g. 'email' or 'sms'.
        :param str communication_channel_address: The communication channel address, e.g. the user's email address.
        :param bool communication_channel_confirmation_url: Only valid for account admins. If true, returns the new user account confirmation URL in the response.
        :param bool communication_channel_skip_confirmation: Only valid for site admins and account admins making requests; If true, the channel is automatically validated and no confirmation email or SMS is sent. Otherwise, the user must respond to a confirmation message to confirm the channel.  If this is true, it is recommended to set <tt>\"pseudonym[send_confirmation]\"</tt> to true as well. Otherwise, the user will not receive any messages about their account creation.
        :param bool force_validations: If true, validations are performed on the newly created user (and their associated pseudonym) even if the request is made by a privileged user like an admin. When set to false, or not included in the request parameters, any newly created users are subject to validations unless the request is made by a user with a 'manage_user_logins' right. In which case, certain validations such as 'require_acceptance_of_terms' and 'require_presence_of_name' are not enforced. Use this parameter to return helpful json errors while building users with an admin request.
        :param bool enable_sis_reactivation: When true, will first try to re-activate a deleted user with matching sis_user_id if possible. This is commonly done with user[skip_registration] and communication_channel[skip_confirmation] so that the default communication_channel is also restored.
        :param Object destination: If you're setting the password for the newly created user, you can provide this param with a valid URL pointing into this Canvas installation, and the response will include a destination field that's a URL that you can redirect a browser to and have the newly created user automatically logged in. The URL is only valid for a short time, and must match the domain this request is directed to, and be for a well-formed path that Canvas can recognize.
        :param str initial_enrollment_type: `observer` if doing a self-registration with a pairing code. This allows setting the password during user creation.
        :param str pairing_code_code: If provided and valid, will link the new user as an observer to the student's whose pairing code is given.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_user_with_http_info(account_id, pseudonym_unique_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_user_with_http_info(account_id, pseudonym_unique_id, **kwargs)  # noqa: E501
            return data

    def create_user_with_http_info(self, account_id, pseudonym_unique_id, **kwargs):  # noqa: E501
        """Create a user  # noqa: E501

        Create and return a new user and pseudonym for an account.  [DEPRECATED (for self-registration only)] If you don't have the \"Modify login details for users\" permission, but self-registration is enabled on the account, you can still use this endpoint to register new users. Certain fields will be required, and others will be ignored (see below).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_user_with_http_info(account_id, pseudonym_unique_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str pseudonym_unique_id: User's login ID. If this is a self-registration, it must be a valid email address. (required)
        :param str user_name: The full name of the user. This name will be used by teacher for grading. Required if this is a self-registration.
        :param str user_short_name: User's name as it will be displayed in discussions, messages, and comments.
        :param str user_sortable_name: User's name as used to sort alphabetically in lists.
        :param str user_time_zone: The time zone for the user. Allowed time zones are {http://www.iana.org/time-zones IANA time zones} or friendlier {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
        :param str user_locale: The user's preferred language, from the list of languages Canvas supports. This is in RFC-5646 format.
        :param bool user_terms_of_use: Whether the user accepts the terms of use. Required if this is a self-registration and this canvas instance requires users to accept the terms (on by default).  If this is true, it will mark the user as having accepted the terms of use.
        :param bool user_skip_registration: Automatically mark the user as registered.  If this is true, it is recommended to set <tt>\"pseudonym[send_confirmation]\"</tt> to true as well. Otherwise, the user will not receive any messages about their account creation.  The users communication channel confirmation can be skipped by setting <tt>\"communication_channel[skip_confirmation]\"</tt> to true as well.
        :param str pseudonym_password: User's password. Cannot be set during self-registration.
        :param str pseudonym_sis_user_id: SIS ID for the user's account. To set this parameter, the caller must be able to manage SIS permissions.
        :param str pseudonym_integration_id: Integration ID for the login. To set this parameter, the caller must be able to manage SIS permissions. The Integration ID is a secondary identifier useful for more complex SIS integrations.
        :param bool pseudonym_send_confirmation: Send user notification of account creation if true. Automatically set to true during self-registration.
        :param bool pseudonym_force_self_registration: Send user a self-registration style email if true. Setting it means the users will get a notification asking them to \"complete the registration process\" by clicking it, setting a password, and letting them in.  Will only be executed on if the user does not need admin approval. Defaults to false unless explicitly provided.
        :param str pseudonym_authentication_provider_id: The authentication provider this login is associated with. Logins associated with a specific provider can only be used with that provider. Legacy providers (LDAP, CAS, SAML) will search for logins associated with them, or unassociated logins. New providers will only search for logins explicitly associated with them. This can be the integer ID of the provider, or the type of the provider (in which case, it will find the first matching provider).
        :param str communication_channel_type: The communication channel type, e.g. 'email' or 'sms'.
        :param str communication_channel_address: The communication channel address, e.g. the user's email address.
        :param bool communication_channel_confirmation_url: Only valid for account admins. If true, returns the new user account confirmation URL in the response.
        :param bool communication_channel_skip_confirmation: Only valid for site admins and account admins making requests; If true, the channel is automatically validated and no confirmation email or SMS is sent. Otherwise, the user must respond to a confirmation message to confirm the channel.  If this is true, it is recommended to set <tt>\"pseudonym[send_confirmation]\"</tt> to true as well. Otherwise, the user will not receive any messages about their account creation.
        :param bool force_validations: If true, validations are performed on the newly created user (and their associated pseudonym) even if the request is made by a privileged user like an admin. When set to false, or not included in the request parameters, any newly created users are subject to validations unless the request is made by a user with a 'manage_user_logins' right. In which case, certain validations such as 'require_acceptance_of_terms' and 'require_presence_of_name' are not enforced. Use this parameter to return helpful json errors while building users with an admin request.
        :param bool enable_sis_reactivation: When true, will first try to re-activate a deleted user with matching sis_user_id if possible. This is commonly done with user[skip_registration] and communication_channel[skip_confirmation] so that the default communication_channel is also restored.
        :param Object destination: If you're setting the password for the newly created user, you can provide this param with a valid URL pointing into this Canvas installation, and the response will include a destination field that's a URL that you can redirect a browser to and have the newly created user automatically logged in. The URL is only valid for a short time, and must match the domain this request is directed to, and be for a well-formed path that Canvas can recognize.
        :param str initial_enrollment_type: `observer` if doing a self-registration with a pairing code. This allows setting the password during user creation.
        :param str pairing_code_code: If provided and valid, will link the new user as an observer to the student's whose pairing code is given.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'pseudonym_unique_id', 'user_name', 'user_short_name', 'user_sortable_name', 'user_time_zone', 'user_locale', 'user_terms_of_use', 'user_skip_registration', 'pseudonym_password', 'pseudonym_sis_user_id', 'pseudonym_integration_id', 'pseudonym_send_confirmation', 'pseudonym_force_self_registration', 'pseudonym_authentication_provider_id', 'communication_channel_type', 'communication_channel_address', 'communication_channel_confirmation_url', 'communication_channel_skip_confirmation', 'force_validations', 'enable_sis_reactivation', 'destination', 'initial_enrollment_type', 'pairing_code_code']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `create_user`")  # noqa: E501
        # verify the required parameter 'pseudonym_unique_id' is set
        if self.api_client.client_side_validation and ('pseudonym_unique_id' not in params or
                                                       params['pseudonym_unique_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `pseudonym_unique_id` when calling `create_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'user_name' in params:
            form_params.append(('user[name]', params['user_name']))  # noqa: E501
        if 'user_short_name' in params:
            form_params.append(('user[short_name]', params['user_short_name']))  # noqa: E501
        if 'user_sortable_name' in params:
            form_params.append(('user[sortable_name]', params['user_sortable_name']))  # noqa: E501
        if 'user_time_zone' in params:
            form_params.append(('user[time_zone]', params['user_time_zone']))  # noqa: E501
        if 'user_locale' in params:
            form_params.append(('user[locale]', params['user_locale']))  # noqa: E501
        if 'user_terms_of_use' in params:
            form_params.append(('user[terms_of_use]', params['user_terms_of_use']))  # noqa: E501
        if 'user_skip_registration' in params:
            form_params.append(('user[skip_registration]', params['user_skip_registration']))  # noqa: E501
        if 'pseudonym_unique_id' in params:
            form_params.append(('pseudonym[unique_id]', params['pseudonym_unique_id']))  # noqa: E501
        if 'pseudonym_password' in params:
            form_params.append(('pseudonym[password]', params['pseudonym_password']))  # noqa: E501
        if 'pseudonym_sis_user_id' in params:
            form_params.append(('pseudonym[sis_user_id]', params['pseudonym_sis_user_id']))  # noqa: E501
        if 'pseudonym_integration_id' in params:
            form_params.append(('pseudonym[integration_id]', params['pseudonym_integration_id']))  # noqa: E501
        if 'pseudonym_send_confirmation' in params:
            form_params.append(('pseudonym[send_confirmation]', params['pseudonym_send_confirmation']))  # noqa: E501
        if 'pseudonym_force_self_registration' in params:
            form_params.append(('pseudonym[force_self_registration]', params['pseudonym_force_self_registration']))  # noqa: E501
        if 'pseudonym_authentication_provider_id' in params:
            form_params.append(('pseudonym[authentication_provider_id]', params['pseudonym_authentication_provider_id']))  # noqa: E501
        if 'communication_channel_type' in params:
            form_params.append(('communication_channel[type]', params['communication_channel_type']))  # noqa: E501
        if 'communication_channel_address' in params:
            form_params.append(('communication_channel[address]', params['communication_channel_address']))  # noqa: E501
        if 'communication_channel_confirmation_url' in params:
            form_params.append(('communication_channel[confirmation_url]', params['communication_channel_confirmation_url']))  # noqa: E501
        if 'communication_channel_skip_confirmation' in params:
            form_params.append(('communication_channel[skip_confirmation]', params['communication_channel_skip_confirmation']))  # noqa: E501
        if 'force_validations' in params:
            form_params.append(('force_validations', params['force_validations']))  # noqa: E501
        if 'enable_sis_reactivation' in params:
            form_params.append(('enable_sis_reactivation', params['enable_sis_reactivation']))  # noqa: E501
        if 'destination' in params:
            form_params.append(('destination', params['destination']))  # noqa: E501
        if 'initial_enrollment_type' in params:
            form_params.append(('initial_enrollment_type', params['initial_enrollment_type']))  # noqa: E501
        if 'pairing_code_code' in params:
            form_params.append(('pairing_code[code]', params['pairing_code_code']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/users', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_custom_data(self, user_id, ns, **kwargs):  # noqa: E501
        """Delete custom data  # noqa: E501

        Delete custom user data.  Arbitrary JSON data can be stored for a User.  This API call deletes that data for a given scope.  Without a scope, all custom_data is deleted. See {api:UsersController#set_custom_data Store Custom Data} for details and examples of storage and retrieval.  As an example, we'll store some data, then delete a subset of it.  Example {api:UsersController#set_custom_data PUT} with valid JSON data:   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data' \\     -X PUT \\     -F 'ns=com.my-organization.canvas-app' \\     -F 'data[fruit][apple]=so tasty' \\     -F 'data[fruit][kiwi]=a bit sour' \\     -F 'data[veggies][root][onion]=tear-jerking' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": {       \"fruit\": {         \"apple\": \"so tasty\",         \"kiwi\": \"a bit sour\"       },       \"veggies\": {         \"root\": {           \"onion\": \"tear-jerking\"         }       }     }   }  Example DELETE:   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data/fruit/kiwi' \\     -X DELETE \\     -F 'ns=com.my-organization.canvas-app' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": \"a bit sour\"   }  Example {api:UsersController#get_custom_data GET} following the above DELETE:   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data' \\     -X GET \\     -F 'ns=com.my-organization.canvas-app' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": {       \"fruit\": {         \"apple\": \"so tasty\"       },       \"veggies\": {         \"root\": {           \"onion\": \"tear-jerking\"         }       }     }   }  Note that hashes left empty after a DELETE will get removed from the custom_data store. For example, following the previous commands, if we delete /custom_data/veggies/root/onion, then the entire /custom_data/veggies scope will be removed.  Example DELETE that empties a parent scope:   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data/veggies/root/onion' \\     -X DELETE \\     -F 'ns=com.my-organization.canvas-app' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": \"tear-jerking\"   }  Example {api:UsersController#get_custom_data GET} following the above DELETE:   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data' \\     -X GET \\     -F 'ns=com.my-organization.canvas-app' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": {       \"fruit\": {         \"apple\": \"so tasty\"       }     }   }  On success, this endpoint returns an object containing the data that was deleted.  Responds with status code 400 if the namespace parameter, +ns+, is missing or invalid, or if the specified scope does not contain any data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_custom_data(user_id, ns, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str ns: The namespace from which to delete the data.  This should be something other Canvas API apps aren't likely to use, such as a reverse DNS for your organization. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_custom_data_with_http_info(user_id, ns, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_custom_data_with_http_info(user_id, ns, **kwargs)  # noqa: E501
            return data

    def delete_custom_data_with_http_info(self, user_id, ns, **kwargs):  # noqa: E501
        """Delete custom data  # noqa: E501

        Delete custom user data.  Arbitrary JSON data can be stored for a User.  This API call deletes that data for a given scope.  Without a scope, all custom_data is deleted. See {api:UsersController#set_custom_data Store Custom Data} for details and examples of storage and retrieval.  As an example, we'll store some data, then delete a subset of it.  Example {api:UsersController#set_custom_data PUT} with valid JSON data:   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data' \\     -X PUT \\     -F 'ns=com.my-organization.canvas-app' \\     -F 'data[fruit][apple]=so tasty' \\     -F 'data[fruit][kiwi]=a bit sour' \\     -F 'data[veggies][root][onion]=tear-jerking' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": {       \"fruit\": {         \"apple\": \"so tasty\",         \"kiwi\": \"a bit sour\"       },       \"veggies\": {         \"root\": {           \"onion\": \"tear-jerking\"         }       }     }   }  Example DELETE:   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data/fruit/kiwi' \\     -X DELETE \\     -F 'ns=com.my-organization.canvas-app' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": \"a bit sour\"   }  Example {api:UsersController#get_custom_data GET} following the above DELETE:   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data' \\     -X GET \\     -F 'ns=com.my-organization.canvas-app' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": {       \"fruit\": {         \"apple\": \"so tasty\"       },       \"veggies\": {         \"root\": {           \"onion\": \"tear-jerking\"         }       }     }   }  Note that hashes left empty after a DELETE will get removed from the custom_data store. For example, following the previous commands, if we delete /custom_data/veggies/root/onion, then the entire /custom_data/veggies scope will be removed.  Example DELETE that empties a parent scope:   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data/veggies/root/onion' \\     -X DELETE \\     -F 'ns=com.my-organization.canvas-app' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": \"tear-jerking\"   }  Example {api:UsersController#get_custom_data GET} following the above DELETE:   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data' \\     -X GET \\     -F 'ns=com.my-organization.canvas-app' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": {       \"fruit\": {         \"apple\": \"so tasty\"       }     }   }  On success, this endpoint returns an object containing the data that was deleted.  Responds with status code 400 if the namespace parameter, +ns+, is missing or invalid, or if the specified scope does not contain any data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_custom_data_with_http_info(user_id, ns, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str ns: The namespace from which to delete the data.  This should be something other Canvas API apps aren't likely to use, such as a reverse DNS for your organization. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'ns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_custom_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `delete_custom_data`")  # noqa: E501
        # verify the required parameter 'ns' is set
        if self.api_client.client_side_validation and ('ns' not in params or
                                                       params['ns'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ns` when calling `delete_custom_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'ns' in params:
            query_params.append(('ns', params['ns']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/custom_data', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def deprecated_self_register_user(self, account_id, user_name, user_terms_of_use, pseudonym_unique_id, **kwargs):  # noqa: E501
        """[DEPRECATED] Self register a user  # noqa: E501

        Self register and return a new user and pseudonym for an account.  If self-registration is enabled on the account, you can use this endpoint to self register new users.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deprecated_self_register_user(account_id, user_name, user_terms_of_use, pseudonym_unique_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str user_name: The full name of the user. This name will be used by teacher for grading. (required)
        :param bool user_terms_of_use: Whether the user accepts the terms of use. (required)
        :param str pseudonym_unique_id: User's login ID. Must be a valid email address. (required)
        :param str user_short_name: User's name as it will be displayed in discussions, messages, and comments.
        :param str user_sortable_name: User's name as used to sort alphabetically in lists.
        :param str user_time_zone: The time zone for the user. Allowed time zones are {http://www.iana.org/time-zones IANA time zones} or friendlier {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
        :param str user_locale: The user's preferred language, from the list of languages Canvas supports. This is in RFC-5646 format.
        :param str communication_channel_type: The communication channel type, e.g. 'email' or 'sms'.
        :param str communication_channel_address: The communication channel address, e.g. the user's email address.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.deprecated_self_register_user_with_http_info(account_id, user_name, user_terms_of_use, pseudonym_unique_id, **kwargs)  # noqa: E501
        else:
            (data) = self.deprecated_self_register_user_with_http_info(account_id, user_name, user_terms_of_use, pseudonym_unique_id, **kwargs)  # noqa: E501
            return data

    def deprecated_self_register_user_with_http_info(self, account_id, user_name, user_terms_of_use, pseudonym_unique_id, **kwargs):  # noqa: E501
        """[DEPRECATED] Self register a user  # noqa: E501

        Self register and return a new user and pseudonym for an account.  If self-registration is enabled on the account, you can use this endpoint to self register new users.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deprecated_self_register_user_with_http_info(account_id, user_name, user_terms_of_use, pseudonym_unique_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str user_name: The full name of the user. This name will be used by teacher for grading. (required)
        :param bool user_terms_of_use: Whether the user accepts the terms of use. (required)
        :param str pseudonym_unique_id: User's login ID. Must be a valid email address. (required)
        :param str user_short_name: User's name as it will be displayed in discussions, messages, and comments.
        :param str user_sortable_name: User's name as used to sort alphabetically in lists.
        :param str user_time_zone: The time zone for the user. Allowed time zones are {http://www.iana.org/time-zones IANA time zones} or friendlier {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
        :param str user_locale: The user's preferred language, from the list of languages Canvas supports. This is in RFC-5646 format.
        :param str communication_channel_type: The communication channel type, e.g. 'email' or 'sms'.
        :param str communication_channel_address: The communication channel address, e.g. the user's email address.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'user_name', 'user_terms_of_use', 'pseudonym_unique_id', 'user_short_name', 'user_sortable_name', 'user_time_zone', 'user_locale', 'communication_channel_type', 'communication_channel_address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deprecated_self_register_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `deprecated_self_register_user`")  # noqa: E501
        # verify the required parameter 'user_name' is set
        if self.api_client.client_side_validation and ('user_name' not in params or
                                                       params['user_name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_name` when calling `deprecated_self_register_user`")  # noqa: E501
        # verify the required parameter 'user_terms_of_use' is set
        if self.api_client.client_side_validation and ('user_terms_of_use' not in params or
                                                       params['user_terms_of_use'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_terms_of_use` when calling `deprecated_self_register_user`")  # noqa: E501
        # verify the required parameter 'pseudonym_unique_id' is set
        if self.api_client.client_side_validation and ('pseudonym_unique_id' not in params or
                                                       params['pseudonym_unique_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `pseudonym_unique_id` when calling `deprecated_self_register_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'user_name' in params:
            form_params.append(('user[name]', params['user_name']))  # noqa: E501
        if 'user_short_name' in params:
            form_params.append(('user[short_name]', params['user_short_name']))  # noqa: E501
        if 'user_sortable_name' in params:
            form_params.append(('user[sortable_name]', params['user_sortable_name']))  # noqa: E501
        if 'user_time_zone' in params:
            form_params.append(('user[time_zone]', params['user_time_zone']))  # noqa: E501
        if 'user_locale' in params:
            form_params.append(('user[locale]', params['user_locale']))  # noqa: E501
        if 'user_terms_of_use' in params:
            form_params.append(('user[terms_of_use]', params['user_terms_of_use']))  # noqa: E501
        if 'pseudonym_unique_id' in params:
            form_params.append(('pseudonym[unique_id]', params['pseudonym_unique_id']))  # noqa: E501
        if 'communication_channel_type' in params:
            form_params.append(('communication_channel[type]', params['communication_channel_type']))  # noqa: E501
        if 'communication_channel_address' in params:
            form_params.append(('communication_channel[address]', params['communication_channel_address']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/self_registration', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_user(self, id, **kwargs):  # noqa: E501
        """Edit a user  # noqa: E501

        Modify an existing user. To modify a user's login, see the documentation for logins.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_user(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str user_name: The full name of the user. This name will be used by teacher for grading.
        :param str user_short_name: User's name as it will be displayed in discussions, messages, and comments.
        :param str user_sortable_name: User's name as used to sort alphabetically in lists.
        :param str user_time_zone: The time zone for the user. Allowed time zones are {http://www.iana.org/time-zones IANA time zones} or friendlier {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
        :param str user_email: The default email address of the user.
        :param str user_locale: The user's preferred language, from the list of languages Canvas supports. This is in RFC-5646 format.
        :param str user_avatar_token: A unique representation of the avatar record to assign as the user's current avatar. This token can be obtained from the user avatars endpoint. This supersedes the user [avatar] [url] argument, and if both are included the url will be ignored. Note: this is an internal representation and is subject to change without notice. It should be consumed with this api endpoint and used in the user update endpoint, and should not be constructed by the client.
        :param str user_avatar_url: To set the user's avatar to point to an external url, do not include a token and instead pass the url here. Warning: For maximum compatibility, please use 128 px square images.
        :param str user_avatar_state: To set the state of user's avatar. Only valid for account administrator.
        :param str user_title: Sets a title on the user profile. (See {api:ProfileController#settings Get user profile}.) Profiles must be enabled on the root account.
        :param str user_bio: Sets a bio on the user profile. (See {api:ProfileController#settings Get user profile}.) Profiles must be enabled on the root account.
        :param str user_pronunciation: Sets name pronunciation on the user profile. (See {api:ProfileController#settings Get user profile}.) Profiles and name pronunciation must be enabled on the root account.
        :param str user_pronouns: Sets pronouns on the user profile. Passing an empty string will empty the user's pronouns Only Available Pronouns set on the root account are allowed Adding and changing pronouns must be enabled on the root account.
        :param str user_event: Suspends or unsuspends all logins for this user that the calling user has permission to
        :param bool override_sis_stickiness: Default is true. If false, any fields containing “sticky” changes will not be updated. See SIS CSV Format documentation for information on which fields can have SIS stickiness
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_user_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_user_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def edit_user_with_http_info(self, id, **kwargs):  # noqa: E501
        """Edit a user  # noqa: E501

        Modify an existing user. To modify a user's login, see the documentation for logins.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_user_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str user_name: The full name of the user. This name will be used by teacher for grading.
        :param str user_short_name: User's name as it will be displayed in discussions, messages, and comments.
        :param str user_sortable_name: User's name as used to sort alphabetically in lists.
        :param str user_time_zone: The time zone for the user. Allowed time zones are {http://www.iana.org/time-zones IANA time zones} or friendlier {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
        :param str user_email: The default email address of the user.
        :param str user_locale: The user's preferred language, from the list of languages Canvas supports. This is in RFC-5646 format.
        :param str user_avatar_token: A unique representation of the avatar record to assign as the user's current avatar. This token can be obtained from the user avatars endpoint. This supersedes the user [avatar] [url] argument, and if both are included the url will be ignored. Note: this is an internal representation and is subject to change without notice. It should be consumed with this api endpoint and used in the user update endpoint, and should not be constructed by the client.
        :param str user_avatar_url: To set the user's avatar to point to an external url, do not include a token and instead pass the url here. Warning: For maximum compatibility, please use 128 px square images.
        :param str user_avatar_state: To set the state of user's avatar. Only valid for account administrator.
        :param str user_title: Sets a title on the user profile. (See {api:ProfileController#settings Get user profile}.) Profiles must be enabled on the root account.
        :param str user_bio: Sets a bio on the user profile. (See {api:ProfileController#settings Get user profile}.) Profiles must be enabled on the root account.
        :param str user_pronunciation: Sets name pronunciation on the user profile. (See {api:ProfileController#settings Get user profile}.) Profiles and name pronunciation must be enabled on the root account.
        :param str user_pronouns: Sets pronouns on the user profile. Passing an empty string will empty the user's pronouns Only Available Pronouns set on the root account are allowed Adding and changing pronouns must be enabled on the root account.
        :param str user_event: Suspends or unsuspends all logins for this user that the calling user has permission to
        :param bool override_sis_stickiness: Default is true. If false, any fields containing “sticky” changes will not be updated. See SIS CSV Format documentation for information on which fields can have SIS stickiness
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'user_name', 'user_short_name', 'user_sortable_name', 'user_time_zone', 'user_email', 'user_locale', 'user_avatar_token', 'user_avatar_url', 'user_avatar_state', 'user_title', 'user_bio', 'user_pronunciation', 'user_pronouns', 'user_event', 'override_sis_stickiness']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `edit_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'user_name' in params:
            form_params.append(('user[name]', params['user_name']))  # noqa: E501
        if 'user_short_name' in params:
            form_params.append(('user[short_name]', params['user_short_name']))  # noqa: E501
        if 'user_sortable_name' in params:
            form_params.append(('user[sortable_name]', params['user_sortable_name']))  # noqa: E501
        if 'user_time_zone' in params:
            form_params.append(('user[time_zone]', params['user_time_zone']))  # noqa: E501
        if 'user_email' in params:
            form_params.append(('user[email]', params['user_email']))  # noqa: E501
        if 'user_locale' in params:
            form_params.append(('user[locale]', params['user_locale']))  # noqa: E501
        if 'user_avatar_token' in params:
            form_params.append(('user[avatar][token]', params['user_avatar_token']))  # noqa: E501
        if 'user_avatar_url' in params:
            form_params.append(('user[avatar][url]', params['user_avatar_url']))  # noqa: E501
        if 'user_avatar_state' in params:
            form_params.append(('user[avatar][state]', params['user_avatar_state']))  # noqa: E501
        if 'user_title' in params:
            form_params.append(('user[title]', params['user_title']))  # noqa: E501
        if 'user_bio' in params:
            form_params.append(('user[bio]', params['user_bio']))  # noqa: E501
        if 'user_pronunciation' in params:
            form_params.append(('user[pronunciation]', params['user_pronunciation']))  # noqa: E501
        if 'user_pronouns' in params:
            form_params.append(('user[pronouns]', params['user_pronouns']))  # noqa: E501
        if 'user_event' in params:
            form_params.append(('user[event]', params['user_event']))  # noqa: E501
        if 'override_sis_stickiness' in params:
            form_params.append(('override_sis_stickiness', params['override_sis_stickiness']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_nickname(self, course_id, **kwargs):  # noqa: E501
        """Get course nickname  # noqa: E501

        Returns the nickname for a specific course.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_nickname(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: CourseNickname
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_nickname_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_nickname_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def get_course_nickname_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Get course nickname  # noqa: E501

        Returns the nickname for a specific course.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_nickname_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: CourseNickname
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_nickname" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_nickname`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/self/course_nicknames/{course_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CourseNickname',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_custom_color(self, id, asset_string, **kwargs):  # noqa: E501
        """Get custom color  # noqa: E501

        Returns the custom colors that have been saved for a user for a given context.  The asset_string parameter should be in the format 'context_id', for example 'course_42'.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_custom_color(id, asset_string, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str asset_string: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_custom_color_with_http_info(id, asset_string, **kwargs)  # noqa: E501
        else:
            (data) = self.get_custom_color_with_http_info(id, asset_string, **kwargs)  # noqa: E501
            return data

    def get_custom_color_with_http_info(self, id, asset_string, **kwargs):  # noqa: E501
        """Get custom color  # noqa: E501

        Returns the custom colors that have been saved for a user for a given context.  The asset_string parameter should be in the format 'context_id', for example 'course_42'.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_custom_color_with_http_info(id, asset_string, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str asset_string: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'asset_string']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_custom_color" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_custom_color`")  # noqa: E501
        # verify the required parameter 'asset_string' is set
        if self.api_client.client_side_validation and ('asset_string' not in params or
                                                       params['asset_string'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `asset_string` when calling `get_custom_color`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'asset_string' in params:
            path_params['asset_string'] = params['asset_string']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{id}/colors/{asset_string}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_custom_colors(self, id, **kwargs):  # noqa: E501
        """Get custom colors  # noqa: E501

        Returns all custom colors that have been saved for a user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_custom_colors(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_custom_colors_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_custom_colors_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_custom_colors_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get custom colors  # noqa: E501

        Returns all custom colors that have been saved for a user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_custom_colors_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_custom_colors" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_custom_colors`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{id}/colors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dashboard_positions(self, id, **kwargs):  # noqa: E501
        """Get dashboard positions  # noqa: E501

        Returns all dashboard positions that have been saved for a user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_positions(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dashboard_positions_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dashboard_positions_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_dashboard_positions_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get dashboard positions  # noqa: E501

        Returns all dashboard positions that have been saved for a user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_positions_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dashboard_positions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_dashboard_positions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{id}/dashboard_positions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pandata_events_jwt_token_and_its_expiration_date(self, **kwargs):  # noqa: E501
        """Get a Pandata Events jwt token and its expiration date  # noqa: E501

        Returns a jwt auth and props token that can be used to send events to Pandata.  NOTE: This is currently only available to the mobile developer keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pandata_events_jwt_token_and_its_expiration_date(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_key: The pandata events appKey for this mobile app
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pandata_events_jwt_token_and_its_expiration_date_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_pandata_events_jwt_token_and_its_expiration_date_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_pandata_events_jwt_token_and_its_expiration_date_with_http_info(self, **kwargs):  # noqa: E501
        """Get a Pandata Events jwt token and its expiration date  # noqa: E501

        Returns a jwt auth and props token that can be used to send events to Pandata.  NOTE: This is currently only available to the mobile developer keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pandata_events_jwt_token_and_its_expiration_date_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_key: The pandata events appKey for this mobile app
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pandata_events_jwt_token_and_its_expiration_date" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'app_key' in params:
            form_params.append(('app_key', params['app_key']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/self/pandata_events_token', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_profile(self, user_id, **kwargs):  # noqa: E501
        """Get user profile  # noqa: E501

        Returns user profile data, including user id, name, and profile pic.  When requesting the profile for the user accessing the API, the user's calendar feed URL and LTI user id will be returned as well.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_profile(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: Profile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_user_profile_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_user_profile_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def get_user_profile_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get user profile  # noqa: E501

        Returns user profile data, including user id, name, and profile pic.  When requesting the profile for the user accessing the API, the user's calendar feed URL and LTI user id will be returned as well.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_profile_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: Profile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `get_user_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/profile', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Profile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_users_most_recently_graded_submissions(self, id, **kwargs):  # noqa: E501
        """Get a users most recently graded submissions  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users_most_recently_graded_submissions(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param list[str] include: Associations to include with the group
        :param bool only_current_enrollments: Returns submissions for only currently active enrollments
        :param bool only_published_assignments: Returns submissions for only published assignments
        :return: list[Submission]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_users_most_recently_graded_submissions_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_users_most_recently_graded_submissions_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_users_most_recently_graded_submissions_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a users most recently graded submissions  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users_most_recently_graded_submissions_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param list[str] include: Associations to include with the group
        :param bool only_current_enrollments: Returns submissions for only currently active enrollments
        :param bool only_published_assignments: Returns submissions for only published assignments
        :return: list[Submission]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'include', 'only_current_enrollments', 'only_published_assignments']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_users_most_recently_graded_submissions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_users_most_recently_graded_submissions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'only_current_enrollments' in params:
            query_params.append(('only_current_enrollments', params['only_current_enrollments']))  # noqa: E501
        if 'only_published_assignments' in params:
            query_params.append(('only_published_assignments', params['only_published_assignments']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{id}/graded_submissions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Submission]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def hide_all_stream_items(self, **kwargs):  # noqa: E501
        """Hide all stream items  # noqa: E501

        Hide all stream items for the user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.hide_all_stream_items(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.hide_all_stream_items_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.hide_all_stream_items_with_http_info(**kwargs)  # noqa: E501
            return data

    def hide_all_stream_items_with_http_info(self, **kwargs):  # noqa: E501
        """Hide all stream items  # noqa: E501

        Hide all stream items for the user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.hide_all_stream_items_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hide_all_stream_items" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/self/activity_stream', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def hide_stream_item(self, id, **kwargs):  # noqa: E501
        """Hide a stream item  # noqa: E501

        Hide the given stream item.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.hide_stream_item(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.hide_stream_item_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.hide_stream_item_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def hide_stream_item_with_http_info(self, id, **kwargs):  # noqa: E501
        """Hide a stream item  # noqa: E501

        Hide the given stream item.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.hide_stream_item_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hide_stream_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `hide_stream_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/self/activity_stream/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_activity_stream_activity_stream(self, **kwargs):  # noqa: E501
        """List the activity stream  # noqa: E501

        Returns the current user's global activity stream, paginated.  There are many types of objects that can be returned in the activity stream. All object types have the same basic set of shared attributes:   !!!javascript   {     'created_at': '2011-07-13T09:12:00Z',     'updated_at': '2011-07-25T08:52:41Z',     'id': 1234,     'title': 'Stream Item Subject',     'message': 'This is the body text of the activity stream item. It is plain-text, and can be multiple paragraphs.',     'type': 'DiscussionTopic|Conversation|Message|Submission|Conference|Collaboration|AssessmentRequest...',     'read_state': false,     'context_type': 'course', // course|group     'course_id': 1,     'group_id': null,     'html_url': \"http://...\" // URL to the Canvas web UI for this stream item   }  In addition, each item type has its own set of attributes available.  DiscussionTopic:    !!!javascript   {     'type': 'DiscussionTopic',     'discussion_topic_id': 1234,     'total_root_discussion_entries': 5,     'require_initial_post': true,     'user_has_posted': true,     'root_discussion_entries': {       ...     }   }  For DiscussionTopic, the message is truncated at 4kb.  Announcement:    !!!javascript   {     'type': 'Announcement',     'announcement_id': 1234,     'total_root_discussion_entries': 5,     'require_initial_post': true,     'user_has_posted': null,     'root_discussion_entries': {       ...     }   }  For Announcement, the message is truncated at 4kb.  Conversation:    !!!javascript   {     'type': 'Conversation',     'conversation_id': 1234,     'private': false,     'participant_count': 3,   }  Message:    !!!javascript   {     'type': 'Message',     'message_id': 1234,     'notification_category': 'Assignment Graded'   }  Submission:  Returns an {api:Submissions:Submission Submission} with its Course and Assignment data.  Conference:    !!!javascript   {     'type': 'Conference',     'web_conference_id': 1234   }  Collaboration:    !!!javascript   {     'type': 'Collaboration',     'collaboration_id': 1234   }  AssessmentRequest:    !!!javascript   {     'type': 'AssessmentRequest',     'assessment_request_id': 1234   }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_activity_stream_activity_stream(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool only_active_courses: If true, will only return objects for courses the user is actively participating in
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_activity_stream_activity_stream_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_activity_stream_activity_stream_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_activity_stream_activity_stream_with_http_info(self, **kwargs):  # noqa: E501
        """List the activity stream  # noqa: E501

        Returns the current user's global activity stream, paginated.  There are many types of objects that can be returned in the activity stream. All object types have the same basic set of shared attributes:   !!!javascript   {     'created_at': '2011-07-13T09:12:00Z',     'updated_at': '2011-07-25T08:52:41Z',     'id': 1234,     'title': 'Stream Item Subject',     'message': 'This is the body text of the activity stream item. It is plain-text, and can be multiple paragraphs.',     'type': 'DiscussionTopic|Conversation|Message|Submission|Conference|Collaboration|AssessmentRequest...',     'read_state': false,     'context_type': 'course', // course|group     'course_id': 1,     'group_id': null,     'html_url': \"http://...\" // URL to the Canvas web UI for this stream item   }  In addition, each item type has its own set of attributes available.  DiscussionTopic:    !!!javascript   {     'type': 'DiscussionTopic',     'discussion_topic_id': 1234,     'total_root_discussion_entries': 5,     'require_initial_post': true,     'user_has_posted': true,     'root_discussion_entries': {       ...     }   }  For DiscussionTopic, the message is truncated at 4kb.  Announcement:    !!!javascript   {     'type': 'Announcement',     'announcement_id': 1234,     'total_root_discussion_entries': 5,     'require_initial_post': true,     'user_has_posted': null,     'root_discussion_entries': {       ...     }   }  For Announcement, the message is truncated at 4kb.  Conversation:    !!!javascript   {     'type': 'Conversation',     'conversation_id': 1234,     'private': false,     'participant_count': 3,   }  Message:    !!!javascript   {     'type': 'Message',     'message_id': 1234,     'notification_category': 'Assignment Graded'   }  Submission:  Returns an {api:Submissions:Submission Submission} with its Course and Assignment data.  Conference:    !!!javascript   {     'type': 'Conference',     'web_conference_id': 1234   }  Collaboration:    !!!javascript   {     'type': 'Collaboration',     'collaboration_id': 1234   }  AssessmentRequest:    !!!javascript   {     'type': 'AssessmentRequest',     'assessment_request_id': 1234   }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_activity_stream_activity_stream_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool only_active_courses: If true, will only return objects for courses the user is actively participating in
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['only_active_courses']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_activity_stream_activity_stream" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'only_active_courses' in params:
            query_params.append(('only_active_courses', params['only_active_courses']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/activity_stream', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_activity_stream_self(self, **kwargs):  # noqa: E501
        """List the activity stream  # noqa: E501

        Returns the current user's global activity stream, paginated.  There are many types of objects that can be returned in the activity stream. All object types have the same basic set of shared attributes:   !!!javascript   {     'created_at': '2011-07-13T09:12:00Z',     'updated_at': '2011-07-25T08:52:41Z',     'id': 1234,     'title': 'Stream Item Subject',     'message': 'This is the body text of the activity stream item. It is plain-text, and can be multiple paragraphs.',     'type': 'DiscussionTopic|Conversation|Message|Submission|Conference|Collaboration|AssessmentRequest...',     'read_state': false,     'context_type': 'course', // course|group     'course_id': 1,     'group_id': null,     'html_url': \"http://...\" // URL to the Canvas web UI for this stream item   }  In addition, each item type has its own set of attributes available.  DiscussionTopic:    !!!javascript   {     'type': 'DiscussionTopic',     'discussion_topic_id': 1234,     'total_root_discussion_entries': 5,     'require_initial_post': true,     'user_has_posted': true,     'root_discussion_entries': {       ...     }   }  For DiscussionTopic, the message is truncated at 4kb.  Announcement:    !!!javascript   {     'type': 'Announcement',     'announcement_id': 1234,     'total_root_discussion_entries': 5,     'require_initial_post': true,     'user_has_posted': null,     'root_discussion_entries': {       ...     }   }  For Announcement, the message is truncated at 4kb.  Conversation:    !!!javascript   {     'type': 'Conversation',     'conversation_id': 1234,     'private': false,     'participant_count': 3,   }  Message:    !!!javascript   {     'type': 'Message',     'message_id': 1234,     'notification_category': 'Assignment Graded'   }  Submission:  Returns an {api:Submissions:Submission Submission} with its Course and Assignment data.  Conference:    !!!javascript   {     'type': 'Conference',     'web_conference_id': 1234   }  Collaboration:    !!!javascript   {     'type': 'Collaboration',     'collaboration_id': 1234   }  AssessmentRequest:    !!!javascript   {     'type': 'AssessmentRequest',     'assessment_request_id': 1234   }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_activity_stream_self(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool only_active_courses: If true, will only return objects for courses the user is actively participating in
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_activity_stream_self_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_activity_stream_self_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_activity_stream_self_with_http_info(self, **kwargs):  # noqa: E501
        """List the activity stream  # noqa: E501

        Returns the current user's global activity stream, paginated.  There are many types of objects that can be returned in the activity stream. All object types have the same basic set of shared attributes:   !!!javascript   {     'created_at': '2011-07-13T09:12:00Z',     'updated_at': '2011-07-25T08:52:41Z',     'id': 1234,     'title': 'Stream Item Subject',     'message': 'This is the body text of the activity stream item. It is plain-text, and can be multiple paragraphs.',     'type': 'DiscussionTopic|Conversation|Message|Submission|Conference|Collaboration|AssessmentRequest...',     'read_state': false,     'context_type': 'course', // course|group     'course_id': 1,     'group_id': null,     'html_url': \"http://...\" // URL to the Canvas web UI for this stream item   }  In addition, each item type has its own set of attributes available.  DiscussionTopic:    !!!javascript   {     'type': 'DiscussionTopic',     'discussion_topic_id': 1234,     'total_root_discussion_entries': 5,     'require_initial_post': true,     'user_has_posted': true,     'root_discussion_entries': {       ...     }   }  For DiscussionTopic, the message is truncated at 4kb.  Announcement:    !!!javascript   {     'type': 'Announcement',     'announcement_id': 1234,     'total_root_discussion_entries': 5,     'require_initial_post': true,     'user_has_posted': null,     'root_discussion_entries': {       ...     }   }  For Announcement, the message is truncated at 4kb.  Conversation:    !!!javascript   {     'type': 'Conversation',     'conversation_id': 1234,     'private': false,     'participant_count': 3,   }  Message:    !!!javascript   {     'type': 'Message',     'message_id': 1234,     'notification_category': 'Assignment Graded'   }  Submission:  Returns an {api:Submissions:Submission Submission} with its Course and Assignment data.  Conference:    !!!javascript   {     'type': 'Conference',     'web_conference_id': 1234   }  Collaboration:    !!!javascript   {     'type': 'Collaboration',     'collaboration_id': 1234   }  AssessmentRequest:    !!!javascript   {     'type': 'AssessmentRequest',     'assessment_request_id': 1234   }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_activity_stream_self_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool only_active_courses: If true, will only return objects for courses the user is actively participating in
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['only_active_courses']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_activity_stream_self" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'only_active_courses' in params:
            query_params.append(('only_active_courses', params['only_active_courses']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/self/activity_stream', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_avatar_options(self, user_id, **kwargs):  # noqa: E501
        """List avatar options  # noqa: E501

        A paginated list of the possible user avatar options that can be set with the user update endpoint. The response will be an array of avatar records. If the 'type' field is 'attachment', the record will include all the normal attachment json fields; otherwise it will include only the 'url' and 'display_name' fields. Additionally, all records will include a 'type' field and a 'token' field. The following explains each field in more detail type:: [\"gravatar\"|\"attachment\"|\"no_pic\"] The type of avatar record, for categorization purposes. url:: The url of the avatar token:: A unique representation of the avatar record which can be used to set the avatar with the user update endpoint. Note: this is an internal representation and is subject to change without notice. It should be consumed with this api endpoint and used in the user update endpoint, and should not be constructed by the client. display_name:: A textual description of the avatar record id:: ['attachment' type only] the internal id of the attachment content-type:: ['attachment' type only] the content-type of the attachment filename:: ['attachment' type only] the filename of the attachment size:: ['attachment' type only] the size of the attachment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_avatar_options(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: list[Avatar]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_avatar_options_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_avatar_options_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def list_avatar_options_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List avatar options  # noqa: E501

        A paginated list of the possible user avatar options that can be set with the user update endpoint. The response will be an array of avatar records. If the 'type' field is 'attachment', the record will include all the normal attachment json fields; otherwise it will include only the 'url' and 'display_name' fields. Additionally, all records will include a 'type' field and a 'token' field. The following explains each field in more detail type:: [\"gravatar\"|\"attachment\"|\"no_pic\"] The type of avatar record, for categorization purposes. url:: The url of the avatar token:: A unique representation of the avatar record which can be used to set the avatar with the user update endpoint. Note: this is an internal representation and is subject to change without notice. It should be consumed with this api endpoint and used in the user update endpoint, and should not be constructed by the client. display_name:: A textual description of the avatar record id:: ['attachment' type only] the internal id of the attachment content-type:: ['attachment' type only] the content-type of the attachment filename:: ['attachment' type only] the filename of the attachment size:: ['attachment' type only] the size of the attachment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_avatar_options_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: list[Avatar]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_avatar_options" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `list_avatar_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/avatars', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Avatar]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_counts_for_todo_items(self, **kwargs):  # noqa: E501
        """List counts for todo items  # noqa: E501

        Counts of different todo items such as the number of assignments needing grading as well as the number of assignments needing submitting.  There is a limit to the number of todo items this endpoint will count. It will only look at the first 100 todo items for the user. If the user has more than 100 todo items this count may not be reliable. The largest reliable number for both counts is 100.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_counts_for_todo_items(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] include: \"ungraded_quizzes\":: Optionally include ungraded quizzes (such as practice quizzes and surveys) in the list.                      These will be returned under a +quiz+ key instead of an +assignment+ key in response elements.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_counts_for_todo_items_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_counts_for_todo_items_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_counts_for_todo_items_with_http_info(self, **kwargs):  # noqa: E501
        """List counts for todo items  # noqa: E501

        Counts of different todo items such as the number of assignments needing grading as well as the number of assignments needing submitting.  There is a limit to the number of todo items this endpoint will count. It will only look at the first 100 todo items for the user. If the user has more than 100 todo items this count may not be reliable. The largest reliable number for both counts is 100.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_counts_for_todo_items_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] include: \"ungraded_quizzes\":: Optionally include ungraded quizzes (such as practice quizzes and surveys) in the list.                      These will be returned under a +quiz+ key instead of an +assignment+ key in response elements.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_counts_for_todo_items" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/self/todo_item_count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_course_nicknames(self, **kwargs):  # noqa: E501
        """List course nicknames  # noqa: E501

        Returns all course nicknames you have set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_course_nicknames(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[CourseNickname]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_course_nicknames_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_course_nicknames_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_course_nicknames_with_http_info(self, **kwargs):  # noqa: E501
        """List course nicknames  # noqa: E501

        Returns all course nicknames you have set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_course_nicknames_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[CourseNickname]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_course_nicknames" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/self/course_nicknames', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CourseNickname]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_missing_submissions(self, user_id, **kwargs):  # noqa: E501
        """List Missing Submissions  # noqa: E501

        A paginated list of past-due assignments for which the student does not have a submission. The user sending the request must either be the student, an admin or a parent observer using the parent app  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_missing_submissions(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: the student's ID (required)
        :param str observed_user_id: Return missing submissions for the given observed user. Must be accompanied by course_ids[]. The user making the request must be observing the observed user in all the courses specified by course_ids[].
        :param list[str] include: \"planner_overrides\":: Optionally include the assignment's associated planner override, if it exists, for the current user.                       These will be returned under a +planner_override+ key \"course\":: Optionally include the assignments' courses
        :param list[str] filter: \"submittable\":: Only return assignments that the current user can submit (i.e. filter out locked assignments) \"current_grading_period\":: Only return missing assignments that are in the current grading period
        :param list[str] course_ids: Optionally restricts the list of past-due assignments to only those associated with the specified course IDs. Required if observed_user_id is passed.
        :return: list[Assignment]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_missing_submissions_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_missing_submissions_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def list_missing_submissions_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List Missing Submissions  # noqa: E501

        A paginated list of past-due assignments for which the student does not have a submission. The user sending the request must either be the student, an admin or a parent observer using the parent app  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_missing_submissions_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: the student's ID (required)
        :param str observed_user_id: Return missing submissions for the given observed user. Must be accompanied by course_ids[]. The user making the request must be observing the observed user in all the courses specified by course_ids[].
        :param list[str] include: \"planner_overrides\":: Optionally include the assignment's associated planner override, if it exists, for the current user.                       These will be returned under a +planner_override+ key \"course\":: Optionally include the assignments' courses
        :param list[str] filter: \"submittable\":: Only return assignments that the current user can submit (i.e. filter out locked assignments) \"current_grading_period\":: Only return missing assignments that are in the current grading period
        :param list[str] course_ids: Optionally restricts the list of past-due assignments to only those associated with the specified course IDs. Required if observed_user_id is passed.
        :return: list[Assignment]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'observed_user_id', 'include', 'filter', 'course_ids']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_missing_submissions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `list_missing_submissions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'observed_user_id' in params:
            query_params.append(('observed_user_id', params['observed_user_id']))  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
            collection_formats['filter'] = 'csv'  # noqa: E501
        if 'course_ids' in params:
            query_params.append(('course_ids', params['course_ids']))  # noqa: E501
            collection_formats['course_ids'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/missing_submissions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Assignment]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_todo_items(self, **kwargs):  # noqa: E501
        """List the TODO items  # noqa: E501

        A paginated list of the current user's list of todo items.  There is a limit to the number of items returned.  The `ignore` and `ignore_permanently` URLs can be used to update the user's preferences on what items will be displayed. Performing a DELETE request against the `ignore` URL will hide that item from future todo item requests, until the item changes. Performing a DELETE request against the `ignore_permanently` URL will hide that item forever.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_todo_items(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] include: \"ungraded_quizzes\":: Optionally include ungraded quizzes (such as practice quizzes and surveys) in the list.                      These will be returned under a +quiz+ key instead of an +assignment+ key in response elements.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_todo_items_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_todo_items_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_todo_items_with_http_info(self, **kwargs):  # noqa: E501
        """List the TODO items  # noqa: E501

        A paginated list of the current user's list of todo items.  There is a limit to the number of items returned.  The `ignore` and `ignore_permanently` URLs can be used to update the user's preferences on what items will be displayed. Performing a DELETE request against the `ignore` URL will hide that item from future todo item requests, until the item changes. Performing a DELETE request against the `ignore_permanently` URL will hide that item forever.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_todo_items_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] include: \"ungraded_quizzes\":: Optionally include ungraded quizzes (such as practice quizzes and surveys) in the list.                      These will be returned under a +quiz+ key instead of an +assignment+ key in response elements.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_todo_items" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/self/todo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_upcoming_assignments_calendar_events(self, **kwargs):  # noqa: E501
        """List upcoming assignments, calendar events  # noqa: E501

        A paginated list of the current user's upcoming events.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_upcoming_assignments_calendar_events(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_upcoming_assignments_calendar_events_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_upcoming_assignments_calendar_events_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_upcoming_assignments_calendar_events_with_http_info(self, **kwargs):  # noqa: E501
        """List upcoming assignments, calendar events  # noqa: E501

        A paginated list of the current user's upcoming events.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_upcoming_assignments_calendar_events_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_upcoming_assignments_calendar_events" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/self/upcoming_events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_user_page_views(self, user_id, **kwargs):  # noqa: E501
        """List user page views  # noqa: E501

        Return a paginated list of the user's page view history in json format, similar to the available CSV download. Page views are returned in descending order, newest to oldest.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_user_page_views(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param Object start_time: The beginning of the time range from which you want page views.
        :param Object end_time: The end of the time range from which you want page views.
        :return: list[PageView]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_user_page_views_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_user_page_views_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def list_user_page_views_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List user page views  # noqa: E501

        Return a paginated list of the user's page view history in json format, similar to the available CSV download. Page views are returned in descending order, newest to oldest.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_user_page_views_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param Object start_time: The beginning of the time range from which you want page views.
        :param Object end_time: The end of the time range from which you want page views.
        :return: list[PageView]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'start_time', 'end_time']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_user_page_views" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `list_user_page_views`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/page_views', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PageView]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_users_in_account(self, account_id, **kwargs):  # noqa: E501
        """List users in account  # noqa: E501

        A paginated list of users associated with this account.   @example_request    curl https://<canvas>/api/v1/accounts/self/users?search_term=<search value> \\       -X GET \\       -H 'Authorization: Bearer <token>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_users_in_account(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str search_term: The partial name or full ID of the users to match and return in the results list. Must be at least 3 characters.  Note that the API will prefer matching on canonical user ID if the ID has a numeric form. It will only search against other fields if non-numeric in form, or if the numeric value doesn't yield any matches. Queries by administrative users will search on SIS ID, Integration ID, login ID, name, or email address
        :param str enrollment_type: When set, only return users enrolled with the specified course-level base role. This can be a base role type of 'student', 'teacher', 'ta', 'observer', or 'designer'.
        :param str sort: The column to sort results by.
        :param str order: The order to sort the given column by.
        :param bool include_deleted_users: When set to true and used with an account context, returns users who have deleted pseudonyms for the context
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_users_in_account_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_users_in_account_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def list_users_in_account_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """List users in account  # noqa: E501

        A paginated list of users associated with this account.   @example_request    curl https://<canvas>/api/v1/accounts/self/users?search_term=<search value> \\       -X GET \\       -H 'Authorization: Bearer <token>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_users_in_account_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: ID (required)
        :param str search_term: The partial name or full ID of the users to match and return in the results list. Must be at least 3 characters.  Note that the API will prefer matching on canonical user ID if the ID has a numeric form. It will only search against other fields if non-numeric in form, or if the numeric value doesn't yield any matches. Queries by administrative users will search on SIS ID, Integration ID, login ID, name, or email address
        :param str enrollment_type: When set, only return users enrolled with the specified course-level base role. This can be a base role type of 'student', 'teacher', 'ta', 'observer', or 'designer'.
        :param str sort: The column to sort results by.
        :param str order: The order to sort the given column by.
        :param bool include_deleted_users: When set to true and used with an account context, returns users who have deleted pseudonyms for the context
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'search_term', 'enrollment_type', 'sort', 'order', 'include_deleted_users']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_users_in_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in params or
                                                       params['account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_id` when calling `list_users_in_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'search_term' in params:
            query_params.append(('search_term', params['search_term']))  # noqa: E501
        if 'enrollment_type' in params:
            query_params.append(('enrollment_type', params['enrollment_type']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'order' in params:
            query_params.append(('order', params['order']))  # noqa: E501
        if 'include_deleted_users' in params:
            query_params.append(('include_deleted_users', params['include_deleted_users']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{account_id}/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[User]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def load_custom_data(self, user_id, ns, **kwargs):  # noqa: E501
        """Load custom data  # noqa: E501

        Load custom user data.  Arbitrary JSON data can be stored for a User.  This API call retrieves that data for a (optional) given scope. See {api:UsersController#set_custom_data Store Custom Data} for details and examples.  On success, this endpoint returns an object containing the data that was requested.  Responds with status code 400 if the namespace parameter, +ns+, is missing or invalid, or if the specified scope does not contain any data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.load_custom_data(user_id, ns, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str ns: The namespace from which to retrieve the data.  This should be something other Canvas API apps aren't likely to use, such as a reverse DNS for your organization. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.load_custom_data_with_http_info(user_id, ns, **kwargs)  # noqa: E501
        else:
            (data) = self.load_custom_data_with_http_info(user_id, ns, **kwargs)  # noqa: E501
            return data

    def load_custom_data_with_http_info(self, user_id, ns, **kwargs):  # noqa: E501
        """Load custom data  # noqa: E501

        Load custom user data.  Arbitrary JSON data can be stored for a User.  This API call retrieves that data for a (optional) given scope. See {api:UsersController#set_custom_data Store Custom Data} for details and examples.  On success, this endpoint returns an object containing the data that was requested.  Responds with status code 400 if the namespace parameter, +ns+, is missing or invalid, or if the specified scope does not contain any data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.load_custom_data_with_http_info(user_id, ns, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str ns: The namespace from which to retrieve the data.  This should be something other Canvas API apps aren't likely to use, such as a reverse DNS for your organization. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'ns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method load_custom_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `load_custom_data`")  # noqa: E501
        # verify the required parameter 'ns' is set
        if self.api_client.client_side_validation and ('ns' not in params or
                                                       params['ns'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ns` when calling `load_custom_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'ns' in params:
            query_params.append(('ns', params['ns']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/custom_data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def log_users_out_of_all_mobile_apps_id(self, id, **kwargs):  # noqa: E501
        """Log users out of all mobile apps  # noqa: E501

        Permanently expires any active mobile sessions, forcing them to re-authorize.  The route that takes a user id will expire mobile sessions for that user. The route that doesn't take a user id will expire mobile sessions for *all* users in the institution.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.log_users_out_of_all_mobile_apps_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.log_users_out_of_all_mobile_apps_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.log_users_out_of_all_mobile_apps_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def log_users_out_of_all_mobile_apps_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Log users out of all mobile apps  # noqa: E501

        Permanently expires any active mobile sessions, forcing them to re-authorize.  The route that takes a user id will expire mobile sessions for that user. The route that doesn't take a user id will expire mobile sessions for *all* users in the institution.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.log_users_out_of_all_mobile_apps_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method log_users_out_of_all_mobile_apps_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `log_users_out_of_all_mobile_apps_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{id}/mobile_sessions', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def log_users_out_of_all_mobile_apps_mobile_sessions(self, **kwargs):  # noqa: E501
        """Log users out of all mobile apps  # noqa: E501

        Permanently expires any active mobile sessions, forcing them to re-authorize.  The route that takes a user id will expire mobile sessions for that user. The route that doesn't take a user id will expire mobile sessions for *all* users in the institution.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.log_users_out_of_all_mobile_apps_mobile_sessions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.log_users_out_of_all_mobile_apps_mobile_sessions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.log_users_out_of_all_mobile_apps_mobile_sessions_with_http_info(**kwargs)  # noqa: E501
            return data

    def log_users_out_of_all_mobile_apps_mobile_sessions_with_http_info(self, **kwargs):  # noqa: E501
        """Log users out of all mobile apps  # noqa: E501

        Permanently expires any active mobile sessions, forcing them to re-authorize.  The route that takes a user id will expire mobile sessions for that user. The route that doesn't take a user id will expire mobile sessions for *all* users in the institution.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.log_users_out_of_all_mobile_apps_mobile_sessions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method log_users_out_of_all_mobile_apps_mobile_sessions" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/mobile_sessions', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def merge_user_into_another_user_accounts(self, id, destination_account_id, destination_user_id, **kwargs):  # noqa: E501
        """Merge user into another user  # noqa: E501

        Merge a user into another user. To merge users, the caller must have permissions to manage both users. This should be considered irreversible. This will delete the user and move all the data into the destination user.  User merge details and caveats: The from_user is the user that was deleted in the user_merge process. The destination_user is the user that remains, that is being split.  Avatars: When both users have avatars, only the destination_users avatar will remain. When one user has an avatar, will it will end up on the destination_user.  Terms of Use: If either user has accepted terms of use, it will be be left as accepted.  Communication Channels: All unique communication channels moved to the destination_user. All notification preferences are moved to the destination_user.  Enrollments: All unique enrollments are moved to the destination_user. When there is an enrollment that would end up making it so that a user would be observing themselves, the enrollment is not moved over. Everything that is tied to the from_user at the course level relating to the enrollment is also moved to the destination_user.  Submissions: All submissions are moved to the destination_user. If there are enrollments for both users in the same course, we prefer submissions that have grades then submissions that have work in them, and if there are no grades or no work, they are not moved.  Other notes: Access Tokens are moved on merge. Conversations are moved on merge. Favorites are moved on merge. Courses will commonly use LTI tools. LTI tools reference the user with IDs that are stored on a user object. Merging users deletes one user and moves all records from the deleted user to the destination_user. These IDs are kept for all enrollments, group_membership, and account_users for the from_user at the time of the merge. When the destination_user launches an LTI tool from a course that used to be the from_user's, it doesn't appear as a new user to the tool provider. Instead it will send the stored ids. The destination_user's LTI IDs remain as they were for the courses that they originally had. Future enrollments for the destination_user will use the IDs that are on the destination_user object. LTI IDs that are kept and tracked per context include lti_context_id, lti_id and uuid. APIs that return the LTI ids will return the one for the context that it is called for, except for the user uuid. The user UUID will display the destination_users uuid, and when getting the uuid from an api that is in a context that was recorded from a merge event, an additional attribute is added as past_uuid.  When finding users by SIS ids in different accounts the destination_account_id is required.  The account can also be identified by passing the domain in destination_account_id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.merge_user_into_another_user_accounts(id, destination_account_id, destination_user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str destination_account_id: ID (required)
        :param str destination_user_id: ID (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.merge_user_into_another_user_accounts_with_http_info(id, destination_account_id, destination_user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.merge_user_into_another_user_accounts_with_http_info(id, destination_account_id, destination_user_id, **kwargs)  # noqa: E501
            return data

    def merge_user_into_another_user_accounts_with_http_info(self, id, destination_account_id, destination_user_id, **kwargs):  # noqa: E501
        """Merge user into another user  # noqa: E501

        Merge a user into another user. To merge users, the caller must have permissions to manage both users. This should be considered irreversible. This will delete the user and move all the data into the destination user.  User merge details and caveats: The from_user is the user that was deleted in the user_merge process. The destination_user is the user that remains, that is being split.  Avatars: When both users have avatars, only the destination_users avatar will remain. When one user has an avatar, will it will end up on the destination_user.  Terms of Use: If either user has accepted terms of use, it will be be left as accepted.  Communication Channels: All unique communication channels moved to the destination_user. All notification preferences are moved to the destination_user.  Enrollments: All unique enrollments are moved to the destination_user. When there is an enrollment that would end up making it so that a user would be observing themselves, the enrollment is not moved over. Everything that is tied to the from_user at the course level relating to the enrollment is also moved to the destination_user.  Submissions: All submissions are moved to the destination_user. If there are enrollments for both users in the same course, we prefer submissions that have grades then submissions that have work in them, and if there are no grades or no work, they are not moved.  Other notes: Access Tokens are moved on merge. Conversations are moved on merge. Favorites are moved on merge. Courses will commonly use LTI tools. LTI tools reference the user with IDs that are stored on a user object. Merging users deletes one user and moves all records from the deleted user to the destination_user. These IDs are kept for all enrollments, group_membership, and account_users for the from_user at the time of the merge. When the destination_user launches an LTI tool from a course that used to be the from_user's, it doesn't appear as a new user to the tool provider. Instead it will send the stored ids. The destination_user's LTI IDs remain as they were for the courses that they originally had. Future enrollments for the destination_user will use the IDs that are on the destination_user object. LTI IDs that are kept and tracked per context include lti_context_id, lti_id and uuid. APIs that return the LTI ids will return the one for the context that it is called for, except for the user uuid. The user UUID will display the destination_users uuid, and when getting the uuid from an api that is in a context that was recorded from a merge event, an additional attribute is added as past_uuid.  When finding users by SIS ids in different accounts the destination_account_id is required.  The account can also be identified by passing the domain in destination_account_id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.merge_user_into_another_user_accounts_with_http_info(id, destination_account_id, destination_user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str destination_account_id: ID (required)
        :param str destination_user_id: ID (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'destination_account_id', 'destination_user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method merge_user_into_another_user_accounts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `merge_user_into_another_user_accounts`")  # noqa: E501
        # verify the required parameter 'destination_account_id' is set
        if self.api_client.client_side_validation and ('destination_account_id' not in params or
                                                       params['destination_account_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `destination_account_id` when calling `merge_user_into_another_user_accounts`")  # noqa: E501
        # verify the required parameter 'destination_user_id' is set
        if self.api_client.client_side_validation and ('destination_user_id' not in params or
                                                       params['destination_user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `destination_user_id` when calling `merge_user_into_another_user_accounts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'destination_account_id' in params:
            path_params['destination_account_id'] = params['destination_account_id']  # noqa: E501
        if 'destination_user_id' in params:
            path_params['destination_user_id'] = params['destination_user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{id}/merge_into/accounts/{destination_account_id}/users/{destination_user_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def merge_user_into_another_user_destination_user_id(self, id, destination_user_id, **kwargs):  # noqa: E501
        """Merge user into another user  # noqa: E501

        Merge a user into another user. To merge users, the caller must have permissions to manage both users. This should be considered irreversible. This will delete the user and move all the data into the destination user.  User merge details and caveats: The from_user is the user that was deleted in the user_merge process. The destination_user is the user that remains, that is being split.  Avatars: When both users have avatars, only the destination_users avatar will remain. When one user has an avatar, will it will end up on the destination_user.  Terms of Use: If either user has accepted terms of use, it will be be left as accepted.  Communication Channels: All unique communication channels moved to the destination_user. All notification preferences are moved to the destination_user.  Enrollments: All unique enrollments are moved to the destination_user. When there is an enrollment that would end up making it so that a user would be observing themselves, the enrollment is not moved over. Everything that is tied to the from_user at the course level relating to the enrollment is also moved to the destination_user.  Submissions: All submissions are moved to the destination_user. If there are enrollments for both users in the same course, we prefer submissions that have grades then submissions that have work in them, and if there are no grades or no work, they are not moved.  Other notes: Access Tokens are moved on merge. Conversations are moved on merge. Favorites are moved on merge. Courses will commonly use LTI tools. LTI tools reference the user with IDs that are stored on a user object. Merging users deletes one user and moves all records from the deleted user to the destination_user. These IDs are kept for all enrollments, group_membership, and account_users for the from_user at the time of the merge. When the destination_user launches an LTI tool from a course that used to be the from_user's, it doesn't appear as a new user to the tool provider. Instead it will send the stored ids. The destination_user's LTI IDs remain as they were for the courses that they originally had. Future enrollments for the destination_user will use the IDs that are on the destination_user object. LTI IDs that are kept and tracked per context include lti_context_id, lti_id and uuid. APIs that return the LTI ids will return the one for the context that it is called for, except for the user uuid. The user UUID will display the destination_users uuid, and when getting the uuid from an api that is in a context that was recorded from a merge event, an additional attribute is added as past_uuid.  When finding users by SIS ids in different accounts the destination_account_id is required.  The account can also be identified by passing the domain in destination_account_id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.merge_user_into_another_user_destination_user_id(id, destination_user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str destination_user_id: ID (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.merge_user_into_another_user_destination_user_id_with_http_info(id, destination_user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.merge_user_into_another_user_destination_user_id_with_http_info(id, destination_user_id, **kwargs)  # noqa: E501
            return data

    def merge_user_into_another_user_destination_user_id_with_http_info(self, id, destination_user_id, **kwargs):  # noqa: E501
        """Merge user into another user  # noqa: E501

        Merge a user into another user. To merge users, the caller must have permissions to manage both users. This should be considered irreversible. This will delete the user and move all the data into the destination user.  User merge details and caveats: The from_user is the user that was deleted in the user_merge process. The destination_user is the user that remains, that is being split.  Avatars: When both users have avatars, only the destination_users avatar will remain. When one user has an avatar, will it will end up on the destination_user.  Terms of Use: If either user has accepted terms of use, it will be be left as accepted.  Communication Channels: All unique communication channels moved to the destination_user. All notification preferences are moved to the destination_user.  Enrollments: All unique enrollments are moved to the destination_user. When there is an enrollment that would end up making it so that a user would be observing themselves, the enrollment is not moved over. Everything that is tied to the from_user at the course level relating to the enrollment is also moved to the destination_user.  Submissions: All submissions are moved to the destination_user. If there are enrollments for both users in the same course, we prefer submissions that have grades then submissions that have work in them, and if there are no grades or no work, they are not moved.  Other notes: Access Tokens are moved on merge. Conversations are moved on merge. Favorites are moved on merge. Courses will commonly use LTI tools. LTI tools reference the user with IDs that are stored on a user object. Merging users deletes one user and moves all records from the deleted user to the destination_user. These IDs are kept for all enrollments, group_membership, and account_users for the from_user at the time of the merge. When the destination_user launches an LTI tool from a course that used to be the from_user's, it doesn't appear as a new user to the tool provider. Instead it will send the stored ids. The destination_user's LTI IDs remain as they were for the courses that they originally had. Future enrollments for the destination_user will use the IDs that are on the destination_user object. LTI IDs that are kept and tracked per context include lti_context_id, lti_id and uuid. APIs that return the LTI ids will return the one for the context that it is called for, except for the user uuid. The user UUID will display the destination_users uuid, and when getting the uuid from an api that is in a context that was recorded from a merge event, an additional attribute is added as past_uuid.  When finding users by SIS ids in different accounts the destination_account_id is required.  The account can also be identified by passing the domain in destination_account_id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.merge_user_into_another_user_destination_user_id_with_http_info(id, destination_user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str destination_user_id: ID (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'destination_user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method merge_user_into_another_user_destination_user_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `merge_user_into_another_user_destination_user_id`")  # noqa: E501
        # verify the required parameter 'destination_user_id' is set
        if self.api_client.client_side_validation and ('destination_user_id' not in params or
                                                       params['destination_user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `destination_user_id` when calling `merge_user_into_another_user_destination_user_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'destination_user_id' in params:
            path_params['destination_user_id'] = params['destination_user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{id}/merge_into/{destination_user_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_course_nickname(self, course_id, **kwargs):  # noqa: E501
        """Remove course nickname  # noqa: E501

        Remove the nickname for the given course. Subsequent course API calls will return the actual name for the course.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_course_nickname(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: CourseNickname
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_course_nickname_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_course_nickname_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def remove_course_nickname_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Remove course nickname  # noqa: E501

        Remove the nickname for the given course. Subsequent course API calls will return the actual name for the course.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_course_nickname_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :return: CourseNickname
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_course_nickname" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `remove_course_nickname`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/self/course_nicknames/{course_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CourseNickname',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_course_nickname(self, course_id, nickname, **kwargs):  # noqa: E501
        """Set course nickname  # noqa: E501

        Set a nickname for the given course. This will replace the course's name in output of API calls you make subsequently, as well as in selected places in the Canvas web user interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_nickname(course_id, nickname, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str nickname: The nickname to set.  It must be non-empty and shorter than 60 characters. (required)
        :return: CourseNickname
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_course_nickname_with_http_info(course_id, nickname, **kwargs)  # noqa: E501
        else:
            (data) = self.set_course_nickname_with_http_info(course_id, nickname, **kwargs)  # noqa: E501
            return data

    def set_course_nickname_with_http_info(self, course_id, nickname, **kwargs):  # noqa: E501
        """Set course nickname  # noqa: E501

        Set a nickname for the given course. This will replace the course's name in output of API calls you make subsequently, as well as in selected places in the Canvas web user interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_nickname_with_http_info(course_id, nickname, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: ID (required)
        :param str nickname: The nickname to set.  It must be non-empty and shorter than 60 characters. (required)
        :return: CourseNickname
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'nickname']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_course_nickname" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if self.api_client.client_side_validation and ('course_id' not in params or
                                                       params['course_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `course_id` when calling `set_course_nickname`")  # noqa: E501
        # verify the required parameter 'nickname' is set
        if self.api_client.client_side_validation and ('nickname' not in params or
                                                       params['nickname'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `nickname` when calling `set_course_nickname`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['course_id'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'nickname' in params:
            form_params.append(('nickname', params['nickname']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/self/course_nicknames/{course_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CourseNickname',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_user_details(self, id, **kwargs):  # noqa: E501
        """Show user details  # noqa: E501

        Shows details for user.  Also includes an attribute \"permissions\", a non-comprehensive list of permissions for the user. Example:   !!!javascript   \"permissions\": {    \"can_update_name\": true, // Whether the user can update their name.    \"can_update_avatar\": false, // Whether the user can update their avatar.    \"limit_parent_app_web_access\": false // Whether the user can interact with Canvas web from the Canvas Parent app.   }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_user_details(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param list[str] include: Array of additional information to include on the user record. \"locale\", \"avatar_url\", \"permissions\", \"email\", and \"effective_locale\" will always be returned
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_user_details_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.show_user_details_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def show_user_details_with_http_info(self, id, **kwargs):  # noqa: E501
        """Show user details  # noqa: E501

        Shows details for user.  Also includes an attribute \"permissions\", a non-comprehensive list of permissions for the user. Example:   !!!javascript   \"permissions\": {    \"can_update_name\": true, // Whether the user can update their name.    \"can_update_avatar\": false, // Whether the user can update their avatar.    \"limit_parent_app_web_access\": false // Whether the user can interact with Canvas web from the Canvas Parent app.   }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_user_details_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param list[str] include: Array of additional information to include on the user record. \"locale\", \"avatar_url\", \"permissions\", \"email\", and \"effective_locale\" will always be returned
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_user_details" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `show_user_details`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def split_merged_users_into_separate_users(self, id, **kwargs):  # noqa: E501
        """Split merged users into separate users  # noqa: E501

        Merged users cannot be fully restored to their previous state, but this will attempt to split as much as possible to the previous state. To split a merged user, the caller must have permissions to manage all of the users logins. If there are multiple users that have been merged into one user it will split each merge into a separate user. A split can only happen within 180 days of a user merge. A user merge deletes the previous user and may be permanently deleted. In this scenario we create a new user object and proceed to move as much as possible to the new user. The user object will not have preserved the name or settings from the previous user. Some items may have been deleted during a user_merge that cannot be restored, and/or the data has become stale because of other changes to the objects since the time of the user_merge.  Split users details and caveats:  The from_user is the user that was deleted in the user_merge process. The destination_user is the user that remains, that is being split.  Avatars: When both users had avatars, both will be remain. When from_user had an avatar and destination_user did not have an avatar, the destination_user's avatar will be deleted if it still matches what was there are the time of the merge. If the destination_user's avatar was changed at anytime after the merge, it will remain on the destination user. If the from_user had an avatar it will be there after split.  Terms of Use: If from_user had not accepted terms of use, they will be prompted again to accept terms of use after the split. If the destination_user had not accepted terms of use, hey will be prompted again to accept terms of use after the split. If neither user had accepted the terms of use, but since the time of the merge had accepted, both will be prompted to accept terms of use. If both had accepted terms of use, this will remain.  Communication Channels: All communication channels are restored to what they were prior to the merge. If a communication channel was added after the merge, it will remain on the destination_user. Notification preferences remain with the communication channels.  Enrollments: All enrollments from the time of the merge will be moved back to where they were. Enrollments created since the time of the merge that were created by sis_import will go to the user that owns that sis_id used for the import. Other new enrollments will remain on the destination_user. Everything that is tied to the destination_user at the course level relating to an enrollment is moved to the from_user. When both users are in the same course prior to merge this can cause some unexpected items to move.  Submissions: Unlike other items tied to a course, submissions are explicitly recorded to avoid problems with grades. All submissions were moved are restored to the spot prior to merge. All submission that were created in a course that was moved in enrollments are moved over to the from_user.  Other notes: Access Tokens are moved back on split. Conversations are moved back on split. Favorites that existing at the time of merge are moved back on split. LTI ids are restored to how they were prior to merge.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.split_merged_users_into_separate_users(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.split_merged_users_into_separate_users_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.split_merged_users_into_separate_users_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def split_merged_users_into_separate_users_with_http_info(self, id, **kwargs):  # noqa: E501
        """Split merged users into separate users  # noqa: E501

        Merged users cannot be fully restored to their previous state, but this will attempt to split as much as possible to the previous state. To split a merged user, the caller must have permissions to manage all of the users logins. If there are multiple users that have been merged into one user it will split each merge into a separate user. A split can only happen within 180 days of a user merge. A user merge deletes the previous user and may be permanently deleted. In this scenario we create a new user object and proceed to move as much as possible to the new user. The user object will not have preserved the name or settings from the previous user. Some items may have been deleted during a user_merge that cannot be restored, and/or the data has become stale because of other changes to the objects since the time of the user_merge.  Split users details and caveats:  The from_user is the user that was deleted in the user_merge process. The destination_user is the user that remains, that is being split.  Avatars: When both users had avatars, both will be remain. When from_user had an avatar and destination_user did not have an avatar, the destination_user's avatar will be deleted if it still matches what was there are the time of the merge. If the destination_user's avatar was changed at anytime after the merge, it will remain on the destination user. If the from_user had an avatar it will be there after split.  Terms of Use: If from_user had not accepted terms of use, they will be prompted again to accept terms of use after the split. If the destination_user had not accepted terms of use, hey will be prompted again to accept terms of use after the split. If neither user had accepted the terms of use, but since the time of the merge had accepted, both will be prompted to accept terms of use. If both had accepted terms of use, this will remain.  Communication Channels: All communication channels are restored to what they were prior to the merge. If a communication channel was added after the merge, it will remain on the destination_user. Notification preferences remain with the communication channels.  Enrollments: All enrollments from the time of the merge will be moved back to where they were. Enrollments created since the time of the merge that were created by sis_import will go to the user that owns that sis_id used for the import. Other new enrollments will remain on the destination_user. Everything that is tied to the destination_user at the course level relating to an enrollment is moved to the from_user. When both users are in the same course prior to merge this can cause some unexpected items to move.  Submissions: Unlike other items tied to a course, submissions are explicitly recorded to avoid problems with grades. All submissions were moved are restored to the spot prior to merge. All submission that were created in a course that was moved in enrollments are moved over to the from_user.  Other notes: Access Tokens are moved back on split. Conversations are moved back on split. Favorites that existing at the time of merge are moved back on split. LTI ids are restored to how they were prior to merge.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.split_merged_users_into_separate_users_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method split_merged_users_into_separate_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `split_merged_users_into_separate_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{id}/split', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[User]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def store_custom_data(self, user_id, ns, data, **kwargs):  # noqa: E501
        """Store custom data  # noqa: E501

        Store arbitrary user data as JSON.  Arbitrary JSON data can be stored for a User. A typical scenario would be an external site/service that registers users in Canvas and wants to capture additional info about them.  The part of the URL that follows +/custom_data/+ defines the scope of the request, and it reflects the structure of the JSON data to be stored or retrieved.  The value +self+ may be used for +user_id+ to store data associated with the calling user. In order to access another user's custom data, you must be an account administrator with permission to manage users.  A namespace parameter, +ns+, is used to prevent custom_data collisions between different apps.  This parameter is required for all custom_data requests.  A request with Content-Type multipart/form-data or Content-Type application/x-www-form-urlencoded can only be used to store strings.  Example PUT with multipart/form-data data:   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data/telephone' \\     -X PUT \\     -F 'ns=com.my-organization.canvas-app' \\     -F 'data=555-1234' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": \"555-1234\"   }  Subscopes (or, generated scopes) can also be specified by passing values to +data+[+subscope+].  Example PUT specifying subscopes:   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data/body/measurements' \\     -X PUT \\     -F 'ns=com.my-organization.canvas-app' \\     -F 'data[waist]=32in' \\     -F 'data[inseam]=34in' \\     -F 'data[chest]=40in' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": {       \"chest\": \"40in\",       \"waist\": \"32in\",       \"inseam\": \"34in\"     }   }  Following such a request, subsets of the stored data to be retrieved directly from a subscope.  Example {api:UsersController#get_custom_data GET} from a generated scope   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data/body/measurements/chest' \\     -X GET \\     -F 'ns=com.my-organization.canvas-app' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": \"40in\"   }  If you want to store more than just strings (i.e. numbers, arrays, hashes, true, false, and/or null), you must make a request with Content-Type application/json as in the following example.  Example PUT with JSON data:   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data' \\     -H 'Content-Type: application/json' \\     -X PUT \\     -d '{           \"ns\": \"com.my-organization.canvas-app\",           \"data\": {             \"a-number\": 6.02e23,             \"a-bool\": true,             \"a-string\": \"true\",             \"a-hash\": {\"a\": {\"b\": \"ohai\"}},             \"an-array\": [1, \"two\", null, false]           }         }' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": {       \"a-number\": 6.02e+23,       \"a-bool\": true,       \"a-string\": \"true\",       \"a-hash\": {         \"a\": {           \"b\": \"ohai\"         }       },       \"an-array\": [1, \"two\", null, false]     }   }  If the data is an Object (as it is in the above example), then subsets of the data can be accessed by including the object's (possibly nested) keys in the scope of a GET request.  Example {api:UsersController#get_custom_data GET} with a generated scope:   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data/a-hash/a/b' \\     -X GET \\     -F 'ns=com.my-organization.canvas-app' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": \"ohai\"   }   On success, this endpoint returns an object containing the data that was stored.  Responds with status code 200 if the scope already contained data, and it was overwritten by the data specified in the request.  Responds with status code 201 if the scope was previously empty, and the data specified in the request was successfully stored there.  Responds with status code 400 if the namespace parameter, +ns+, is missing or invalid, or if the +data+ parameter is missing.  Responds with status code 409 if the requested scope caused a conflict and data was not stored. This happens when storing data at the requested scope would cause data at an outer scope to be lost.  e.g., if +/custom_data+ was +{\"fashion_app\": {\"hair\": \"blonde\"}}+, but you tried to +`PUT /custom_data/fashion_app/hair/style -F data=buzz`+, then for the request to succeed,the value of +/custom_data/fashion_app/hair+ would have to become a hash, and its old string value would be lost.  In this situation, an error object is returned with the following format:    !!!javascript   {     \"message\": \"write conflict for custom_data hash\",     \"conflict_scope\": \"fashion_app/hair\",     \"type_at_conflict\": \"String\",     \"value_at_conflict\": \"blonde\"   }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_custom_data(user_id, ns, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str ns: The namespace under which to store the data.  This should be something other Canvas API apps aren't likely to use, such as a reverse DNS for your organization. (required)
        :param Object data: The data you want to store for the user, at the specified scope.  If the data is composed of (possibly nested) JSON objects, scopes will be generated for the (nested) keys (see examples). (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.store_custom_data_with_http_info(user_id, ns, data, **kwargs)  # noqa: E501
        else:
            (data) = self.store_custom_data_with_http_info(user_id, ns, data, **kwargs)  # noqa: E501
            return data

    def store_custom_data_with_http_info(self, user_id, ns, data, **kwargs):  # noqa: E501
        """Store custom data  # noqa: E501

        Store arbitrary user data as JSON.  Arbitrary JSON data can be stored for a User. A typical scenario would be an external site/service that registers users in Canvas and wants to capture additional info about them.  The part of the URL that follows +/custom_data/+ defines the scope of the request, and it reflects the structure of the JSON data to be stored or retrieved.  The value +self+ may be used for +user_id+ to store data associated with the calling user. In order to access another user's custom data, you must be an account administrator with permission to manage users.  A namespace parameter, +ns+, is used to prevent custom_data collisions between different apps.  This parameter is required for all custom_data requests.  A request with Content-Type multipart/form-data or Content-Type application/x-www-form-urlencoded can only be used to store strings.  Example PUT with multipart/form-data data:   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data/telephone' \\     -X PUT \\     -F 'ns=com.my-organization.canvas-app' \\     -F 'data=555-1234' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": \"555-1234\"   }  Subscopes (or, generated scopes) can also be specified by passing values to +data+[+subscope+].  Example PUT specifying subscopes:   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data/body/measurements' \\     -X PUT \\     -F 'ns=com.my-organization.canvas-app' \\     -F 'data[waist]=32in' \\     -F 'data[inseam]=34in' \\     -F 'data[chest]=40in' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": {       \"chest\": \"40in\",       \"waist\": \"32in\",       \"inseam\": \"34in\"     }   }  Following such a request, subsets of the stored data to be retrieved directly from a subscope.  Example {api:UsersController#get_custom_data GET} from a generated scope   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data/body/measurements/chest' \\     -X GET \\     -F 'ns=com.my-organization.canvas-app' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": \"40in\"   }  If you want to store more than just strings (i.e. numbers, arrays, hashes, true, false, and/or null), you must make a request with Content-Type application/json as in the following example.  Example PUT with JSON data:   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data' \\     -H 'Content-Type: application/json' \\     -X PUT \\     -d '{           \"ns\": \"com.my-organization.canvas-app\",           \"data\": {             \"a-number\": 6.02e23,             \"a-bool\": true,             \"a-string\": \"true\",             \"a-hash\": {\"a\": {\"b\": \"ohai\"}},             \"an-array\": [1, \"two\", null, false]           }         }' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": {       \"a-number\": 6.02e+23,       \"a-bool\": true,       \"a-string\": \"true\",       \"a-hash\": {         \"a\": {           \"b\": \"ohai\"         }       },       \"an-array\": [1, \"two\", null, false]     }   }  If the data is an Object (as it is in the above example), then subsets of the data can be accessed by including the object's (possibly nested) keys in the scope of a GET request.  Example {api:UsersController#get_custom_data GET} with a generated scope:   curl 'https://<canvas>/api/v1/users/<user_id>/custom_data/a-hash/a/b' \\     -X GET \\     -F 'ns=com.my-organization.canvas-app' \\     -H 'Authorization: Bearer <token>'  Response:   !!!javascript   {     \"data\": \"ohai\"   }   On success, this endpoint returns an object containing the data that was stored.  Responds with status code 200 if the scope already contained data, and it was overwritten by the data specified in the request.  Responds with status code 201 if the scope was previously empty, and the data specified in the request was successfully stored there.  Responds with status code 400 if the namespace parameter, +ns+, is missing or invalid, or if the +data+ parameter is missing.  Responds with status code 409 if the requested scope caused a conflict and data was not stored. This happens when storing data at the requested scope would cause data at an outer scope to be lost.  e.g., if +/custom_data+ was +{\"fashion_app\": {\"hair\": \"blonde\"}}+, but you tried to +`PUT /custom_data/fashion_app/hair/style -F data=buzz`+, then for the request to succeed,the value of +/custom_data/fashion_app/hair+ would have to become a hash, and its old string value would be lost.  In this situation, an error object is returned with the following format:    !!!javascript   {     \"message\": \"write conflict for custom_data hash\",     \"conflict_scope\": \"fashion_app/hair\",     \"type_at_conflict\": \"String\",     \"value_at_conflict\": \"blonde\"   }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_custom_data_with_http_info(user_id, ns, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :param str ns: The namespace under which to store the data.  This should be something other Canvas API apps aren't likely to use, such as a reverse DNS for your organization. (required)
        :param Object data: The data you want to store for the user, at the specified scope.  If the data is composed of (possibly nested) JSON objects, scopes will be generated for the (nested) keys (see examples). (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'ns', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method store_custom_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `store_custom_data`")  # noqa: E501
        # verify the required parameter 'ns' is set
        if self.api_client.client_side_validation and ('ns' not in params or
                                                       params['ns'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ns` when calling `store_custom_data`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in params or
                                                       params['data'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `data` when calling `store_custom_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'ns' in params:
            form_params.append(('ns', params['ns']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/custom_data', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def terminate_all_user_sessions(self, id, **kwargs):  # noqa: E501
        """Terminate all user sessions  # noqa: E501

        Terminates all sessions for a user. This includes all browser-based sessions and all access tokens, including manually generated ones. The user can immediately re-authenticate to access Canvas again if they have the current credentials. All integrations will need to be re-authorized.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.terminate_all_user_sessions(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.terminate_all_user_sessions_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.terminate_all_user_sessions_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def terminate_all_user_sessions_with_http_info(self, id, **kwargs):  # noqa: E501
        """Terminate all user sessions  # noqa: E501

        Terminates all sessions for a user. This includes all browser-based sessions and all access tokens, including manually generated ones. The user can immediately re-authenticate to access Canvas again if they have the current credentials. All integrations will need to be re-authorized.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.terminate_all_user_sessions_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method terminate_all_user_sessions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `terminate_all_user_sessions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{id}/sessions', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_custom_color(self, id, asset_string, **kwargs):  # noqa: E501
        """Update custom color  # noqa: E501

        Updates a custom color for a user for a given context.  This allows colors for the calendar and elsewhere to be customized on a user basis.  The asset string parameter should be in the format 'context_id', for example 'course_42'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_custom_color(id, asset_string, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str asset_string: ID (required)
        :param str hexcode: The hexcode of the color to set for the context, if you choose to pass the hexcode as a query parameter rather than in the request body you should NOT include the '#' unless you escape it first.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_custom_color_with_http_info(id, asset_string, **kwargs)  # noqa: E501
        else:
            (data) = self.update_custom_color_with_http_info(id, asset_string, **kwargs)  # noqa: E501
            return data

    def update_custom_color_with_http_info(self, id, asset_string, **kwargs):  # noqa: E501
        """Update custom color  # noqa: E501

        Updates a custom color for a user for a given context.  This allows colors for the calendar and elsewhere to be customized on a user basis.  The asset string parameter should be in the format 'context_id', for example 'course_42'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_custom_color_with_http_info(id, asset_string, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param str asset_string: ID (required)
        :param str hexcode: The hexcode of the color to set for the context, if you choose to pass the hexcode as a query parameter rather than in the request body you should NOT include the '#' unless you escape it first.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'asset_string', 'hexcode']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_custom_color" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_custom_color`")  # noqa: E501
        # verify the required parameter 'asset_string' is set
        if self.api_client.client_side_validation and ('asset_string' not in params or
                                                       params['asset_string'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `asset_string` when calling `update_custom_color`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'asset_string' in params:
            path_params['asset_string'] = params['asset_string']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'hexcode' in params:
            form_params.append(('hexcode', params['hexcode']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{id}/colors/{asset_string}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dashboard_positions(self, id, **kwargs):  # noqa: E501
        """Update dashboard positions  # noqa: E501

        Updates the dashboard positions for a user for a given context.  This allows positions for the dashboard cards and elsewhere to be customized on a per user basis.  The asset string parameter should be in the format 'context_id', for example 'course_42'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dashboard_positions(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_dashboard_positions_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dashboard_positions_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_dashboard_positions_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update dashboard positions  # noqa: E501

        Updates the dashboard positions for a user for a given context.  This allows positions for the dashboard cards and elsewhere to be customized on a per user basis.  The asset string parameter should be in the format 'context_id', for example 'course_42'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dashboard_positions_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dashboard_positions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_dashboard_positions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{id}/dashboard_positions', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user_settings(self, id, **kwargs):  # noqa: E501
        """Update user settings.  # noqa: E501

        Update an existing user's settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_settings(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param bool manual_mark_as_read: If true, require user to manually mark discussion posts as read (don't auto-mark as read).
        :param bool release_notes_badge_disabled: If true, hide the badge for new release notes.
        :param bool collapse_global_nav: If true, the user's page loads with the global navigation collapsed
        :param bool collapse_course_nav: If true, the user's course pages will load with the course navigation collapsed.
        :param bool hide_dashcard_color_overlays: If true, images on course cards will be presented without being tinted to match the course color.
        :param bool comment_library_suggestions_enabled: If true, suggestions within the comment library will be shown.
        :param bool elementary_dashboard_disabled: If true, will display the user's preferred class Canvas dashboard view instead of the canvas for elementary view.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_user_settings_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_user_settings_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_user_settings_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update user settings.  # noqa: E501

        Update an existing user's settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_settings_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID (required)
        :param bool manual_mark_as_read: If true, require user to manually mark discussion posts as read (don't auto-mark as read).
        :param bool release_notes_badge_disabled: If true, hide the badge for new release notes.
        :param bool collapse_global_nav: If true, the user's page loads with the global navigation collapsed
        :param bool collapse_course_nav: If true, the user's course pages will load with the course navigation collapsed.
        :param bool hide_dashcard_color_overlays: If true, images on course cards will be presented without being tinted to match the course color.
        :param bool comment_library_suggestions_enabled: If true, suggestions within the comment library will be shown.
        :param bool elementary_dashboard_disabled: If true, will display the user's preferred class Canvas dashboard view instead of the canvas for elementary view.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'manual_mark_as_read', 'release_notes_badge_disabled', 'collapse_global_nav', 'collapse_course_nav', 'hide_dashcard_color_overlays', 'comment_library_suggestions_enabled', 'elementary_dashboard_disabled']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_user_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'manual_mark_as_read' in params:
            query_params.append(('manual_mark_as_read', params['manual_mark_as_read']))  # noqa: E501
        if 'release_notes_badge_disabled' in params:
            query_params.append(('release_notes_badge_disabled', params['release_notes_badge_disabled']))  # noqa: E501
        if 'collapse_global_nav' in params:
            query_params.append(('collapse_global_nav', params['collapse_global_nav']))  # noqa: E501
        if 'collapse_course_nav' in params:
            query_params.append(('collapse_course_nav', params['collapse_course_nav']))  # noqa: E501
        if 'hide_dashcard_color_overlays' in params:
            query_params.append(('hide_dashcard_color_overlays', params['hide_dashcard_color_overlays']))  # noqa: E501
        if 'comment_library_suggestions_enabled' in params:
            query_params.append(('comment_library_suggestions_enabled', params['comment_library_suggestions_enabled']))  # noqa: E501
        if 'elementary_dashboard_disabled' in params:
            query_params.append(('elementary_dashboard_disabled', params['elementary_dashboard_disabled']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{id}/settings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_file(self, user_id, **kwargs):  # noqa: E501
        """Upload a file  # noqa: E501

        Upload a file to the user's personal files section.  This API endpoint is the first step in uploading a file to a user's files. See the {file:file_uploads.html File Upload Documentation} for details on the file upload workflow.  Note that typically users will only be able to upload files to their own files section. Passing a user_id of +self+ is an easy shortcut to specify the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_file_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_file_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def upload_file_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Upload a file  # noqa: E501

        Upload a file to the user's personal files section.  This API endpoint is the first step in uploading a file to a user's files. See the {file:file_uploads.html File Upload Documentation} for details on the file upload workflow.  Note that typically users will only be able to upload files to their own files section. Passing a user_id of +self+ is an easy shortcut to specify the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `upload_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{user_id}/files', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
