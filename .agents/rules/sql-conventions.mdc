---
description: SQL Conventions
globs: **/*.sql,**/*.ts,**/*.tsx
alwaysApply: false
---
# SQL Conventions

## File Organization
- Each `.ts` file should have a corresponding `.sql` file in the same directory
- Use Yesql pattern with `-- BLOCK` comments to name queries
- Uppercase SQL keywords: `SELECT`, `FROM`, `WHERE`, etc.

## SQL Queries via @prairielearn/postgres

- To keep SQL definitions and TypeScript logic cleanly separated yet colocated, each `*.ts` file has a same-named `*.sql` alongside it.
- Use `loadSqlEquiv(import.meta.url)` in TypeScript files to load and parse the adjacent `.sql` file.
- `loadSqlEquiv` reads the SQL file, splits it on the `-- BLOCK` markers, and returns an object whose keys are the block names. 
- Use `queryRow`, `queryRows`, and `runInTransactionAsync` from `@prairielearn/postgres` to execute SQL queries.
- Prefer using the models in `src/models/*.ts` instead of writing new SQL code
- Always validate data from the database using the appropriate Zod codec from `src/lib/db-types.ts`.
- When the database schema changes, update `src/components/AuditEventsTable.html.ts` to reflect the changes.

## Database Access
- Use `queryRow` for single-row queries (errors if not exactly one result)
- Use `queryRows` for multiple-row queries
- Always use prepared statements with named parameters
- Example:
```typescript
const question = await queryRow(
  sql.select_question,
  { question_id: 45 },
  QuestionSchema
);

const questions = await queryRows(
  sql.select_questions_by_course,
  { course_id: 45 },
  QuestionSchema
);
```

#### Example

In `accommodations.ts`:

```ts
import { loadSqlEquiv, queryRow, queryRows, runInTransactionAsync } from '@prairielearn/postgres';

// this will locate and parse "<same‑base‑name>.sql" next to the current file
const sql = loadSqlEquiv(import.meta.url);
```

In `accommodations.sql`:

```sql
-- BLOCK select_accommodation_by_id
SELECT …;
-- BLOCK insert_accommodation
INSERT … RETURNING …;
```

then in `accommodations.ts` you can write:

```ts
const row = await queryRow(
  sql.select_accommodation_by_id,
  { accommodation_id: id },
  AccommodationCodec,
);
const inserted = await runInTransactionAsync(async () =>
  queryRow(sql.insert_accommodation, { center_id, name, description }, AccommodationCodec),
);
```

## Naming Conventions
- Tables: plural names (e.g., `assessments`, `questions`)
- Primary keys: always named `id`
- Foreign keys: singular table name + `_id` (e.g., `assessment_id`)
- Variables: use `snake_case` matching SQL names
- Table aliases: first letters of words (e.g., `ai` for `assessment_instances`)

## Database Schema Conventions
- Tables have plural names (e.g. `assessments`) and always have a primary key called `id`
- Foreign keys pointing to a table are non-plural, like `assessment_id`
- Table aliases use first letters of words (e.g. `ai` for `assessment_instances`)
- Exceptions: `aset` for `assessment_sets`, `top` for `topics`, `tag` for `tags`
- Never delete student data from the database
- Use soft deletion with `deleted_at` column for course configuration tables
- Always include `WHERE deleted_at IS NULL` for soft-deletable tables

## Query Patterns
- Use CTEs (`WITH` queries) for complex queries
- Use named parameters with `$parameter_name`
- Always include `WHERE deleted_at IS NULL` for soft-deletable tables
- Use explicit row locking for student data modifications:
  ```sql
  SELECT * FROM assessment_instances
  WHERE id = $assessment_instance_id
  FOR NO KEY UPDATE;
  ```

## Example Structure
```sql
-- BLOCK select_questions_by_course
SELECT
  *
FROM
  questions
WHERE
  course_id = $course_id
  AND deleted_at IS NULL;

-- BLOCK insert_user
INSERT INTO
  users (uid)
VALUES
  ($uid)
RETURNING
  *;
```
