const ERR = require('async-stacktrace');
const path = require('path');


const { sqlDb, sqlLoader } = require('@prairielearn/prairielib');

const sql = sqlLoader.loadSqlEquiv(__filename);

/**
 * 
 * @param {string[]} changedFiles A list of files that changed in a given sync.
 * @param {object} course The "full course" that was loaded from disk, as generated by `course-db.js#loadFullCourse`.
 */
module.exports.identifyChunksFromChangedFiles = (changedFiles, course) => {
    const chunks = {
        courseChunks: new Set(),
        courseInstances: {},
        questionChunks: new Set(),
    };

    changedFiles.forEach(changedFile => {
        if (changedFile.startsWith('elements/')) {
            chunks.courseChunks.add('elements');
        }
        if (changedFile.startsWith('serverFilesCourse/')) {
            chunks.courseChunks.add('serverFilesCourse');
        }
        if (changedFile.startsWith('clientFilesCourse/')) {
            chunks.courseChunks.add('clientFilesCourse');
        }
        if (changedFile.startsWith('questions/')) {
            // Here's where things get interesting. Questions can be nested in
            // directories, so we need to figure out which of the potentially
            // deeply-nested directories is the root of a particular question.
            const pathComponents = changedFile.split(path.sep).slice(1);
            // Progressively join more and more path components until we get
            // something that corresponds to an actual question
            let questionId = null;
            for (let i = 1; i < pathComponents.length; i++) {
                const candidateQuestionId = path.join(...pathComponents.slice(0, i));
                if (course.questionDB[candidateQuestionId]) {
                    questionId = candidateQuestionId;
                    break;
                }
            }
            if (questionId) {
                // This chunk corresponds to a question!
                chunks.questionChunks.add(questionId);
            }
        }
        if (changedFile.startsWith('courseInstances/')) {
            // There's really only one type of thing in course instances that
            // we care about building chunks for: `clientFilesAssessment` in
            // assessment directories.

            const pathComponents = changedFile.split(path.sep).slice(1);

            const assessmentsIndex = pathComponents.indexOf('assessments');
            const clientFilesAssessmentIndex = pathComponents.indexOf('clientFilesAssessment');
            if (
                assessmentsIndex >= 0 &&
                clientFilesAssessmentIndex >= 0 &&
                clientFilesAssessmentIndex > assessmentsIndex
            ) {
                // We probably care about this file - let's validate that by
                // splitting up the path into chunks that hopefully correspond
                // to course instance IDs and assessment IDs.
                const courseInstanceId = path.join(...pathComponents.slice(0, assessmentsIndex));
                const assessmentId = path.join(...pathComponents.slice(assessmentsIndex + 1, clientFilesAssessmentIndex));

                if (
                    course.courseInstanceDB[courseInstanceId] &&
                    course.courseInstanceDB[courseInstanceId].assessmentDB[assessmentId]
                ) {
                    // This corresponds to something that we need to
                    // create/update a chunk for!
                    if (!chunks.courseInstances[courseInstanceId]) {
                        chunks.courseInstances[courseInstanceId] = { assessmentChunks: new Set() };
                    }
                    chunks.courseInstances[courseInstanceId].assessmentChunks.add(assessmentId);
                }
            }
        }
    });

    return chunks;
};
