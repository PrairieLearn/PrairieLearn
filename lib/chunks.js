// @ts-check
const path = require('path');

/**
 * Given a list of files that have changed (such as that produced by
 * `git diff --name-only`), returns a data structure describing the chunks
 * that need to be generated.
 * 
 * @param {string[]} changedFiles A list of files that changed in a given sync.
 * @param {object} course The "full course" that was loaded from disk, as generated by `course-db.js#loadFullCourse`.
 * @returns {{ courseChunks: Set<string>, courseInstances: { [id: string]: { assessmentChunks: Set<string> } }, questionChunks: Set<string> }}
 */
module.exports.identifyChunksFromChangedFiles = (changedFiles, course) => {
    const chunks = {
        /** @type {Set<string>} */
        courseChunks: new Set(),
        /** @type {{ [id: string]: { assessmentChunks: Set<string> } }} */
        courseInstances: {},
        /** @type {Set<string>} */
        questionChunks: new Set(),
    };

    changedFiles.forEach(changedFile => {
        if (changedFile.startsWith('elements/')) {
            chunks.courseChunks.add('elements');
        }
        if (changedFile.startsWith('serverFilesCourse/')) {
            chunks.courseChunks.add('serverFilesCourse');
        }
        if (changedFile.startsWith('clientFilesCourse/')) {
            chunks.courseChunks.add('clientFilesCourse');
        }
        if (changedFile.startsWith('questions/')) {
            // Here's where things get interesting. Questions can be nested in
            // directories, so we need to figure out which of the potentially
            // deeply-nested directories is the root of a particular question.
            const pathComponents = changedFile.split(path.sep).slice(1);
            // Progressively join more and more path components until we get
            // something that corresponds to an actual question
            let questionId = null;
            for (let i = 1; i < pathComponents.length; i++) {
                const candidateQuestionId = path.join(...pathComponents.slice(0, i));
                if (course.questionDB[candidateQuestionId]) {
                    questionId = candidateQuestionId;
                    break;
                }
            }
            if (questionId) {
                // This chunk corresponds to a question!
                chunks.questionChunks.add(questionId);
            }
        }
        if (changedFile.startsWith('courseInstances/')) {
            // There's really only one type of thing in course instances that
            // we care about building chunks for: `clientFilesAssessment` in
            // assessment directories.

            const pathComponents = changedFile.split(path.sep).slice(1);

            const assessmentsIndex = pathComponents.indexOf('assessments');
            const clientFilesAssessmentIndex = pathComponents.indexOf('clientFilesAssessment');
            if (
                assessmentsIndex >= 0 &&
                clientFilesAssessmentIndex >= 0 &&
                clientFilesAssessmentIndex > assessmentsIndex
            ) {
                // We probably care about this file - let's validate that by
                // splitting up the path into chunks that hopefully correspond
                // to course instance IDs and assessment IDs.
                const courseInstanceId = path.join(...pathComponents.slice(0, assessmentsIndex));
                const assessmentId = path.join(...pathComponents.slice(assessmentsIndex + 1, clientFilesAssessmentIndex));

                if (
                    course.courseInstanceDB[courseInstanceId] &&
                    course.courseInstanceDB[courseInstanceId].assessmentDB[assessmentId]
                ) {
                    // This corresponds to something that we need to
                    // create/update a chunk for!
                    if (!chunks.courseInstances[courseInstanceId]) {
                        chunks.courseInstances[courseInstanceId] = { assessmentChunks: new Set() };
                    }
                    chunks.courseInstances[courseInstanceId].assessmentChunks.add(assessmentId);
                }
            }
        }
    });

    return chunks;
};
