const ERR = require('async-stacktrace');
const path = require('path');


const { sqlDb, sqlLoader } = require('@prairielearn/prairielib');

const sql = sqlLoader.loadSqlEquiv(__filename);

/**
 * 
 * @param {string[]} changedFiles A list of files that changed in a given sync.
 * @param {object} course The "full course" that was loaded from disk, as generated by `course-db.js#loadFullCourse`.
 */
module.exports.identifyChunksFromChangedFiles = (changedFiles, course) => {
    const chunks = {
        courseChunks: new Set(),
        courseInstances: {},
        questionChunks: new Set(),
    };

    changedFiles.forEach(changedFile => {
        if (changedFile.startsWith('elements/')) {
            chunks.courseChunks.add('elements');
        }
        if (changedFile.startsWith('serverFilesCourse/')) {
            chunks.courseChunks.add('serverFilesCourse');
        }
        if (changedFile.startsWith('clientFilesCourse/')) {
            chunks.courseChunks.add('clientFilesCourse');
        }
        if (changedFile.startsWith('questions/')) {
            // Here's where things get interesting. Questions can be nested in
            // directories, so we need to figure out which of the potentially
            // deeply-nested directories is the root of a particular question.
            const pathComponents = changedFile.split(path.sep).slice(1);
            // Progressively join more and more path components until we get
            // something that corresponds to an actual question
            let questionId = null;
            for (let i = 1; i < pathComponents.length; i++) {
                const candidateQuestionId = path.join(...pathComponents.slice(0, i));
                if (course.questionDB[candidateQuestionId]) {
                    questionId = candidateQuestionId;
                    break;
                }
            }
            if (questionId) {
                // This chunk corresponds to a question!
                chunks.questionChunks.add(questionId);
            }
        }
    });

    return chunks;
}
