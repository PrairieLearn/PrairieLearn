on:
  workflow_call:
    inputs:
      directory:
        description: 'Either "workspaces" or "graders"'
        required: true
        type: string
      image-prefix:
        description: 'The prefix for the image name (e.g. prairielearn/workspace-)'
        required: true
        type: string
      base-images:
        description: 'The base images to build'
        required: false
        type: string
        default: '[]'
      images:
        description: 'The images to build'
        required: true
        type: string
      upload-artifacts-for:
        description: 'The images to upload artifacts for'
        required: false
        type: string
        default: '[]'
      exclude:
        description: 'The combinations to exclude'
        required: false
        type: string
        default: '[]'

jobs:
  build-base-images:
    if: ${{ inputs.base-images != '[]' }}
    strategy:
      max-parallel: 5
      matrix:
        image: ${{ fromJSON(inputs.base-images) }}
        os: [ubuntu-24.04, ubuntu-24.04-arm]
        exclude: ${{ fromJSON(inputs.exclude) }}
    runs-on: ${{ matrix.os }}
    env:
      CAN_PUSH_IMAGE: ${{ secrets.DOCKERHUB_USERNAME != '' }}
    steps:
      # Check out the repository with full depth so we can check if the workspace was modified
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check whether ${{ inputs.directory }}/${{ matrix.image }} was modified
        id: check-modified
        run: |
          scripts/check_path_modified.sh ${{ inputs.directory }}/${{ matrix.image }} ${{ inputs.directory }}_${{ matrix.image }}_modified

      - name: Set up Docker Buildx
        # Currently, we need this 'if' on each step. https://github.com/orgs/community/discussions/82744
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        uses: docker/setup-buildx-action@v3

      - name: Login to DockerHub
        if: ${{ steps.check-modified.outputs.was-modified == 'true' && env.CAN_PUSH_IMAGE == 'true' }}
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set docker tags and labels
        id: meta
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        uses: docker/metadata-action@v5
        with:
          context: git
          images: |
            ${{ inputs.image-prefix }}${{ matrix.image }}
          # On the default branch, we'll also tag the image as `latest`
          tags: |
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,prefix=,format=long

      - name: Build ${{ (env.CAN_PUSH_IMAGE == 'true' && 'and push') || '' }} digest
        id: build-digest
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.directory }}/${{ matrix.image }}
          labels: ${{ steps.meta.outputs.labels }}
          tags: ${{ inputs.image-prefix }}${{ matrix.image }}
          outputs: |
            type=image,push-by-digest=true,name-canonical=true,push=${{ env.CAN_PUSH_IMAGE == 'true' }}

      - name: Build tarball
        id: build
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.directory }}/${{ matrix.image }}
          labels: ${{ steps.meta.outputs.labels }}
          tags: ${{ steps.meta.outputs.tags }}
          outputs: |
            type=docker,dest=${{ runner.temp }}/${{ matrix.image }}-${{ matrix.os }}.tar

      # Group digests by image name. Tags are associated with each digest, but will be all merged when we push the image.
      - name: Export docker metadata
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        run: |
          mkdir -p ${{ runner.temp }}/digests/${{ matrix.image}}
          digest="${{ steps.build-digest.outputs.digest }}"
          echo "${{ steps.meta.outputs.tags }}" > "${{ runner.temp }}/digests/${{ matrix.image }}/${digest#sha256:}"

      # Workaround for https://github.com/orgs/community/discussions/17245
      - name: Upload docker metadata
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ inputs.directory }}-${{ matrix.image }}-${{ matrix.os }}
          path: ${{ runner.temp }}/digests/
          if-no-files-found: error
          retention-days: 1
      # We will upload the tarball so we can use it in the next job
      - name: Upload docker tarball
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.directory }}-${{ matrix.image }}-${{ matrix.os }}-tarball
          path: ${{ runner.temp }}/${{ matrix.image }}-${{ matrix.os }}.tar
          if-no-files-found: error
          retention-days: 1

  build-images:
    needs: [build-base-images]
    if: |
      always() && (needs.build-base-images.result == 'success' || needs.build-base-images.result == 'skipped')
    strategy:
      max-parallel: 5
      matrix:
        image: ${{ fromJSON(inputs.images) }}
        os: [ubuntu-24.04, ubuntu-24.04-arm]
        exclude: ${{ fromJSON(inputs.exclude) }}
    runs-on: ${{ matrix.os }}
    env:
      CAN_PUSH_IMAGE: ${{ secrets.DOCKERHUB_USERNAME != '' }}

    # Associate each workspace with requirements
    steps:
      # Check out the repository with full depth so we can check if the workspace was modified
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check whether ${{ inputs.directory }}/${{ matrix.image }} was modified
        id: check-modified
        run: |
          scripts/check_path_modified.sh ${{ inputs.directory }}/${{ matrix.image }} ${{ inputs.directory }}_${{ matrix.image }}_modified

      - name: Set up Docker Buildx
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        uses: docker/setup-buildx-action@v3
        with:
          # network=host driver-opt needed to push to local registry
          driver-opts: network=host

      - name: Login to DockerHub
        if: ${{ steps.check-modified.outputs.was-modified == 'true' && env.CAN_PUSH_IMAGE == 'true' }}
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Download artifact
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        uses: actions/download-artifact@v4
        # Download all uploaded artifacts that match our OS
        with:
          pattern: '${{ inputs.directory }}-*-${{ matrix.os }}-tarball'
          path: ${{ runner.temp }}
          merge-multiple: true

      # This won't do anything if there are no artifacts to download (i.e. the base image didn't change)
      # Retag these loaded images as latest, so that they get used as the base image instead of
      # the one from DockerHub
      - name: Load and tag base images
        id: tag-base
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        run: |
          build_contexts=""
          for file in ${{ runner.temp }}/*-${{ matrix.os }}.tar; do
            tagged_images=$(docker load -i "$file" | sed -n 's/Loaded image: //p')
            for tagged_image in $tagged_images; do
              image="${tagged_image%:*}"
              docker tag "$tagged_image" "localhost:5000/$image:latest"
              build_contexts="$build_contexts$image=docker-image://localhost:5000/$image:latest\n"
            done
          done
          echo "build-contexts=$build_contexts" >> $GITHUB_OUTPUT
          cat $GITHUB_OUTPUT
          docker image ls -a

      - name: Set docker tags and labels
        id: meta
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        uses: docker/metadata-action@v5
        with:
          context: git
          images: |
            ${{ inputs.image-prefix }}${{ matrix.image }}
          # On the default branch, we'll also tag the image as `latest`
          tags: |
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,prefix=,format=long

      - name: Build ${{ (env.CAN_PUSH_IMAGE == 'true' && 'and push') || '' }} digest
        id: build-digest
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.directory }}/${{ matrix.image }}
          labels: ${{ steps.meta.outputs.labels }}
          tags: ${{ inputs.image-prefix }}${{ matrix.image }}
          build-contexts: ${{ steps.tag-base.outputs.build-contexts }}
          outputs: |
            type=image,push-by-digest=true,name-canonical=true,push=${{ env.CAN_PUSH_IMAGE == 'true' }}

      - name: Build tarball
        id: build
        if: ${{ steps.check-modified.outputs.was-modified == 'true' && contains(fromJson(inputs.upload-artifacts-for), format('{0}-{1}', matrix.image, matrix.os)) }}
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.directory }}/${{ matrix.image }}
          labels: ${{ steps.meta.outputs.labels }}
          tags: ${{ steps.meta.outputs.tags }}
          outputs: |
            type=docker,dest=${{ runner.temp }}/${{ matrix.image }}-${{ matrix.os }}.tar

      - name: Export docker metadata
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        run: |
          mkdir -p ${{ runner.temp }}/digests/${{ matrix.image }}
          digest="${{ steps.build-digest.outputs.digest }}"
          echo "${{ steps.meta.outputs.tags }}" > "${{ runner.temp }}/digests/${{ matrix.image }}/${digest#sha256:}"

      - name: Upload docker metadata
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ inputs.directory}}-${{ matrix.image }}-${{ matrix.os }}
          path: ${{ runner.temp }}/digests/
          if-no-files-found: error
          retention-days: 1

      - name: Upload docker tarball
        if: ${{ steps.check-modified.outputs.was-modified == 'true'  && contains(fromJson(inputs.upload-artifacts-for), format('{0}-{1}', matrix.image, matrix.os)) }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.directory }}-${{ matrix.image }}-${{ matrix.os }}-tarball
          path: ${{ runner.temp }}/${{ matrix.image }}-${{ matrix.os }}.tar
          if-no-files-found: error
          retention-days: 1
  tag-images:
    runs-on: ubuntu-24.04
    needs: [build-images]
    # If build-base-images is skipped, this normally wouldn't run. https://github.com/actions/runner/issues/491#issuecomment-882886236
    if: |
      always() && (needs.build-images.result == 'success')
    env:
      CAN_PUSH_IMAGE: ${{ secrets.DOCKERHUB_USERNAME != '' }}
    steps:
      - name: Download digests
        if: ${{ env.CAN_PUSH_IMAGE == 'true' }}
        uses: actions/download-artifact@v4
        with:
          path: ${{ runner.temp }}/digests
          pattern: 'digests-${{ inputs.directory}}-*'
          merge-multiple: true

      - name: Login to DockerHub
        if: ${{ env.CAN_PUSH_IMAGE == 'true' }}
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        if: ${{ env.CAN_PUSH_IMAGE == 'true' }}
        uses: docker/setup-buildx-action@v3

      - name: Create manifest list and push
        if: ${{ env.CAN_PUSH_IMAGE == 'true' }}
        working-directory: ${{ runner.temp }}/digests
        run: |
          for image in *; do
            pushd "$image"
            tags="$(cat -- * | xargs echo -n | tr '\n' ' ' | sed 's/ / -t /g')"
            # shellcheck disable=SC2046,SC2086
            docker buildx imagetools create -t $tags $(printf "${{ inputs.image-prefix }}$image@sha256:%s " *)
            popd
          done
