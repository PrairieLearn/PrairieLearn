on:
  workflow_call:
    inputs:
      directory:
        description: 'The directory containing Dockerfiles to build (e.g. workspaces)'
        required: true
        type: string
      image-prefix:
        description: 'The prefix for the image name (e.g. prairielearn/workspace-)'
        required: true
        type: string
      base-images:
        description: 'The base images to build'
        required: false
        type: string
        default: '[]'
      images:
        description: 'The images to build'
        required: true
        type: string
      upload-artifacts-for:
        description: 'The images to upload artifacts for'
        required: false
        type: string
        default: '[]'
      exclude:
        description: 'The combinations to exclude'
        required: false
        type: string
        default: '[]'

jobs:
  build-base-images:
    if: ${{ inputs.base-images != '[]' }}
    strategy:
      max-parallel: 5
      matrix:
        image: ${{ fromJSON(inputs.base-images) }}
        os: [ubuntu-24.04, ubuntu-24.04-arm]
        exclude: ${{ fromJSON(inputs.exclude) }}
    runs-on: ${{ matrix.os }}
    env:
      CAN_PUSH_IMAGE: ${{ secrets.DOCKERHUB_USERNAME != '' }}
    steps:
      # Check out the repository with full depth so we can check if the workspace was modified
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check whether ${{ inputs.directory }}/${{ matrix.image }} was modified
        id: check-modified
        run: |
          scripts/check_path_modified.sh ${{ inputs.directory }}/${{ matrix.image }} ${{ inputs.directory }}_${{ matrix.image }}_modified

      - name: Login to DockerHub
        if: ${{ steps.check-modified.outputs.was-modified == 'true' && env.CAN_PUSH_IMAGE == 'true' }}
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build ${{ (env.CAN_PUSH_IMAGE == 'true' && 'and push') || '' }} platform-specific base image
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.directory }}/${{ matrix.image }}
          tags: '${{ inputs.image-prefix }}${{ matrix.image }}:${{ github.sha }}-${{ runner.arch }}'
          push: ${{ env.CAN_PUSH_IMAGE == 'true' }}

      # Export the base image as a tarball (See https://docs.docker.com/build/ci/github-actions/share-image-jobs/)
      - name: Export tarball
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        run: |
          docker save -o ${{ runner.temp }}/${{ matrix.image }}-${{ matrix.os }}.tar "${{ inputs.image-prefix }}${{ matrix.image }}:${{ github.sha }}-${{ runner.arch }}"

      # Create an empty file that will be used to mark an image as modified
      - name: Export metadata
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        run: |
          mkdir -p ${{ runner.temp }}/image-metadata
          touch ${{ runner.temp }}/image-metadata/${{ matrix.image }}

      # Currently, there is no way to reference outputs for matrix jobs (https://github.com/orgs/community/discussions/17245)
      - name: Upload metadata
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: image-metadata-${{ inputs.directory}}-${{ matrix.image }}-${{ matrix.os }}
          path: ${{ runner.temp }}/image-metadata/
          if-no-files-found: error
          retention-days: 1

      # Upload the docker container so we can reference it in the next job.
      - name: Upload tarball
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.directory }}-${{ matrix.image }}-${{ matrix.os }}-tarball
          path: ${{ runner.temp }}/${{ matrix.image }}-${{ matrix.os }}.tar
          if-no-files-found: error
          retention-days: 1

  build-images:
    needs: [build-base-images]
    if: |
      always() && (needs.build-base-images.result == 'success' || needs.build-base-images.result == 'skipped')
    strategy:
      max-parallel: 5
      matrix:
        image: ${{ fromJSON(inputs.images) }}
        os: [ubuntu-24.04, ubuntu-24.04-arm]
        exclude: ${{ fromJSON(inputs.exclude) }}
    runs-on: ${{ matrix.os }}
    env:
      CAN_PUSH_IMAGE: ${{ secrets.DOCKERHUB_USERNAME != '' }}

    # These steps will be similar to `build-base-images` -- View the comments there for more details.
    steps:
      # Check out the repository with full depth so we can check if the workspace was modified
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check whether ${{ inputs.directory }}/${{ matrix.image }} was modified
        id: check-modified
        run: |
          scripts/check_path_modified.sh ${{ inputs.directory }}/${{ matrix.image }} ${{ inputs.directory }}_${{ matrix.image }}_modified

      - name: Login to DockerHub
        if: ${{ steps.check-modified.outputs.was-modified == 'true' && env.CAN_PUSH_IMAGE == 'true' }}
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Download tarball
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        uses: actions/download-artifact@v4
        # Download all base images that were built in the previous job
        with:
          pattern: '${{ inputs.directory }}-*-${{ matrix.os }}-tarball'
          path: ${{ runner.temp }}
          merge-multiple: true

      - name: Tag base images
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        # Retag all base images that were downloaded in the previous step as latest.
        # This is slightly simpler than using a named context.
        run: |
          for file in ${{ runner.temp }}/*-${{ matrix.os }}.tar; do
            tagged_images=$(docker load -i "$file" | sed -n 's/Loaded image: //p')
            for tagged_image in $tagged_images; do
              image="${tagged_image%:*}"
              docker tag "$tagged_image" "$image:latest"
            done
          done
          docker image ls -a

      - name: Build ${{ (env.CAN_PUSH_IMAGE == 'true' && 'and push') || '' }} platform-specific image
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.directory }}/${{ matrix.image }}
          push: ${{ env.CAN_PUSH_IMAGE == 'true' }}
          # We will tag using a platform-specific image instead of doing a push-by-digest (https://docs.docker.com/build/ci/github-actions/multi-platform/#distribute-build-across-multiple-runners).
          # We want to use the default docker builder, as buildx uses `docker-container`, which has additional overhead to load local images (https://docs.docker.com/build/ci/github-actions/named-contexts/#using-with-a-container-builder).
          tags: '${{ inputs.image-prefix }}${{ matrix.image }}:${{ github.sha }}-${{ runner.arch }}'

      - name: Export tarball
        if: ${{ steps.check-modified.outputs.was-modified == 'true' && contains(fromJson(inputs.upload-artifacts-for), format('{0}-{1}', matrix.image, matrix.os)) }}
        run: |
          docker save -o ${{ runner.temp }}/${{ matrix.image }}-${{ matrix.os }}.tar "${{ inputs.image-prefix }}${{ matrix.image }}:${{ github.sha }}-${{ runner.arch }}"

      - name: Export metadata
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        run: |
          mkdir -p ${{ runner.temp }}/image-metadata
          touch ${{ runner.temp }}/image-metadata/${{ matrix.image }}

      - name: Upload metadata
        if: ${{ steps.check-modified.outputs.was-modified == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: image-metadata-${{ inputs.directory}}-${{ matrix.image }}-${{ matrix.os }}
          path: ${{ runner.temp }}/image-metadata/
          if-no-files-found: error
          retention-days: 1

      - name: Upload tarball
        if: ${{ steps.check-modified.outputs.was-modified == 'true'  && contains(fromJson(inputs.upload-artifacts-for), format('{0}-{1}', matrix.image, matrix.os)) }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.directory }}-${{ matrix.image }}-${{ matrix.os }}-tarball
          path: ${{ runner.temp }}/${{ matrix.image }}-${{ matrix.os }}.tar
          if-no-files-found: error
          retention-days: 1
  tag-images:
    runs-on: ubuntu-24.04
    needs: [build-images]
    # If build-base-images is skipped, this wouldn't run, so we add this `always()` block (https://github.com/actions/runner/issues/491#issuecomment-882886236)
    if: |
      always() && (needs.build-images.result == 'success')
    env:
      CAN_PUSH_IMAGE: ${{ secrets.DOCKERHUB_USERNAME != '' }}
    steps:
      - name: Download metadata
        if: ${{ env.CAN_PUSH_IMAGE == 'true' }}
        uses: actions/download-artifact@v4
        with:
          path: ${{ runner.temp }}/image-metadata
          pattern: 'image-metadata-${{ inputs.directory}}-*'
          merge-multiple: true

      - name: Login to DockerHub
        if: ${{ env.CAN_PUSH_IMAGE == 'true' }}
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        if: ${{ env.CAN_PUSH_IMAGE == 'true' }}
        uses: docker/setup-buildx-action@v3

      - name: Create multi-platform manifest
        if: ${{ env.CAN_PUSH_IMAGE == 'true' }}
        working-directory: ${{ runner.temp }}/image-metadata
        run: |
          for image in *; do
            latest_tag="${{ github.ref_name == github.event.repository.default_branch && format('-t \"{0}$image:latest\"', inputs.image-prefix) || '' }}"
            # shellcheck disable=SC2046,SC2086
            docker buildx imagetools create \
              $latest_tag \
              -t $image:latest \
              -t "${{ inputs.image-prefix }}$image:${{ github.sha }}" \
            "${{ inputs.image-prefix }}$image:${{ github.sha }}-X64" "${{ inputs.image-prefix }}$image:${{ github.sha }}-ARM64"
          done
