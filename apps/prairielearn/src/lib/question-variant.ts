import _ = require('lodash');
import * as fg from 'fast-glob';
import { z } from 'zod';

import { workspaceFastGlobDefaultOptions } from '@prairielearn/workspace-utils';
import * as sqldb from '@prairielearn/postgres';

import * as questionServers from '../question-servers';
import { writeCourseIssues } from './issues';
import { selectCourseById } from '../models/course';
import { selectQuestionById, selectQuestionByInstanceQuestionId } from '../models/question';
import { Course, Question, Variant, VariantSchema } from './db-types';

const VariantWithFormattedDateSchema = VariantSchema.extend({
  formatted_date: z.string(),
});
type VariantWithFormattedDate = z.infer<typeof VariantWithFormattedDateSchema>;

interface VariantCreationData {
  variant_seed: string;
  params: Record<string, any>;
  true_answer: Record<string, any>;
  options: Record<string, any>;
  broken: boolean;
}

/**
 * Internal function, do not call directly. Create a variant object, do not write to DB.
 * @protected
 *
 * @param question - The question for the variant.
 * @param course - The course for the question.
 * @param options - Options controlling the creation: options = {variant_seed}
 */
async function makeVariant(
  question: Question,
  course: Course,
  options: { variant_seed?: string | null },
): Promise<{
  courseIssues: (Error & { fatal?: boolean; data?: any })[];
  variant: VariantCreationData;
}> {
  let variant_seed: string;
  if (_(options).has('variant_seed') && options.variant_seed != null) {
    variant_seed = options.variant_seed;
  } else {
    variant_seed = Math.floor(Math.random() * Math.pow(2, 32)).toString(36);
  }

  const questionModule = questionServers.getModule(question.type);
  const { courseIssues, data } = await questionModule.generate(question, course, variant_seed);
  const hasFatalIssue = _.some(_.map(courseIssues, 'fatal'));
  let variant: VariantCreationData = {
    variant_seed: variant_seed,
    params: data.params || {},
    true_answer: data.true_answer || {},
    options: data.options || {},
    broken: hasFatalIssue,
  };

  if (question.workspace_image !== null) {
    // if workspace, add graded files to params
    variant.params['_workspace_required_file_names'] = (
      question.workspace_graded_files || []
    ).filter((file) => !fg.isDynamicPattern(file, workspaceFastGlobDefaultOptions));
    if (!('_required_file_names' in variant.params)) {
      variant.params['_required_file_names'] = [];
    }
    variant.params['_required_file_names'] = variant.params['_required_file_names'].concat(
      variant.params['_workspace_required_file_names'],
    );
  }

  if (!variant.broken) {
    const { courseIssues: prepareCourseIssues, data } = await questionModule.prepare(
      question,
      course,
      variant,
    );
    courseIssues.push(...prepareCourseIssues);
    const hasFatalIssue = _.some(_.map(courseIssues, 'fatal'));
    variant = {
      variant_seed: variant_seed,
      params: data.params || {},
      true_answer: data.true_answer || {},
      options: data.options || {},
      broken: hasFatalIssue,
    };
  }

  return { courseIssues, variant };
}

/**
 * Get a file that is generated by code.
 *
 * @param filename
 * @param variant - The variant.
 * @param question - The question for the variant.
 * @param variant_course - The course for the variant.
 * @param authn_user_id - The current authenticated user.
 */
export async function getDynamicFile(
  filename: string,
  variant: Variant,
  question: Question,
  variant_course: Course,
  authn_user_id: string,
): Promise<Buffer> {
  const question_course = await getQuestionCourse(question, variant_course);
  const questionModule = questionServers.getModule(question.type);
  if (!questionModule.file) {
    throw new Error(`Question type ${question.type} does not support file generation`);
  }
  const { courseIssues, data: fileData } = await questionModule.file(
    filename,
    variant,
    question,
    question_course,
  );

  const studentMessage = 'Error creating file: ' + filename;
  const courseData = { variant, question, course: variant_course };
  await writeCourseIssues(courseIssues, variant, authn_user_id, studentMessage, courseData);
  return fileData;
}

/**
 * Internal function, do not call directly. Get a question by either question_id or instance_question_id.
 * @protected
 *
 * @param question_id - The question for the new variant. Can be null if instance_question_id is provided.
 * @param instance_question_id - The instance question for the new variant. Can be null if question_id is provided.
 */
async function selectQuestion(
  question_id: string | null,
  instance_question_id: string | null,
): Promise<Question> {
  if (question_id != null) {
    return await selectQuestionById(question_id);
  } else if (instance_question_id != null) {
    return await selectQuestionByInstanceQuestionId(instance_question_id);
  } else {
    throw new Error('question_id and instance_question_id cannot both be null');
  }
}

/**
 * Internal function, do not call directly. Create a variant object, and write it to the DB.
 * @protected
 *
 * @param question_id - The question for the new variant. Can be null if instance_question_id is provided.
 * @param instance_question_id - The instance question for the new variant, or null for a floating variant.
 * @param user_id - The user for the new variant.
 * @param authn_user_id - The current authenticated user.
 * @param group_work - If the assessment will support group work.
 * @param course_instance_id - The course instance for this variant. Can be null for instructor questions.
 * @param variant_course - The course for the variant.
 * @param question_course - The course for the question.
 * @param options - Options controlling the creation: options = {variant_seed}
 * @param require_open - If true, only use an existing variant if it is open.
 * @param client_fingerprint_id - The client fingerprint for this variant.
 */
async function makeAndInsertVariant(
  question_id: string | null,
  instance_question_id: string | null,
  user_id: string,
  authn_user_id: string,
  group_work: boolean,
  course_instance_id: string | null,
  variant_course: Course,
  question_course: Course,
  options: { variant_seed?: string | null },
  require_open: boolean,
  client_fingerprint_id: string | null,
): Promise<VariantWithFormattedDate> {
  const question = await selectQuestion(question_id, instance_question_id);
  const { courseIssues, variant: variantData } = await makeVariant(
    question,
    question_course,
    options,
  );
  const variant = await sqldb.callRow(
    'variants_insert',
    [
      variantData.variant_seed,
      variantData.params,
      variantData.true_answer,
      variantData.options,
      variantData.broken,
      instance_question_id,
      question.id,
      course_instance_id,
      user_id,
      authn_user_id,
      group_work,
      require_open,
      variant_course.id,
      client_fingerprint_id,
    ],
    VariantWithFormattedDateSchema,
  );

  const studentMessage = 'Error creating question variant';
  const courseData = { variant, question, course: variant_course };
  await writeCourseIssues(courseIssues, variant, authn_user_id, studentMessage, courseData);
  return variant;
}

/**
 * Ensure that there is a variant for the given instance question.
 *
 * @param question_id - The question for the new variant. Can be null if instance_question_id is provided.
 * @param instance_question_id - The instance question for the new variant, or null for a floating variant.
 * @param user_id - The user for the new variant.
 * @param authn_user_id - The current authenticated user.
 * @param group_work - If the assessment will support group work.
 * @param course_instance_id - The course instance for this variant. Can be null for instructor questions.
 * @param variant_course - The course for the variant.
 * @param question_course - The course for the question.
 * @param options - Options controlling the creation: options = {variant_seed}
 * @param require_open - If true, only use an existing variant if it is open.
 * @param client_fingerprint_id - The client fingerprint for this variant. Can be null.
 */
export async function ensureVariant(
  question_id: string | null,
  instance_question_id: string | null,
  user_id: string,
  authn_user_id: string,
  group_work: boolean,
  course_instance_id: string | null,
  variant_course: Course,
  question_course: Course,
  options: { variant_seed?: string | null },
  require_open: boolean,
  client_fingerprint_id: string | null,
): Promise<VariantWithFormattedDate> {
  if (instance_question_id != null) {
    // see if we have a useable existing variant, otherwise make a new one
    const variant = await sqldb.callOptionalRow(
      'instance_questions_select_variant',
      [instance_question_id, require_open],
      VariantWithFormattedDateSchema.nullable(),
    );
    if (variant != null) {
      return variant;
    }
  }
  // if we don't have instance_question_id or if it's not open, just make a new variant
  return await makeAndInsertVariant(
    question_id,
    instance_question_id,
    user_id,
    authn_user_id,
    group_work,
    course_instance_id,
    variant_course,
    question_course,
    options,
    require_open,
    client_fingerprint_id,
  );
}

/**
 * Get the course associated with the question
 *
 * @param question - The question for the variant.
 * @param variant_course - The course for the variant.
 */
export async function getQuestionCourse(
  question: Question,
  variant_course: Course,
): Promise<Course> {
  if (question.course_id === variant_course.id) {
    return variant_course;
  } else {
    return selectCourseById(question.course_id);
  }
}
